import {
  SvelteMap
} from "./chunk-TKE4VP3B.js";
import "./chunk-7MXQRCDG.js";
import {
  createSubscriber
} from "./chunk-TG2AXNWI.js";
import "./chunk-7RQDXF5S.js";
import {
  append_styles,
  attribute_effect,
  bind_this,
  bind_value,
  component,
  createAttachmentKey,
  each,
  element,
  if_block,
  init,
  key_block,
  onMount,
  prop,
  remove_input_defaults,
  rest_props,
  set_attribute,
  set_selected,
  set_style,
  snippet,
  spread_props
} from "./chunk-EOB5ZLR7.js";
import {
  append,
  comment,
  from_html,
  from_svg,
  mount,
  props_id,
  set_text,
  text,
  unmount
} from "./chunk-UR5WURMW.js";
import {
  child,
  derived_safe_equal,
  effect_root,
  first_child,
  get,
  getAllContexts,
  getContext,
  hasContext,
  next,
  noop,
  on,
  pop,
  proxy,
  push,
  replay_events,
  reset,
  set,
  setContext,
  sibling,
  snapshot,
  state,
  template_effect,
  tick,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-JDXWA2GI.js";
import "./chunk-MER2FNS2.js";
import {
  false_default,
  true_default
} from "./chunk-CNXG7EOH.js";
import "./chunk-QRCWDNKT.js";
import "./chunk-NTBXCXB5.js";
import "./chunk-OKMPZSYG.js";
import {
  StyleToObject
} from "./chunk-4HF7MGII.js";
import {
  $11d87f3f76e88657$export$b4a036af3fc0b032,
  $14e0f24ef4ac5c92$export$2061056d06d7cdf7,
  $14e0f24ef4ac5c92$export$629b0a497aa65267,
  $14e0f24ef4ac5c92$export$a18c89cbd24170ff,
  $14e0f24ef4ac5c92$export$a2258d9c4118825c,
  $14e0f24ef4ac5c92$export$a5a3b454ada2268e,
  $14e0f24ef4ac5c92$export$aa8b41735afcabd2,
  $14e0f24ef4ac5c92$export$ea39ec197993aef0,
  $35ea8db9cb2ccb90$export$680ea196effce5f,
  $35ea8db9cb2ccb90$export$99faa760c7908e4f,
  $35ea8db9cb2ccb90$export$ca871e8dbb80966f,
  $35ea8db9cb2ccb90$export$d3b7288e7994edea,
  $fae977aafc393c5c$export$588937bcd60ade55,
  $fae977aafc393c5c$export$6b862160d295c8e,
  $fae977aafc393c5c$export$fd7893f06e92a6a4,
  $fb18d541ea1ad717$export$ad991b66133851cf
} from "./chunk-7F6MK5HD.js";
import {
  focusable,
  isFocusable,
  isTabbable,
  tabbable
} from "./chunk-UJ7JXMTJ.js";
import {
  arrow,
  autoUpdate,
  computePosition,
  flip,
  hide,
  limitShift,
  offset,
  shift,
  size
} from "./chunk-JCU57T2W.js";
import {
  clsx
} from "./chunk-KDVGFZWC.js";
import {
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-6LNZPZHA.js";

// node_modules/bits-ui/dist/bits/accordion/exports.js
var exports_exports = {};
__export(exports_exports, {
  Content: () => Accordion_content,
  Header: () => Accordion_header,
  Item: () => Accordion_item,
  Root: () => Accordion,
  Trigger: () => Accordion_trigger
});

// node_modules/svelte-toolbelt/dist/utils/is.js
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
var CLASS_VALUE_PRIMITIVE_TYPES = ["string", "number", "bigint", "boolean"];
function isClassValue(value) {
  if (value === null || value === void 0)
    return true;
  if (CLASS_VALUE_PRIMITIVE_TYPES.includes(typeof value))
    return true;
  if (Array.isArray(value))
    return value.every((item) => isClassValue(item));
  if (typeof value === "object") {
    if (Object.getPrototypeOf(value) !== Object.prototype)
      return false;
    return true;
  }
  return false;
}

// node_modules/svelte-toolbelt/dist/box/box-extras.svelte.js
var BoxSymbol = Symbol("box");
var isWritableSymbol = Symbol("is-writable");
function boxWith(getter, setter) {
  const derived = user_derived(getter);
  if (setter) {
    return {
      [BoxSymbol]: true,
      [isWritableSymbol]: true,
      get current() {
        return get(derived);
      },
      set current(v) {
        setter(v);
      }
    };
  }
  return {
    [BoxSymbol]: true,
    get current() {
      return getter();
    }
  };
}
function isBox(value) {
  return isObject(value) && BoxSymbol in value;
}
function isWritableBox(value) {
  return isBox(value) && isWritableSymbol in value;
}
function boxFrom(value) {
  if (isBox(value)) return value;
  if (isFunction(value)) return boxWith(value);
  return simpleBox(value);
}
function boxFlatten(boxes) {
  return Object.entries(boxes).reduce(
    (acc, [key, b]) => {
      if (!isBox(b)) {
        return Object.assign(acc, { [key]: b });
      }
      if (isWritableBox(b)) {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          },
          set(v) {
            b.current = v;
          }
        });
      } else {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          }
        });
      }
      return acc;
    },
    {}
  );
}
function toReadonlyBox(b) {
  if (!isWritableBox(b)) return b;
  return {
    [BoxSymbol]: true,
    get current() {
      return b.current;
    }
  };
}
function simpleBox(initialValue) {
  let current = state(proxy(initialValue));
  return {
    [BoxSymbol]: true,
    [isWritableSymbol]: true,
    get current() {
      return get(current);
    },
    set current(v) {
      set(current, v, true);
    }
  };
}

// node_modules/svelte-toolbelt/dist/box/box.svelte.js
function box(initialValue) {
  let current = state(proxy(initialValue));
  return {
    [BoxSymbol]: true,
    [isWritableSymbol]: true,
    get current() {
      return get(current);
    },
    set current(v) {
      set(current, v, true);
    }
  };
}
box.from = boxFrom;
box.with = boxWith;
box.flatten = boxFlatten;
box.readonly = toReadonlyBox;
box.isBox = isBox;
box.isWritableBox = isWritableBox;

// node_modules/svelte-toolbelt/dist/utils/compose-handlers.js
function composeHandlers(...handlers) {
  return function(e) {
    var _a;
    for (const handler of handlers) {
      if (!handler)
        continue;
      if (e.defaultPrevented)
        return;
      if (typeof handler === "function") {
        handler.call(this, e);
      } else {
        (_a = handler.current) == null ? void 0 : _a.call(this, e);
      }
    }
  };
}

// node_modules/svelte-toolbelt/dist/utils/strings.js
var NUMBER_CHAR_RE = /\d/;
var STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char))
    return void 0;
  return char !== char.toLowerCase();
}
function splitByCase(str) {
  const parts = [];
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of str) {
    const isSplitter = STR_SPLITTERS.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = void 0;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function pascalCase(str) {
  if (!str)
    return "";
  return splitByCase(str).map((p2) => upperFirst(p2)).join("");
}
function camelCase(str) {
  return lowerFirst(pascalCase(str || ""));
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}
function lowerFirst(str) {
  return str ? str[0].toLowerCase() + str.slice(1) : "";
}

// node_modules/svelte-toolbelt/dist/utils/css-to-style-obj.js
function cssToStyleObj(css) {
  if (!css)
    return {};
  const styleObj = {};
  function iterator(name, value) {
    if (name.startsWith("-moz-") || name.startsWith("-webkit-") || name.startsWith("-ms-") || name.startsWith("-o-")) {
      styleObj[pascalCase(name)] = value;
      return;
    }
    if (name.startsWith("--")) {
      styleObj[name] = value;
      return;
    }
    styleObj[camelCase(name)] = value;
  }
  StyleToObject(css, iterator);
  return styleObj;
}

// node_modules/svelte-toolbelt/dist/utils/execute-callbacks.js
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}

// node_modules/svelte-toolbelt/dist/utils/style-to-css.js
function createParser(matcher, replacer) {
  const regex = RegExp(matcher, "g");
  return (str) => {
    if (typeof str !== "string") {
      throw new TypeError(`expected an argument of type string, but got ${typeof str}`);
    }
    if (!str.match(regex))
      return str;
    return str.replace(regex, replacer);
  };
}
var camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);
function styleToCSS(styleObj) {
  if (!styleObj || typeof styleObj !== "object" || Array.isArray(styleObj)) {
    throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);
  }
  return Object.keys(styleObj).map((property) => `${camelToKebab(property)}: ${styleObj[property]};`).join("\n");
}

// node_modules/svelte-toolbelt/dist/utils/style.js
function styleToString(style = {}) {
  return styleToCSS(style).replace("\n", " ");
}

// node_modules/svelte-toolbelt/dist/utils/event-list.js
var EVENT_LIST = [
  "onabort",
  "onanimationcancel",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  "onauxclick",
  "onbeforeinput",
  "onbeforetoggle",
  "onblur",
  "oncancel",
  "oncanplay",
  "oncanplaythrough",
  "onchange",
  "onclick",
  "onclose",
  "oncompositionend",
  "oncompositionstart",
  "oncompositionupdate",
  "oncontextlost",
  "oncontextmenu",
  "oncontextrestored",
  "oncopy",
  "oncuechange",
  "oncut",
  "ondblclick",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onended",
  "onerror",
  "onfocus",
  "onfocusin",
  "onfocusout",
  "onformdata",
  "ongotpointercapture",
  "oninput",
  "oninvalid",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onload",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onlostpointercapture",
  "onmousedown",
  "onmouseenter",
  "onmouseleave",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onpaste",
  "onpause",
  "onplay",
  "onplaying",
  "onpointercancel",
  "onpointerdown",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointerout",
  "onpointerover",
  "onpointerup",
  "onprogress",
  "onratechange",
  "onreset",
  "onresize",
  "onscroll",
  "onscrollend",
  "onsecuritypolicyviolation",
  "onseeked",
  "onseeking",
  "onselect",
  "onselectionchange",
  "onselectstart",
  "onslotchange",
  "onstalled",
  "onsubmit",
  "onsuspend",
  "ontimeupdate",
  "ontoggle",
  "ontouchcancel",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ontransitioncancel",
  "ontransitionend",
  "ontransitionrun",
  "ontransitionstart",
  "onvolumechange",
  "onwaiting",
  "onwebkitanimationend",
  "onwebkitanimationiteration",
  "onwebkitanimationstart",
  "onwebkittransitionend",
  "onwheel"
];
var EVENT_LIST_SET = new Set(EVENT_LIST);

// node_modules/svelte-toolbelt/dist/utils/merge-props.js
function isEventHandler(key) {
  return EVENT_LIST_SET.has(key);
}
function mergeProps(...args) {
  const result = { ...args[0] };
  for (let i = 1; i < args.length; i++) {
    const props = args[i];
    if (!props)
      continue;
    for (const key of Object.keys(props)) {
      const a2 = result[key];
      const b = props[key];
      const aIsFunction = typeof a2 === "function";
      const bIsFunction = typeof b === "function";
      if (aIsFunction && typeof bIsFunction && isEventHandler(key)) {
        const aHandler = a2;
        const bHandler = b;
        result[key] = composeHandlers(aHandler, bHandler);
      } else if (aIsFunction && bIsFunction) {
        result[key] = executeCallbacks(a2, b);
      } else if (key === "class") {
        const aIsClassValue = isClassValue(a2);
        const bIsClassValue = isClassValue(b);
        if (aIsClassValue && bIsClassValue) {
          result[key] = clsx(a2, b);
        } else if (aIsClassValue) {
          result[key] = clsx(a2);
        } else if (bIsClassValue) {
          result[key] = clsx(b);
        }
      } else if (key === "style") {
        const aIsObject = typeof a2 === "object";
        const bIsObject = typeof b === "object";
        const aIsString = typeof a2 === "string";
        const bIsString = typeof b === "string";
        if (aIsObject && bIsObject) {
          result[key] = { ...a2, ...b };
        } else if (aIsObject && bIsString) {
          const parsedStyle = cssToStyleObj(b);
          result[key] = { ...a2, ...parsedStyle };
        } else if (aIsString && bIsObject) {
          const parsedStyle = cssToStyleObj(a2);
          result[key] = { ...parsedStyle, ...b };
        } else if (aIsString && bIsString) {
          const parsedStyleA = cssToStyleObj(a2);
          const parsedStyleB = cssToStyleObj(b);
          result[key] = { ...parsedStyleA, ...parsedStyleB };
        } else if (aIsObject) {
          result[key] = a2;
        } else if (bIsObject) {
          result[key] = b;
        } else if (aIsString) {
          result[key] = a2;
        } else if (bIsString) {
          result[key] = b;
        }
      } else {
        result[key] = b !== void 0 ? b : a2;
      }
    }
    for (const key of Object.getOwnPropertySymbols(props)) {
      const a2 = result[key];
      const b = props[key];
      result[key] = b !== void 0 ? b : a2;
    }
  }
  if (typeof result.style === "object") {
    result.style = styleToString(result.style).replaceAll("\n", " ");
  }
  if (result.hidden === false) {
    result.hidden = void 0;
    delete result.hidden;
  }
  if (result.disabled === false) {
    result.disabled = void 0;
    delete result.disabled;
  }
  return result;
}

// node_modules/svelte-toolbelt/dist/utils/sr-only-styles.js
var srOnlyStyles = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
var srOnlyStylesString = styleToString(srOnlyStyles);

// node_modules/runed/dist/internal/configurable-globals.js
var defaultWindow = true_default && typeof window !== "undefined" ? window : void 0;
var defaultDocument = true_default && typeof window !== "undefined" ? window.document : void 0;
var defaultNavigator = true_default && typeof window !== "undefined" ? window.navigator : void 0;
var defaultLocation = true_default && typeof window !== "undefined" ? window.location : void 0;

// node_modules/runed/dist/internal/utils/dom.js
function getActiveElement(document2) {
  let activeElement2 = document2.activeElement;
  while (activeElement2 == null ? void 0 : activeElement2.shadowRoot) {
    const node = activeElement2.shadowRoot.activeElement;
    if (node === activeElement2)
      break;
    else
      activeElement2 = node;
  }
  return activeElement2;
}

// node_modules/runed/dist/utilities/active-element/active-element.svelte.js
var _document, _subscribe;
var ActiveElement = class {
  constructor(options = {}) {
    __privateAdd(this, _document);
    __privateAdd(this, _subscribe);
    const {
      window: window2 = defaultWindow,
      document: document2 = window2 == null ? void 0 : window2.document
    } = options;
    if (window2 === void 0) return;
    __privateSet(this, _document, document2);
    __privateSet(this, _subscribe, createSubscriber((update2) => {
      const cleanupFocusIn = on(window2, "focusin", update2);
      const cleanupFocusOut = on(window2, "focusout", update2);
      return () => {
        cleanupFocusIn();
        cleanupFocusOut();
      };
    }));
  }
  get current() {
    var _a;
    (_a = __privateGet(this, _subscribe)) == null ? void 0 : _a.call(this);
    if (!__privateGet(this, _document)) return null;
    return getActiveElement(__privateGet(this, _document));
  }
};
_document = new WeakMap();
_subscribe = new WeakMap();
var activeElement = new ActiveElement();

// node_modules/runed/dist/internal/utils/is.js
function isFunction2(value) {
  return typeof value === "function";
}

// node_modules/runed/dist/utilities/extract/extract.svelte.js
function extract(value, defaultValue) {
  if (isFunction2(value)) {
    const getter = value;
    const gotten = getter();
    if (gotten === void 0) return defaultValue;
    return gotten;
  }
  if (value === void 0) return defaultValue;
  return value;
}

// node_modules/runed/dist/utilities/context/context.js
var _name, _key;
var Context = class {
  /**
   * @param name The name of the context.
   * This is used for generating the context key and error messages.
   */
  constructor(name) {
    __privateAdd(this, _name);
    __privateAdd(this, _key);
    __privateSet(this, _name, name);
    __privateSet(this, _key, Symbol(name));
  }
  /**
   * The key used to get and set the context.
   *
   * It is not recommended to use this value directly.
   * Instead, use the methods provided by this class.
   */
  get key() {
    return __privateGet(this, _key);
  }
  /**
   * Checks whether this has been set in the context of a parent component.
   *
   * Must be called during component initialisation.
   */
  exists() {
    return hasContext(__privateGet(this, _key));
  }
  /**
   * Retrieves the context that belongs to the closest parent component.
   *
   * Must be called during component initialisation.
   *
   * @throws An error if the context does not exist.
   */
  get() {
    const context = getContext(__privateGet(this, _key));
    if (context === void 0) {
      throw new Error(`Context "${__privateGet(this, _name)}" not found`);
    }
    return context;
  }
  /**
   * Retrieves the context that belongs to the closest parent component,
   * or the given fallback value if the context does not exist.
   *
   * Must be called during component initialisation.
   */
  getOr(fallback) {
    const context = getContext(__privateGet(this, _key));
    if (context === void 0) {
      return fallback;
    }
    return context;
  }
  /**
   * Associates the given value with the current component and returns it.
   *
   * Must be called during component initialisation.
   */
  set(context) {
    return setContext(__privateGet(this, _key), context);
  }
};
_name = new WeakMap();
_key = new WeakMap();

// node_modules/runed/dist/utilities/use-debounce/use-debounce.svelte.js
function useDebounce(callback, wait) {
  let context = state(null);
  const wait$ = user_derived(() => extract(wait, 250));
  function debounced(...args) {
    if (get(context)) {
      if (get(context).timeout) {
        clearTimeout(get(context).timeout);
      }
    } else {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      set(
        context,
        {
          timeout: null,
          runner: null,
          promise,
          resolve,
          reject
        },
        true
      );
    }
    get(context).runner = async () => {
      if (!get(context)) return;
      const ctx = get(context);
      set(context, null);
      try {
        ctx.resolve(await callback.apply(this, args));
      } catch (error) {
        ctx.reject(error);
      }
    };
    get(context).timeout = setTimeout(get(context).runner, get(wait$));
    return get(context).promise;
  }
  debounced.cancel = async () => {
    if (!get(context) || get(context).timeout === null) {
      await new Promise((resolve) => setTimeout(resolve, 0));
      if (!get(context) || get(context).timeout === null) return;
    }
    clearTimeout(get(context).timeout);
    get(context).reject("Cancelled");
    set(context, null);
  };
  debounced.runScheduledNow = async () => {
    var _a, _b;
    if (!get(context) || !get(context).timeout) {
      await new Promise((resolve) => setTimeout(resolve, 0));
      if (!get(context) || !get(context).timeout) return;
    }
    clearTimeout(get(context).timeout);
    get(context).timeout = null;
    await ((_b = (_a = get(context)).runner) == null ? void 0 : _b.call(_a));
  };
  Object.defineProperty(debounced, "pending", {
    enumerable: true,
    get() {
      var _a;
      return !!((_a = get(context)) == null ? void 0 : _a.timeout);
    }
  });
  return debounced;
}

// node_modules/runed/dist/utilities/watch/watch.svelte.js
function runEffect(flush, effect) {
  switch (flush) {
    case "post":
      user_effect(effect);
      break;
    case "pre":
      user_pre_effect(effect);
      break;
  }
}
function runWatcher(sources, flush, effect, options = {}) {
  const { lazy = false } = options;
  let active = !lazy;
  let previousValues = Array.isArray(sources) ? [] : void 0;
  runEffect(flush, () => {
    const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();
    if (!active) {
      active = true;
      previousValues = values;
      return;
    }
    const cleanup = untrack(() => effect(values, previousValues));
    previousValues = values;
    return cleanup;
  });
}
function runWatcherOnce(sources, flush, effect) {
  const cleanupRoot = effect_root(() => {
    let stop = false;
    runWatcher(
      sources,
      flush,
      (values, previousValues) => {
        if (stop) {
          cleanupRoot();
          return;
        }
        const cleanup = effect(values, previousValues);
        stop = true;
        return cleanup;
      },
      // Running the effect immediately just once makes no sense at all.
      // That's just `onMount` with extra steps.
      { lazy: true }
    );
  });
  user_effect(() => {
    return cleanupRoot;
  });
}
function watch(sources, effect, options) {
  runWatcher(sources, "post", effect, options);
}
function watchPre(sources, effect, options) {
  runWatcher(sources, "pre", effect, options);
}
watch.pre = watchPre;
function watchOnce(source, effect) {
  runWatcherOnce(source, "post", effect);
}
function watchOncePre(source, effect) {
  runWatcherOnce(source, "pre", effect);
}
watchOnce.pre = watchOncePre;

// node_modules/runed/dist/internal/utils/get.js
function get2(value) {
  if (isFunction2(value)) {
    return value();
  }
  return value;
}

// node_modules/runed/dist/utilities/element-size/element-size.svelte.js
var _size, _observed, _options, _node, _window, _width, _height, _subscribe2;
var ElementSize = class {
  constructor(node, options = { box: "border-box" }) {
    // no need to use `$state` here since we are using createSubscriber
    __privateAdd(this, _size, { width: 0, height: 0 });
    __privateAdd(this, _observed, false);
    __privateAdd(this, _options);
    __privateAdd(this, _node);
    __privateAdd(this, _window);
    // we use a derived here to extract the width so that if the width doesn't change we don't get a state update
    // which we would get if we would just use a getter since the version of the subscriber will be changing
    __privateAdd(this, _width, user_derived(() => {
      var _a;
      (_a = get(__privateGet(this, _subscribe2))) == null ? void 0 : _a();
      return this.getSize().width;
    }));
    // we use a derived here to extract the height so that if the height doesn't change we don't get a state update
    // which we would get if we would just use a getter since the version of the subscriber will be changing
    __privateAdd(this, _height, user_derived(() => {
      var _a;
      (_a = get(__privateGet(this, _subscribe2))) == null ? void 0 : _a();
      return this.getSize().height;
    }));
    // we need to use a derived here because the class will be created before the node is bound to the ref
    __privateAdd(this, _subscribe2, user_derived(() => {
      const node$ = get2(__privateGet(this, _node));
      if (!node$) return;
      return createSubscriber((update2) => {
        if (!__privateGet(this, _window)) return;
        const observer = new (__privateGet(this, _window)).ResizeObserver((entries) => {
          __privateSet(this, _observed, true);
          for (const entry of entries) {
            const boxSize = __privateGet(this, _options).box === "content-box" ? entry.contentBoxSize : entry.borderBoxSize;
            const boxSizeArr = Array.isArray(boxSize) ? boxSize : [boxSize];
            __privateGet(this, _size).width = boxSizeArr.reduce((acc, size2) => Math.max(acc, size2.inlineSize), 0);
            __privateGet(this, _size).height = boxSizeArr.reduce((acc, size2) => Math.max(acc, size2.blockSize), 0);
          }
          update2();
        });
        observer.observe(node$);
        return () => {
          __privateSet(this, _observed, false);
          observer.disconnect();
        };
      });
    }));
    __privateSet(this, _window, options.window ?? defaultWindow);
    __privateSet(this, _options, options);
    __privateSet(this, _node, node);
    __privateSet(this, _size, { width: 0, height: 0 });
  }
  calculateSize() {
    const element2 = get2(__privateGet(this, _node));
    if (!element2 || !__privateGet(this, _window)) {
      return;
    }
    const offsetWidth = element2.offsetWidth;
    const offsetHeight = element2.offsetHeight;
    if (__privateGet(this, _options).box === "border-box") {
      return { width: offsetWidth, height: offsetHeight };
    }
    const style = __privateGet(this, _window).getComputedStyle(element2);
    const paddingWidth = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    const paddingHeight = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    const borderWidth = parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
    const borderHeight = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
    const contentWidth = offsetWidth - paddingWidth - borderWidth;
    const contentHeight = offsetHeight - paddingHeight - borderHeight;
    return { width: contentWidth, height: contentHeight };
  }
  getSize() {
    return __privateGet(this, _observed) ? __privateGet(this, _size) : this.calculateSize() ?? __privateGet(this, _size);
  }
  get current() {
    var _a;
    (_a = get(__privateGet(this, _subscribe2))) == null ? void 0 : _a();
    return this.getSize();
  }
  get width() {
    return get(__privateGet(this, _width));
  }
  get height() {
    return get(__privateGet(this, _height));
  }
};
_size = new WeakMap();
_observed = new WeakMap();
_options = new WeakMap();
_node = new WeakMap();
_window = new WeakMap();
_width = new WeakMap();
_height = new WeakMap();
_subscribe2 = new WeakMap();

// node_modules/runed/dist/utilities/is-mounted/is-mounted.svelte.js
var _isMounted;
var IsMounted = class {
  constructor() {
    __privateAdd(this, _isMounted, state(false));
    user_effect(() => {
      untrack(() => set(__privateGet(this, _isMounted), true));
      return () => {
        set(__privateGet(this, _isMounted), false);
      };
    });
  }
  get current() {
    return get(__privateGet(this, _isMounted));
  }
};
_isMounted = new WeakMap();

// node_modules/runed/dist/utilities/previous/previous.svelte.js
var _previousCallback, _previous;
var Previous = class {
  constructor(getter, initialValue) {
    __privateAdd(this, _previousCallback, () => void 0);
    __privateAdd(this, _previous, user_derived(() => __privateGet(this, _previousCallback).call(this)));
    let actualPrevious = void 0;
    if (initialValue !== void 0) actualPrevious = initialValue;
    __privateSet(this, _previousCallback, () => {
      try {
        return actualPrevious;
      } finally {
        actualPrevious = getter();
      }
    });
  }
  get current() {
    return get(__privateGet(this, _previous));
  }
};
_previousCallback = new WeakMap();
_previous = new WeakMap();

// node_modules/runed/dist/utilities/resource/resource.svelte.js
function debounce(fn, delay) {
  let timeoutId;
  let lastResolve = null;
  return (...args) => {
    return new Promise((resolve) => {
      if (lastResolve) {
        lastResolve(void 0);
      }
      lastResolve = resolve;
      clearTimeout(timeoutId);
      timeoutId = setTimeout(
        async () => {
          const result = await fn(...args);
          if (lastResolve) {
            lastResolve(result);
            lastResolve = null;
          }
        },
        delay
      );
    });
  };
}
function throttle(fn, delay) {
  let lastRun = 0;
  let lastPromise = null;
  return (...args) => {
    const now = Date.now();
    if (lastRun && now - lastRun < delay) {
      return lastPromise ?? Promise.resolve(void 0);
    }
    lastRun = now;
    lastPromise = fn(...args);
    return lastPromise;
  };
}
function runResource(source, fetcher, options = {}, effectFn) {
  const {
    lazy = false,
    once = false,
    initialValue,
    debounce: debounceTime,
    throttle: throttleTime
  } = options;
  let current = state(proxy(initialValue));
  let loading = state(false);
  let error = state(void 0);
  let cleanupFns = state(proxy([]));
  const runCleanup = () => {
    get(cleanupFns).forEach((fn) => fn());
    set(cleanupFns, [], true);
  };
  const onCleanup2 = (fn) => {
    set(cleanupFns, [...get(cleanupFns), fn], true);
  };
  const baseFetcher = async (value, previousValue, refetching = false) => {
    try {
      set(loading, true);
      set(error, void 0);
      runCleanup();
      const controller = new AbortController();
      onCleanup2(() => controller.abort());
      const result = await fetcher(value, previousValue, {
        data: get(current),
        refetching,
        onCleanup: onCleanup2,
        signal: controller.signal
      });
      set(current, result, true);
      return result;
    } catch (e) {
      if (!(e instanceof DOMException && e.name === "AbortError")) {
        set(error, e, true);
      }
      return void 0;
    } finally {
      set(loading, false);
    }
  };
  const runFetcher = debounceTime ? debounce(baseFetcher, debounceTime) : throttleTime ? throttle(baseFetcher, throttleTime) : baseFetcher;
  const sources = Array.isArray(source) ? source : [source];
  let prevValues;
  effectFn(
    (values, previousValues) => {
      if (once && prevValues) {
        return;
      }
      prevValues = values;
      runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? previousValues : previousValues == null ? void 0 : previousValues[0]);
    },
    { lazy }
  );
  return {
    get current() {
      return get(current);
    },
    get loading() {
      return get(loading);
    },
    get error() {
      return get(error);
    },
    mutate: (value) => {
      set(current, value, true);
    },
    refetch: (info) => {
      const values = sources.map((s) => s());
      return runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? values : values[0], info ?? true);
    }
  };
}
function resource(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getters = () => sources.map((s) => s());
    watch(
      getters,
      (values, previousValues) => {
        fn(values, previousValues ?? []);
      },
      options2
    );
  });
}
function resourcePre(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getter = () => sources.map((s) => s());
    watch.pre(
      getter,
      (values, previousValues) => {
        fn(values, previousValues ?? []);
      },
      options2
    );
  });
}
resource.pre = resourcePre;

// node_modules/svelte-toolbelt/dist/utils/on-destroy-effect.svelte.js
function onDestroyEffect(fn) {
  user_effect(() => {
    return () => {
      fn();
    };
  });
}

// node_modules/svelte-toolbelt/dist/utils/on-mount-effect.svelte.js
function onMountEffect(fn) {
  user_effect(() => {
    const cleanup = untrack(() => fn());
    return cleanup;
  });
}

// node_modules/svelte-toolbelt/dist/utils/after-sleep.js
function afterSleep(ms, cb) {
  return setTimeout(cb, ms);
}

// node_modules/svelte-toolbelt/dist/utils/after-tick.js
function afterTick(fn) {
  tick().then(fn);
}

// node_modules/svelte-toolbelt/dist/utils/dom.js
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
function isHTMLElement(node) {
  return isObject(node) && node.nodeType === ELEMENT_NODE && typeof node.nodeName === "string";
}
function isDocument(node) {
  return isObject(node) && node.nodeType === DOCUMENT_NODE;
}
function isWindow(node) {
  var _a;
  return isObject(node) && ((_a = node.constructor) == null ? void 0 : _a.name) === "VisualViewport";
}
function isNode(node) {
  return isObject(node) && node.nodeType !== void 0;
}
function isShadowRoot(node) {
  return isNode(node) && node.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in node;
}
function contains(parent, child2) {
  var _a;
  if (!parent || !child2)
    return false;
  if (!isHTMLElement(parent) || !isHTMLElement(child2))
    return false;
  const rootNode = (_a = child2.getRootNode) == null ? void 0 : _a.call(child2);
  if (parent === child2)
    return true;
  if (parent.contains(child2))
    return true;
  if (rootNode && isShadowRoot(rootNode)) {
    let next3 = child2;
    while (next3) {
      if (parent === next3)
        return true;
      next3 = next3.parentNode || next3.host;
    }
  }
  return false;
}
function getDocument(node) {
  if (isDocument(node))
    return node;
  if (isWindow(node))
    return node.document;
  return (node == null ? void 0 : node.ownerDocument) ?? document;
}
function getWindow(node) {
  var _a;
  if (isShadowRoot(node))
    return getWindow(node.host);
  if (isDocument(node))
    return node.defaultView ?? window;
  if (isHTMLElement(node))
    return ((_a = node.ownerDocument) == null ? void 0 : _a.defaultView) ?? window;
  return window;
}
function getActiveElement2(rootNode) {
  let activeElement2 = rootNode.activeElement;
  while (activeElement2 == null ? void 0 : activeElement2.shadowRoot) {
    const el = activeElement2.shadowRoot.activeElement;
    if (el === activeElement2)
      break;
    else
      activeElement2 = el;
  }
  return activeElement2;
}

// node_modules/svelte-toolbelt/dist/utils/dom-context.svelte.js
var _root;
var DOMContext = class {
  constructor(element2) {
    __publicField(this, "element");
    __privateAdd(this, _root, user_derived(() => {
      if (!this.element.current) return document;
      const rootNode = this.element.current.getRootNode() ?? document;
      return rootNode;
    }));
    __publicField(this, "getDocument", () => {
      return getDocument(this.root);
    });
    __publicField(this, "getWindow", () => {
      return this.getDocument().defaultView ?? window;
    });
    __publicField(this, "getActiveElement", () => {
      return getActiveElement2(this.root);
    });
    __publicField(this, "isActiveElement", (node) => {
      return node === this.getActiveElement();
    });
    __publicField(this, "querySelector", (selector) => {
      if (!this.root) return null;
      return this.root.querySelector(selector);
    });
    __publicField(this, "querySelectorAll", (selector) => {
      if (!this.root) return [];
      return this.root.querySelectorAll(selector);
    });
    __publicField(this, "setTimeout", (callback, delay) => {
      return this.getWindow().setTimeout(callback, delay);
    });
    __publicField(this, "clearTimeout", (timeoutId) => {
      return this.getWindow().clearTimeout(timeoutId);
    });
    if (typeof element2 === "function") {
      this.element = boxWith(element2);
    } else {
      this.element = element2;
    }
  }
  get root() {
    return get(__privateGet(this, _root));
  }
  set root(value) {
    set(__privateGet(this, _root), value);
  }
  getElementById(id) {
    return this.root.getElementById(id);
  }
};
_root = new WeakMap();

// node_modules/svelte-toolbelt/dist/utils/attach-ref.js
function attachRef(ref, onChange) {
  return {
    [createAttachmentKey()]: (node) => {
      if (isBox(ref)) {
        ref.current = node;
        untrack(() => onChange == null ? void 0 : onChange(node));
        return () => {
          if ("isConnected" in node && node.isConnected)
            return;
          ref.current = null;
          onChange == null ? void 0 : onChange(null);
        };
      }
      ref(node);
      untrack(() => onChange == null ? void 0 : onChange(node));
      return () => {
        if ("isConnected" in node && node.isConnected)
          return;
        ref(null);
        onChange == null ? void 0 : onChange(null);
      };
    }
  };
}

// node_modules/bits-ui/dist/internal/attrs.js
function boolToStr(condition) {
  return condition ? "true" : "false";
}
function boolToStrTrueOrUndef(condition) {
  return condition ? "true" : void 0;
}
function boolToEmptyStrOrUndef(condition) {
  return condition ? "" : void 0;
}
function boolToTrueOrUndef(condition) {
  return condition ? true : void 0;
}
function getDataOpenClosed(condition) {
  return condition ? "open" : "closed";
}
function getDataChecked(condition) {
  return condition ? "checked" : "unchecked";
}
function getAriaChecked(checked, indeterminate) {
  if (indeterminate) {
    return "mixed";
  }
  return checked ? "true" : "false";
}
var _variant, _prefix;
var BitsAttrs = class {
  constructor(config) {
    __privateAdd(this, _variant);
    __privateAdd(this, _prefix);
    __publicField(this, "attrs");
    __privateSet(this, _variant, config.getVariant ? config.getVariant() : null);
    __privateSet(this, _prefix, __privateGet(this, _variant) ? `data-${__privateGet(this, _variant)}-` : `data-${config.component}-`);
    this.getAttr = this.getAttr.bind(this);
    this.selector = this.selector.bind(this);
    this.attrs = Object.fromEntries(config.parts.map((part) => [part, this.getAttr(part)]));
  }
  getAttr(part, variantOverride) {
    if (variantOverride)
      return `data-${variantOverride}-${part}`;
    return `${__privateGet(this, _prefix)}${part}`;
  }
  selector(part, variantOverride) {
    return `[${this.getAttr(part, variantOverride)}]`;
  }
};
_variant = new WeakMap();
_prefix = new WeakMap();
function createBitsAttrs(config) {
  const bitsAttrs = new BitsAttrs(config);
  return {
    ...bitsAttrs.attrs,
    selector: bitsAttrs.selector,
    getAttr: bitsAttrs.getAttr
  };
}

// node_modules/bits-ui/dist/internal/kbd-constants.js
var kbd_constants_exports = {};
__export(kbd_constants_exports, {
  A: () => A,
  ALT: () => ALT,
  ARROW_DOWN: () => ARROW_DOWN,
  ARROW_LEFT: () => ARROW_LEFT,
  ARROW_RIGHT: () => ARROW_RIGHT,
  ARROW_UP: () => ARROW_UP,
  ASTERISK: () => ASTERISK,
  BACKSPACE: () => BACKSPACE,
  CAPS_LOCK: () => CAPS_LOCK,
  CONTROL: () => CONTROL,
  CTRL: () => CTRL,
  DELETE: () => DELETE,
  END: () => END,
  ENTER: () => ENTER,
  ESCAPE: () => ESCAPE,
  F1: () => F1,
  F10: () => F10,
  F11: () => F11,
  F12: () => F12,
  F2: () => F2,
  F3: () => F3,
  F4: () => F4,
  F5: () => F5,
  F6: () => F6,
  F7: () => F7,
  F8: () => F8,
  F9: () => F9,
  HOME: () => HOME,
  META: () => META,
  P: () => P,
  PAGE_DOWN: () => PAGE_DOWN,
  PAGE_UP: () => PAGE_UP,
  SHIFT: () => SHIFT,
  SPACE: () => SPACE,
  TAB: () => TAB,
  a: () => a,
  h: () => h,
  j: () => j,
  k: () => k,
  l: () => l,
  n: () => n,
  p: () => p
});
var ALT = "Alt";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var ARROW_UP = "ArrowUp";
var BACKSPACE = "Backspace";
var CAPS_LOCK = "CapsLock";
var CONTROL = "Control";
var DELETE = "Delete";
var END = "End";
var ENTER = "Enter";
var ESCAPE = "Escape";
var F1 = "F1";
var F10 = "F10";
var F11 = "F11";
var F12 = "F12";
var F2 = "F2";
var F3 = "F3";
var F4 = "F4";
var F5 = "F5";
var F6 = "F6";
var F7 = "F7";
var F8 = "F8";
var F9 = "F9";
var HOME = "Home";
var META = "Meta";
var PAGE_DOWN = "PageDown";
var PAGE_UP = "PageUp";
var SHIFT = "Shift";
var SPACE = " ";
var TAB = "Tab";
var CTRL = "Control";
var ASTERISK = "*";
var a = "a";
var P = "P";
var A = "A";
var p = "p";
var n = "n";
var j = "j";
var k = "k";
var h = "h";
var l = "l";

// node_modules/bits-ui/dist/internal/locale.js
function getElemDirection(elem) {
  const style = window.getComputedStyle(elem);
  const direction = style.getPropertyValue("direction");
  return direction;
}

// node_modules/bits-ui/dist/internal/get-directional-keys.js
var FIRST_KEYS = [kbd_constants_exports.ARROW_DOWN, kbd_constants_exports.PAGE_UP, kbd_constants_exports.HOME];
var LAST_KEYS = [kbd_constants_exports.ARROW_UP, kbd_constants_exports.PAGE_DOWN, kbd_constants_exports.END];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SELECTION_KEYS = [kbd_constants_exports.SPACE, kbd_constants_exports.ENTER];
function getNextKey(dir = "ltr", orientation = "horizontal") {
  return {
    horizontal: dir === "rtl" ? kbd_constants_exports.ARROW_LEFT : kbd_constants_exports.ARROW_RIGHT,
    vertical: kbd_constants_exports.ARROW_DOWN
  }[orientation];
}
function getPrevKey(dir = "ltr", orientation = "horizontal") {
  return {
    horizontal: dir === "rtl" ? kbd_constants_exports.ARROW_RIGHT : kbd_constants_exports.ARROW_LEFT,
    vertical: kbd_constants_exports.ARROW_UP
  }[orientation];
}
function getDirectionalKeys(dir = "ltr", orientation = "horizontal") {
  if (!["ltr", "rtl"].includes(dir))
    dir = "ltr";
  if (!["horizontal", "vertical"].includes(orientation))
    orientation = "horizontal";
  return {
    nextKey: getNextKey(dir, orientation),
    prevKey: getPrevKey(dir, orientation)
  };
}

// node_modules/bits-ui/dist/internal/is.js
var isBrowser = typeof document !== "undefined";
var isIOS = getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isBrowser && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || // The new iPad Pro Gen3 does not identify itself as iPad, but as Macintosh.
  ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function isHTMLElement2(element2) {
  return element2 instanceof HTMLElement;
}
function isElement2(element2) {
  return element2 instanceof Element;
}
function isElementOrSVGElement(element2) {
  return element2 instanceof Element || element2 instanceof SVGElement;
}
function isNumberString(value) {
  return !Number.isNaN(Number(value)) && !Number.isNaN(Number.parseFloat(value));
}
function isNull(value) {
  return value === null;
}
function isTouch(e) {
  return e.pointerType === "touch";
}
function isFocusVisible(element2) {
  return element2.matches(":focus-visible");
}
function isNotNull(value) {
  return value !== null;
}
function isSelectableInput(element2) {
  return element2 instanceof HTMLInputElement && "select" in element2;
}

// node_modules/bits-ui/dist/internal/roving-focus-group.js
var _opts, _currentTabStopId;
var RovingFocusGroup = class {
  constructor(opts) {
    __privateAdd(this, _opts);
    __privateAdd(this, _currentTabStopId, box(null));
    __privateSet(this, _opts, opts);
  }
  getCandidateNodes() {
    if (!true_default || !__privateGet(this, _opts).rootNode.current)
      return [];
    if (__privateGet(this, _opts).candidateSelector) {
      const candidates = Array.from(__privateGet(this, _opts).rootNode.current.querySelectorAll(__privateGet(this, _opts).candidateSelector));
      return candidates;
    } else if (__privateGet(this, _opts).candidateAttr) {
      const candidates = Array.from(__privateGet(this, _opts).rootNode.current.querySelectorAll(`[${__privateGet(this, _opts).candidateAttr}]:not([data-disabled])`));
      return candidates;
    }
    return [];
  }
  focusFirstCandidate() {
    var _a;
    const items = this.getCandidateNodes();
    if (!items.length)
      return;
    (_a = items[0]) == null ? void 0 : _a.focus();
  }
  handleKeydown(node, e, both = false) {
    var _a, _b;
    const rootNode = __privateGet(this, _opts).rootNode.current;
    if (!rootNode || !node)
      return;
    const items = this.getCandidateNodes();
    if (!items.length)
      return;
    const currentIndex = items.indexOf(node);
    const dir = getElemDirection(rootNode);
    const { nextKey, prevKey } = getDirectionalKeys(dir, __privateGet(this, _opts).orientation.current);
    const loop = __privateGet(this, _opts).loop.current;
    const keyToIndex = {
      [nextKey]: currentIndex + 1,
      [prevKey]: currentIndex - 1,
      [kbd_constants_exports.HOME]: 0,
      [kbd_constants_exports.END]: items.length - 1
    };
    if (both) {
      const altNextKey = nextKey === kbd_constants_exports.ARROW_DOWN ? kbd_constants_exports.ARROW_RIGHT : kbd_constants_exports.ARROW_DOWN;
      const altPrevKey = prevKey === kbd_constants_exports.ARROW_UP ? kbd_constants_exports.ARROW_LEFT : kbd_constants_exports.ARROW_UP;
      keyToIndex[altNextKey] = currentIndex + 1;
      keyToIndex[altPrevKey] = currentIndex - 1;
    }
    let itemIndex = keyToIndex[e.key];
    if (itemIndex === void 0)
      return;
    e.preventDefault();
    if (itemIndex < 0 && loop) {
      itemIndex = items.length - 1;
    } else if (itemIndex === items.length && loop) {
      itemIndex = 0;
    }
    const itemToFocus = items[itemIndex];
    if (!itemToFocus)
      return;
    itemToFocus.focus();
    __privateGet(this, _currentTabStopId).current = itemToFocus.id;
    (_b = (_a = __privateGet(this, _opts)).onCandidateFocus) == null ? void 0 : _b.call(_a, itemToFocus);
    return itemToFocus;
  }
  getTabIndex(node) {
    const items = this.getCandidateNodes();
    const anyActive = __privateGet(this, _currentTabStopId).current !== null;
    if (node && !anyActive && items[0] === node) {
      __privateGet(this, _currentTabStopId).current = node.id;
      return 0;
    } else if ((node == null ? void 0 : node.id) === __privateGet(this, _currentTabStopId).current) {
      return 0;
    }
    return -1;
  }
  setCurrentTabStopId(id) {
    __privateGet(this, _currentTabStopId).current = id;
  }
  focusCurrentTabStop() {
    var _a;
    const currentTabStopId = __privateGet(this, _currentTabStopId).current;
    if (!currentTabStopId)
      return;
    const currentTabStop = (_a = __privateGet(this, _opts).rootNode.current) == null ? void 0 : _a.querySelector(`#${currentTabStopId}`);
    if (!currentTabStop || !isHTMLElement2(currentTabStop))
      return;
    currentTabStop.focus();
  }
};
_opts = new WeakMap();
_currentTabStopId = new WeakMap();

// node_modules/bits-ui/dist/internal/animations-complete.js
var _opts2, _currentFrame, _AnimationsComplete_instances, cleanup_fn, executeCallback_fn;
var AnimationsComplete = class {
  constructor(opts) {
    __privateAdd(this, _AnimationsComplete_instances);
    __privateAdd(this, _opts2);
    __privateAdd(this, _currentFrame, null);
    __privateSet(this, _opts2, opts);
    onDestroyEffect(() => __privateMethod(this, _AnimationsComplete_instances, cleanup_fn).call(this));
  }
  run(fn) {
    __privateMethod(this, _AnimationsComplete_instances, cleanup_fn).call(this);
    const node = __privateGet(this, _opts2).ref.current;
    if (!node)
      return;
    if (typeof node.getAnimations !== "function") {
      __privateMethod(this, _AnimationsComplete_instances, executeCallback_fn).call(this, fn);
      return;
    }
    __privateSet(this, _currentFrame, window.requestAnimationFrame(() => {
      const animations = node.getAnimations();
      if (animations.length === 0) {
        __privateMethod(this, _AnimationsComplete_instances, executeCallback_fn).call(this, fn);
        return;
      }
      Promise.allSettled(animations.map((animation) => animation.finished)).then(() => {
        __privateMethod(this, _AnimationsComplete_instances, executeCallback_fn).call(this, fn);
      });
    }));
  }
};
_opts2 = new WeakMap();
_currentFrame = new WeakMap();
_AnimationsComplete_instances = new WeakSet();
cleanup_fn = function() {
  if (!__privateGet(this, _currentFrame))
    return;
  window.cancelAnimationFrame(__privateGet(this, _currentFrame));
  __privateSet(this, _currentFrame, null);
};
executeCallback_fn = function(fn) {
  const execute = () => {
    fn();
  };
  if (__privateGet(this, _opts2).afterTick) {
    afterTick(execute);
  } else {
    execute();
  }
};

// node_modules/bits-ui/dist/internal/presence-manager.svelte.js
var _opts3, _enabled, _afterAnimations, _shouldRender;
var PresenceManager = class {
  constructor(opts) {
    __privateAdd(this, _opts3);
    __privateAdd(this, _enabled);
    __privateAdd(this, _afterAnimations);
    __privateAdd(this, _shouldRender, state(false));
    __privateSet(this, _opts3, opts);
    set(__privateGet(this, _shouldRender), opts.open.current, true);
    __privateSet(this, _enabled, opts.enabled ?? true);
    __privateSet(this, _afterAnimations, new AnimationsComplete({
      ref: __privateGet(this, _opts3).ref,
      afterTick: __privateGet(this, _opts3).open
    }));
    watch(() => __privateGet(this, _opts3).open.current, (isOpen) => {
      if (isOpen) set(__privateGet(this, _shouldRender), true);
      if (!__privateGet(this, _enabled)) return;
      __privateGet(this, _afterAnimations).run(() => {
        var _a, _b;
        if (isOpen === __privateGet(this, _opts3).open.current) {
          if (!__privateGet(this, _opts3).open.current) {
            set(__privateGet(this, _shouldRender), false);
          }
          (_b = (_a = __privateGet(this, _opts3)).onComplete) == null ? void 0 : _b.call(_a);
        }
      });
    });
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender));
  }
};
_opts3 = new WeakMap();
_enabled = new WeakMap();
_afterAnimations = new WeakMap();
_shouldRender = new WeakMap();

// node_modules/bits-ui/dist/bits/accordion/accordion.svelte.js
var accordionAttrs = createBitsAttrs({
  component: "accordion",
  parts: [
    "root",
    "trigger",
    "content",
    "item",
    "header"
  ]
});
var AccordionRootContext = new Context("Accordion.Root");
var AccordionItemContext = new Context("Accordion.Item");
var _props;
var AccordionBaseState = class {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "attachment");
    __privateAdd(this, _props, user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": this.opts.orientation.current,
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      [accordionAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: this.opts.ref,
      candidateAttr: accordionAttrs.trigger,
      loop: this.opts.loop,
      orientation: this.opts.orientation
    });
    this.attachment = attachRef(this.opts.ref);
  }
  get props() {
    return get(__privateGet(this, _props));
  }
  set props(value) {
    set(__privateGet(this, _props), value);
  }
};
_props = new WeakMap();
var AccordionSingleState = class extends AccordionBaseState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", false);
    this.opts = opts;
    this.includesItem = this.includesItem.bind(this);
    this.toggleItem = this.toggleItem.bind(this);
  }
  includesItem(item) {
    return this.opts.value.current === item;
  }
  toggleItem(item) {
    this.opts.value.current = this.includesItem(item) ? "" : item;
  }
};
var _value;
var AccordionMultiState = class extends AccordionBaseState {
  constructor(props) {
    super(props);
    __privateAdd(this, _value);
    __publicField(this, "isMulti", true);
    __privateSet(this, _value, props.value);
    this.includesItem = this.includesItem.bind(this);
    this.toggleItem = this.toggleItem.bind(this);
  }
  includesItem(item) {
    return __privateGet(this, _value).current.includes(item);
  }
  toggleItem(item) {
    __privateGet(this, _value).current = this.includesItem(item) ? __privateGet(this, _value).current.filter((v) => v !== item) : [...__privateGet(this, _value).current, item];
  }
};
_value = new WeakMap();
var AccordionRootState = class {
  static create(props) {
    const { type, ...rest } = props;
    const rootState = type === "single" ? new AccordionSingleState(rest) : new AccordionMultiState(rest);
    return AccordionRootContext.set(rootState);
  }
};
var _isActive, _isDisabled, _contentNode, _props2;
var _AccordionItemState = class _AccordionItemState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _isActive, user_derived(() => this.root.includesItem(this.opts.value.current)));
    __privateAdd(this, _isDisabled, user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current));
    __publicField(this, "attachment");
    __privateAdd(this, _contentNode, state(null));
    __publicField(this, "contentPresence");
    __privateAdd(this, _props2, user_derived(() => ({
      id: this.opts.id.current,
      "data-state": getDataOpenClosed(this.isActive),
      "data-disabled": boolToEmptyStrOrUndef(this.isDisabled),
      "data-orientation": this.root.opts.orientation.current,
      [accordionAttrs.item]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = opts.rootState;
    this.updateValue = this.updateValue.bind(this);
    this.attachment = attachRef(this.opts.ref);
    this.contentPresence = new PresenceManager({
      ref: boxWith(() => this.contentNode),
      open: boxWith(() => this.isActive)
    });
  }
  static create(props) {
    return AccordionItemContext.set(new _AccordionItemState({
      ...props,
      rootState: AccordionRootContext.get()
    }));
  }
  get isActive() {
    return get(__privateGet(this, _isActive));
  }
  set isActive(value) {
    set(__privateGet(this, _isActive), value);
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled), value);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode), value, true);
  }
  updateValue() {
    this.root.toggleItem(this.opts.value.current);
  }
  get props() {
    return get(__privateGet(this, _props2));
  }
  set props(value) {
    set(__privateGet(this, _props2), value);
  }
};
_isActive = new WeakMap();
_isDisabled = new WeakMap();
_contentNode = new WeakMap();
_props2 = new WeakMap();
var AccordionItemState = _AccordionItemState;
var _root2, _isDisabled2, _props3;
var _AccordionTriggerState = class _AccordionTriggerState {
  constructor(opts, itemState) {
    __publicField(this, "opts");
    __publicField(this, "itemState");
    __privateAdd(this, _root2);
    __privateAdd(this, _isDisabled2, user_derived(() => this.opts.disabled.current || this.itemState.opts.disabled.current || __privateGet(this, _root2).opts.disabled.current));
    __publicField(this, "attachment");
    __privateAdd(this, _props3, user_derived(() => ({
      id: this.opts.id.current,
      disabled: get(__privateGet(this, _isDisabled2)),
      "aria-expanded": boolToStr(this.itemState.isActive),
      "aria-disabled": boolToStr(get(__privateGet(this, _isDisabled2))),
      "data-disabled": boolToEmptyStrOrUndef(get(__privateGet(this, _isDisabled2))),
      "data-state": getDataOpenClosed(this.itemState.isActive),
      "data-orientation": __privateGet(this, _root2).opts.orientation.current,
      [accordionAttrs.trigger]: "",
      tabindex: 0,
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.itemState = itemState;
    __privateSet(this, _root2, itemState.root);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(props) {
    return new _AccordionTriggerState(props, AccordionItemContext.get());
  }
  onclick(e) {
    if (get(__privateGet(this, _isDisabled2)) || e.button !== 0) {
      e.preventDefault();
      return;
    }
    this.itemState.updateValue();
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled2))) return;
    if (e.key === kbd_constants_exports.SPACE || e.key === kbd_constants_exports.ENTER) {
      e.preventDefault();
      this.itemState.updateValue();
      return;
    }
    __privateGet(this, _root2).rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  get props() {
    return get(__privateGet(this, _props3));
  }
  set props(value) {
    set(__privateGet(this, _props3), value);
  }
};
_root2 = new WeakMap();
_isDisabled2 = new WeakMap();
_props3 = new WeakMap();
var AccordionTriggerState = _AccordionTriggerState;
var _originalStyles, _isMountAnimationPrevented, _dimensions, _open, _updateDimensions, _snippetProps, _props4;
var _AccordionContentState = class _AccordionContentState {
  constructor(opts, item) {
    __publicField(this, "opts");
    __publicField(this, "item");
    __publicField(this, "attachment");
    __privateAdd(this, _originalStyles);
    __privateAdd(this, _isMountAnimationPrevented, false);
    __privateAdd(this, _dimensions, state(proxy({ width: 0, height: 0 })));
    __privateAdd(this, _open, user_derived(() => {
      if (this.opts.hiddenUntilFound.current) return this.item.isActive;
      return this.opts.forceMount.current || this.item.isActive;
    }));
    __privateAdd(this, _updateDimensions, ([_, node]) => {
      if (!node) return;
      afterTick(() => {
        const element2 = this.opts.ref.current;
        if (!element2) return;
        __privateGet(this, _originalStyles) ?? __privateSet(this, _originalStyles, {
          transitionDuration: element2.style.transitionDuration,
          animationName: element2.style.animationName
        });
        element2.style.transitionDuration = "0s";
        element2.style.animationName = "none";
        const rect = element2.getBoundingClientRect();
        set(__privateGet(this, _dimensions), { width: rect.width, height: rect.height }, true);
        if (!__privateGet(this, _isMountAnimationPrevented) && __privateGet(this, _originalStyles)) {
          element2.style.transitionDuration = __privateGet(this, _originalStyles).transitionDuration;
          element2.style.animationName = __privateGet(this, _originalStyles).animationName;
        }
      });
    });
    __privateAdd(this, _snippetProps, user_derived(() => ({ open: this.item.isActive })));
    __privateAdd(this, _props4, user_derived(() => ({
      id: this.opts.id.current,
      "data-state": getDataOpenClosed(this.item.isActive),
      "data-disabled": boolToEmptyStrOrUndef(this.item.isDisabled),
      "data-orientation": this.item.root.opts.orientation.current,
      [accordionAttrs.content]: "",
      style: {
        "--bits-accordion-content-height": `${get(__privateGet(this, _dimensions)).height}px`,
        "--bits-accordion-content-width": `${get(__privateGet(this, _dimensions)).width}px`
      },
      hidden: this.opts.hiddenUntilFound.current && !this.item.isActive ? "until-found" : void 0,
      ...this.opts.hiddenUntilFound.current && !this.shouldRender ? {} : {
        hidden: this.opts.hiddenUntilFound.current ? !this.shouldRender : this.opts.forceMount.current ? void 0 : !this.shouldRender
      },
      ...this.attachment
    })));
    this.opts = opts;
    this.item = item;
    __privateSet(this, _isMountAnimationPrevented, this.item.isActive);
    this.attachment = attachRef(this.opts.ref, (v) => this.item.contentNode = v);
    user_effect(() => {
      const rAF = requestAnimationFrame(() => {
        __privateSet(this, _isMountAnimationPrevented, false);
      });
      return () => cancelAnimationFrame(rAF);
    });
    watch.pre(
      [
        () => this.opts.ref.current,
        () => this.opts.hiddenUntilFound.current
      ],
      ([node, hiddenUntilFound]) => {
        if (!node || !hiddenUntilFound) return;
        const handleBeforeMatch = () => {
          if (this.item.isActive) return;
          requestAnimationFrame(() => {
            this.item.updateValue();
          });
        };
        return on(node, "beforematch", handleBeforeMatch);
      }
    );
    watch([() => this.open, () => this.opts.ref.current], __privateGet(this, _updateDimensions));
  }
  get open() {
    return get(__privateGet(this, _open));
  }
  set open(value) {
    set(__privateGet(this, _open), value);
  }
  static create(props) {
    return new _AccordionContentState(props, AccordionItemContext.get());
  }
  get shouldRender() {
    return this.item.contentPresence.shouldRender;
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps), value);
  }
  get props() {
    return get(__privateGet(this, _props4));
  }
  set props(value) {
    set(__privateGet(this, _props4), value);
  }
};
_originalStyles = new WeakMap();
_isMountAnimationPrevented = new WeakMap();
_dimensions = new WeakMap();
_open = new WeakMap();
_updateDimensions = new WeakMap();
_snippetProps = new WeakMap();
_props4 = new WeakMap();
var AccordionContentState = _AccordionContentState;
var _props5;
var _AccordionHeaderState = class _AccordionHeaderState {
  constructor(opts, item) {
    __publicField(this, "opts");
    __publicField(this, "item");
    __publicField(this, "attachment");
    __privateAdd(this, _props5, user_derived(() => ({
      id: this.opts.id.current,
      role: "heading",
      "aria-level": this.opts.level.current,
      "data-heading-level": this.opts.level.current,
      "data-state": getDataOpenClosed(this.item.isActive),
      "data-orientation": this.item.root.opts.orientation.current,
      [accordionAttrs.header]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.item = item;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(props) {
    return new _AccordionHeaderState(props, AccordionItemContext.get());
  }
  get props() {
    return get(__privateGet(this, _props5));
  }
  set props(value) {
    set(__privateGet(this, _props5), value);
  }
};
_props5 = new WeakMap();
var AccordionHeaderState = _AccordionHeaderState;

// node_modules/bits-ui/dist/internal/noop.js
function noop3() {
}

// node_modules/bits-ui/dist/internal/create-id.js
function createId(prefixOrUid, uid) {
  if (uid === void 0)
    return `bits-${prefixOrUid}`;
  return `bits-${prefixOrUid}-${uid}`;
}

// node_modules/bits-ui/dist/bits/accordion/components/accordion.svelte
var root_2 = from_html(`<div><!></div>`);
function Accordion($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15), ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), onValueChange = prop($$props, "onValueChange", 3, noop3), loop = prop($$props, "loop", 3, true), orientation = prop($$props, "orientation", 3, "vertical"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "disabled",
    "children",
    "child",
    "type",
    "value",
    "ref",
    "id",
    "onValueChange",
    "loop",
    "orientation"
  ]);
  function handleDefaultValue() {
    if (value() !== void 0) return;
    value($$props.type === "single" ? "" : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = AccordionRootState.create({
    type: $$props.type,
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    id: boxWith(() => id()),
    disabled: boxWith(() => disabled()),
    loop: boxWith(() => loop()),
    orientation: boxWith(() => orientation()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/accordion/components/accordion-item.svelte
var root_22 = from_html(`<div><!></div>`);
function Accordion_item($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  const defaultId = createId(uid);
  let id = prop($$props, "id", 3, defaultId), disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 3, defaultId), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "disabled",
    "value",
    "children",
    "child",
    "ref"
  ]);
  const itemState = AccordionItemState.create({
    value: boxWith(() => value()),
    disabled: boxWith(() => disabled()),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_22();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/accordion/components/accordion-header.svelte
var root_23 = from_html(`<div><!></div>`);
function Accordion_header($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), level = prop($$props, "level", 3, 2), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "level",
    "children",
    "child",
    "ref"
  ]);
  const headerState = AccordionHeaderState.create({
    id: boxWith(() => id()),
    level: boxWith(() => level()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, headerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_23();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/accordion/components/accordion-trigger.svelte
var root_24 = from_html(`<button><!></button>`);
function Accordion_trigger($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "disabled",
    "ref",
    "id",
    "children",
    "child"
  ]);
  const triggerState = AccordionTriggerState.create({
    disabled: boxWith(() => disabled()),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_24();
      attribute_effect(button, () => ({ type: "button", ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/accordion/components/accordion-content.svelte
var root_25 = from_html(`<div><!></div>`);
function Accordion_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), hiddenUntilFound = prop($$props, "hiddenUntilFound", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "ref",
    "id",
    "forceMount",
    "children",
    "hiddenUntilFound"
  ]);
  const contentState = AccordionContentState.create({
    forceMount: boxWith(() => forceMount()),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    hiddenUntilFound: boxWith(() => hiddenUntilFound())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...contentState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_25();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/alert-dialog/exports.js
var exports_exports2 = {};
__export(exports_exports2, {
  Action: () => Alert_dialog_action,
  Cancel: () => Alert_dialog_cancel,
  Content: () => Alert_dialog_content,
  Description: () => Dialog_description,
  Overlay: () => Dialog_overlay,
  Portal: () => Portal,
  Root: () => Alert_dialog,
  Title: () => Dialog_title,
  Trigger: () => Dialog_trigger
});

// node_modules/bits-ui/dist/bits/dialog/dialog.svelte.js
var dialogAttrs = createBitsAttrs({
  component: "dialog",
  parts: [
    "content",
    "trigger",
    "overlay",
    "title",
    "description",
    "close",
    "cancel",
    "action"
  ]
});
var DialogRootContext = new Context("Dialog.Root | AlertDialog.Root");
var _triggerNode, _contentNode2, _overlayNode, _descriptionNode, _contentId, _titleId, _triggerId, _descriptionId, _cancelNode, _nestedOpenCount, _sharedProps;
var _DialogRootState = class _DialogRootState {
  constructor(opts, parent) {
    __publicField(this, "opts");
    __privateAdd(this, _triggerNode, state(null));
    __privateAdd(this, _contentNode2, state(null));
    __privateAdd(this, _overlayNode, state(null));
    __privateAdd(this, _descriptionNode, state(null));
    __privateAdd(this, _contentId, state(void 0));
    __privateAdd(this, _titleId, state(void 0));
    __privateAdd(this, _triggerId, state(void 0));
    __privateAdd(this, _descriptionId, state(void 0));
    __privateAdd(this, _cancelNode, state(null));
    __privateAdd(this, _nestedOpenCount, state(0));
    __publicField(this, "depth");
    __publicField(this, "parent");
    __publicField(this, "contentPresence");
    __publicField(this, "overlayPresence");
    __publicField(this, "getBitsAttr", (part) => {
      return dialogAttrs.getAttr(part, this.opts.variant.current);
    });
    __privateAdd(this, _sharedProps, user_derived(() => ({
      "data-state": getDataOpenClosed(this.opts.open.current)
    })));
    this.opts = opts;
    this.parent = parent;
    this.depth = parent ? parent.depth + 1 : 0;
    this.handleOpen = this.handleOpen.bind(this);
    this.handleClose = this.handleClose.bind(this);
    this.contentPresence = new PresenceManager({
      ref: boxWith(() => this.contentNode),
      open: this.opts.open,
      enabled: true,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    this.overlayPresence = new PresenceManager({
      ref: boxWith(() => this.overlayNode),
      open: this.opts.open,
      enabled: true
    });
    watch(
      () => this.opts.open.current,
      (isOpen) => {
        if (!this.parent) return;
        if (isOpen) {
          this.parent.incrementNested();
        } else {
          this.parent.decrementNested();
        }
      },
      { lazy: true }
    );
    onDestroyEffect(() => {
      var _a;
      if (this.opts.open.current) {
        (_a = this.parent) == null ? void 0 : _a.decrementNested();
      }
    });
  }
  static create(opts) {
    const parent = DialogRootContext.getOr(null);
    return DialogRootContext.set(new _DialogRootState(opts, parent));
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode), value, true);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode2));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode2), value, true);
  }
  get overlayNode() {
    return get(__privateGet(this, _overlayNode));
  }
  set overlayNode(value) {
    set(__privateGet(this, _overlayNode), value, true);
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode), value, true);
  }
  get contentId() {
    return get(__privateGet(this, _contentId));
  }
  set contentId(value) {
    set(__privateGet(this, _contentId), value, true);
  }
  get titleId() {
    return get(__privateGet(this, _titleId));
  }
  set titleId(value) {
    set(__privateGet(this, _titleId), value, true);
  }
  get triggerId() {
    return get(__privateGet(this, _triggerId));
  }
  set triggerId(value) {
    set(__privateGet(this, _triggerId), value, true);
  }
  get descriptionId() {
    return get(__privateGet(this, _descriptionId));
  }
  set descriptionId(value) {
    set(__privateGet(this, _descriptionId), value, true);
  }
  get cancelNode() {
    return get(__privateGet(this, _cancelNode));
  }
  set cancelNode(value) {
    set(__privateGet(this, _cancelNode), value, true);
  }
  get nestedOpenCount() {
    return get(__privateGet(this, _nestedOpenCount));
  }
  set nestedOpenCount(value) {
    set(__privateGet(this, _nestedOpenCount), value, true);
  }
  handleOpen() {
    if (this.opts.open.current) return;
    this.opts.open.current = true;
  }
  handleClose() {
    if (!this.opts.open.current) return;
    this.opts.open.current = false;
  }
  incrementNested() {
    var _a;
    this.nestedOpenCount++;
    (_a = this.parent) == null ? void 0 : _a.incrementNested();
  }
  decrementNested() {
    var _a;
    if (this.nestedOpenCount === 0) return;
    this.nestedOpenCount--;
    (_a = this.parent) == null ? void 0 : _a.decrementNested();
  }
  get sharedProps() {
    return get(__privateGet(this, _sharedProps));
  }
  set sharedProps(value) {
    set(__privateGet(this, _sharedProps), value);
  }
};
_triggerNode = new WeakMap();
_contentNode2 = new WeakMap();
_overlayNode = new WeakMap();
_descriptionNode = new WeakMap();
_contentId = new WeakMap();
_titleId = new WeakMap();
_triggerId = new WeakMap();
_descriptionId = new WeakMap();
_cancelNode = new WeakMap();
_nestedOpenCount = new WeakMap();
_sharedProps = new WeakMap();
var DialogRootState = _DialogRootState;
var _props6;
var _DialogTriggerState = class _DialogTriggerState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props6, user_derived(() => ({
      id: this.opts.id.current,
      "aria-haspopup": "dialog",
      "aria-expanded": boolToStr(this.root.opts.open.current),
      "aria-controls": this.root.contentId,
      [this.root.getBitsAttr("trigger")]: "",
      onkeydown: this.onkeydown,
      onclick: this.onclick,
      disabled: this.opts.disabled.current ? true : void 0,
      ...this.root.sharedProps,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => {
      this.root.triggerNode = v;
      this.root.triggerId = v == null ? void 0 : v.id;
    });
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _DialogTriggerState(opts, DialogRootContext.get());
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (e.button > 0) return;
    this.root.handleOpen();
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (e.key === kbd_constants_exports.SPACE || e.key === kbd_constants_exports.ENTER) {
      e.preventDefault();
      this.root.handleOpen();
    }
  }
  get props() {
    return get(__privateGet(this, _props6));
  }
  set props(value) {
    set(__privateGet(this, _props6), value);
  }
};
_props6 = new WeakMap();
var DialogTriggerState = _DialogTriggerState;
var _props7;
var _DialogCloseState = class _DialogCloseState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props7, user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr(this.opts.variant.current)]: "",
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      disabled: this.opts.disabled.current ? true : void 0,
      tabindex: 0,
      ...this.root.sharedProps,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _DialogCloseState(opts, DialogRootContext.get());
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (e.button > 0) return;
    this.root.handleClose();
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (e.key === kbd_constants_exports.SPACE || e.key === kbd_constants_exports.ENTER) {
      e.preventDefault();
      this.root.handleClose();
    }
  }
  get props() {
    return get(__privateGet(this, _props7));
  }
  set props(value) {
    set(__privateGet(this, _props7), value);
  }
};
_props7 = new WeakMap();
var DialogCloseState = _DialogCloseState;
var _props8;
var _DialogActionState = class _DialogActionState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props8, user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr("action")]: "",
      ...this.root.sharedProps,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _DialogActionState(opts, DialogRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props8));
  }
  set props(value) {
    set(__privateGet(this, _props8), value);
  }
};
_props8 = new WeakMap();
var DialogActionState = _DialogActionState;
var _props9;
var _DialogTitleState = class _DialogTitleState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props9, user_derived(() => ({
      id: this.opts.id.current,
      role: "heading",
      "aria-level": this.opts.level.current,
      [this.root.getBitsAttr("title")]: "",
      ...this.root.sharedProps,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.root.titleId = this.opts.id.current;
    this.attachment = attachRef(this.opts.ref);
    watch.pre(() => this.opts.id.current, (id) => {
      this.root.titleId = id;
    });
  }
  static create(opts) {
    return new _DialogTitleState(opts, DialogRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props9));
  }
  set props(value) {
    set(__privateGet(this, _props9), value);
  }
};
_props9 = new WeakMap();
var DialogTitleState = _DialogTitleState;
var _props10;
var _DialogDescriptionState = class _DialogDescriptionState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props10, user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr("description")]: "",
      ...this.root.sharedProps,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.root.descriptionId = this.opts.id.current;
    this.attachment = attachRef(this.opts.ref, (v) => {
      this.root.descriptionNode = v;
    });
    watch.pre(() => this.opts.id.current, (id) => {
      this.root.descriptionId = id;
    });
  }
  static create(opts) {
    return new _DialogDescriptionState(opts, DialogRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props10));
  }
  set props(value) {
    set(__privateGet(this, _props10), value);
  }
};
_props10 = new WeakMap();
var DialogDescriptionState = _DialogDescriptionState;
var _snippetProps2, _props11;
var _DialogContentState = class _DialogContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps2, user_derived(() => ({ open: this.root.opts.open.current })));
    __privateAdd(this, _props11, user_derived(() => ({
      id: this.opts.id.current,
      role: this.root.opts.variant.current === "alert-dialog" ? "alertdialog" : "dialog",
      "aria-modal": "true",
      "aria-describedby": this.root.descriptionId,
      "aria-labelledby": this.root.titleId,
      [this.root.getBitsAttr("content")]: "",
      style: {
        pointerEvents: "auto",
        outline: this.root.opts.variant.current === "alert-dialog" ? "none" : void 0,
        "--bits-dialog-depth": this.root.depth,
        "--bits-dialog-nested-count": this.root.nestedOpenCount
      },
      tabindex: this.root.opts.variant.current === "alert-dialog" ? -1 : void 0,
      "data-nested-open": boolToEmptyStrOrUndef(this.root.nestedOpenCount > 0),
      "data-nested": boolToEmptyStrOrUndef(this.root.parent !== null),
      ...this.root.sharedProps,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => {
      this.root.contentNode = v;
      this.root.contentId = v == null ? void 0 : v.id;
    });
  }
  static create(opts) {
    return new _DialogContentState(opts, DialogRootContext.get());
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps2));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps2), value);
  }
  get props() {
    return get(__privateGet(this, _props11));
  }
  set props(value) {
    set(__privateGet(this, _props11), value);
  }
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
};
_snippetProps2 = new WeakMap();
_props11 = new WeakMap();
var DialogContentState = _DialogContentState;
var _snippetProps3, _props12;
var _DialogOverlayState = class _DialogOverlayState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps3, user_derived(() => ({ open: this.root.opts.open.current })));
    __privateAdd(this, _props12, user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr("overlay")]: "",
      style: {
        pointerEvents: "auto",
        "--bits-dialog-depth": this.root.depth,
        "--bits-dialog-nested-count": this.root.nestedOpenCount
      },
      "data-nested-open": boolToEmptyStrOrUndef(this.root.nestedOpenCount > 0),
      "data-nested": boolToEmptyStrOrUndef(this.root.parent !== null),
      ...this.root.sharedProps,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.overlayNode = v);
  }
  static create(opts) {
    return new _DialogOverlayState(opts, DialogRootContext.get());
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps3));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps3), value);
  }
  get props() {
    return get(__privateGet(this, _props12));
  }
  set props(value) {
    set(__privateGet(this, _props12), value);
  }
  get shouldRender() {
    return this.root.overlayPresence.shouldRender;
  }
};
_snippetProps3 = new WeakMap();
_props12 = new WeakMap();
var DialogOverlayState = _DialogOverlayState;
var _props13;
var _AlertDialogCancelState = class _AlertDialogCancelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props13, user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr("cancel")]: "",
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      tabindex: 0,
      ...this.root.sharedProps,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.cancelNode = v);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _AlertDialogCancelState(opts, DialogRootContext.get());
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (e.button > 0) return;
    this.root.handleClose();
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (e.key === kbd_constants_exports.SPACE || e.key === kbd_constants_exports.ENTER) {
      e.preventDefault();
      this.root.handleClose();
    }
  }
  get props() {
    return get(__privateGet(this, _props13));
  }
  set props(value) {
    set(__privateGet(this, _props13), value);
  }
};
_props13 = new WeakMap();
var AlertDialogCancelState = _AlertDialogCancelState;

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog.svelte
function Alert_dialog($$anchor, $$props) {
  push($$props, true);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  DialogRootState.create({
    variant: boxWith(() => "alert-dialog"),
    open: boxWith(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/dialog/components/dialog-title.svelte
var root_26 = from_html(`<div><!></div>`);
function Dialog_title($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), level = prop($$props, "level", 3, 2), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "child",
    "children",
    "level"
  ]);
  const titleState = DialogTitleState.create({
    id: boxWith(() => id()),
    level: boxWith(() => level()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, titleState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_26();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-action.svelte
var root_27 = from_html(`<button><!></button>`);
function Alert_dialog_action($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref"
  ]);
  const actionState = DialogActionState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, actionState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_27();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-cancel.svelte
var root_28 = from_html(`<button><!></button>`);
function Alert_dialog_cancel($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child",
    "disabled"
  ]);
  const cancelState = AlertDialogCancelState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    disabled: boxWith(() => Boolean(disabled()))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, cancelState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_28();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/portal/portal-consumer.svelte
function Portal_consumer($$anchor, $$props) {
  var fragment = comment();
  var node = first_child(fragment);
  key_block(node, () => $$props.children, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    snippet(node_1, () => $$props.children ?? noop);
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
}

// node_modules/bits-ui/dist/bits/utilities/config/bits-config.js
var BitsConfigContext = new Context("BitsConfig");
function getBitsConfig() {
  const fallback = new BitsConfigState(null, {});
  return BitsConfigContext.getOr(fallback).opts;
}
function useBitsConfig(opts) {
  return BitsConfigContext.set(new BitsConfigState(BitsConfigContext.getOr(null), opts));
}
var BitsConfigState = class {
  constructor(parent, opts) {
    __publicField(this, "opts");
    const resolveConfigOption = createConfigResolver(parent, opts);
    this.opts = {
      defaultPortalTo: resolveConfigOption((config) => config.defaultPortalTo),
      defaultLocale: resolveConfigOption((config) => config.defaultLocale)
    };
  }
};
function createConfigResolver(parent, currentOpts) {
  return (getter) => {
    const configOption = boxWith(() => {
      var _a, _b;
      const value = (_a = getter(currentOpts)) == null ? void 0 : _a.current;
      if (value !== void 0)
        return value;
      if (parent === null)
        return void 0;
      return (_b = getter(parent.opts)) == null ? void 0 : _b.current;
    });
    return configOption;
  };
}

// node_modules/bits-ui/dist/bits/utilities/config/prop-resolvers.js
function createPropResolver(configOption, fallback) {
  return (getProp) => {
    const config = getBitsConfig();
    return boxWith(() => {
      const propValue = getProp();
      if (propValue !== void 0)
        return propValue;
      const option = configOption(config).current;
      if (option !== void 0)
        return option;
      return fallback;
    });
  };
}
var resolveLocaleProp = createPropResolver((config) => config.defaultLocale, "en");
var resolvePortalToProp = createPropResolver((config) => config.defaultPortalTo, "body");

// node_modules/bits-ui/dist/bits/utilities/portal/portal.svelte
function Portal($$anchor, $$props) {
  push($$props, true);
  const to = resolvePortalToProp(() => $$props.to);
  const context = getAllContexts();
  let target = user_derived(getTarget);
  function getTarget() {
    if (!isBrowser || $$props.disabled) return null;
    let localTarget = null;
    if (typeof to.current === "string") {
      const target2 = document.querySelector(to.current);
      if (false_default && target2 === null) {
        throw new Error(`Target element "${to.current}" not found.`);
      }
      localTarget = target2;
    } else {
      localTarget = to.current;
    }
    if (false_default && !(localTarget instanceof Element)) {
      const type = localTarget === null ? "null" : typeof localTarget;
      throw new TypeError(`Unknown portal target type: ${type}. Allowed types: string (query selector) or Element.`);
    }
    return localTarget;
  }
  let instance;
  function unmountInstance() {
    if (instance) {
      unmount(instance);
      instance = null;
    }
  }
  watch(
    [
      () => get(target),
      () => $$props.disabled
    ],
    ([target2, disabled]) => {
      if (!target2 || disabled) {
        unmountInstance();
        return;
      }
      instance = mount(Portal_consumer, {
        target: target2,
        props: { children: $$props.children },
        context
      });
      return () => {
        unmountInstance();
      };
    }
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if ($$props.disabled) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/internal/events.js
var CustomEventDispatcher = class {
  constructor(eventName, options = { bubbles: true, cancelable: true }) {
    __publicField(this, "eventName");
    __publicField(this, "options");
    this.eventName = eventName;
    this.options = options;
  }
  createEvent(detail) {
    return new CustomEvent(this.eventName, {
      ...this.options,
      detail
    });
  }
  dispatch(element2, detail) {
    const event = this.createEvent(detail);
    element2.dispatchEvent(event);
    return event;
  }
  listen(element2, callback, options) {
    const handler = (event) => {
      callback(event);
    };
    return on(element2, this.eventName, handler, options);
  }
};

// node_modules/bits-ui/dist/internal/debounce.js
function debounce2(fn, wait = 500) {
  let timeout = null;
  const debounced = (...args) => {
    if (timeout !== null) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      fn(...args);
    }, wait);
  };
  debounced.destroy = () => {
    if (timeout !== null) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  return debounced;
}

// node_modules/bits-ui/dist/internal/elements.js
function isOrContainsTarget2(node, target) {
  return node === target || node.contains(target);
}
function getOwnerDocument2(el) {
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}

// node_modules/bits-ui/dist/internal/dom.js
function getFirstNonCommentChild(element2) {
  if (!element2)
    return null;
  for (const child2 of element2.childNodes) {
    if (child2.nodeType !== Node.COMMENT_NODE) {
      return child2;
    }
  }
  return null;
}
function isClickTrulyOutside(event, contentNode) {
  const { clientX, clientY } = event;
  const rect = contentNode.getBoundingClientRect();
  return clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom;
}

// node_modules/bits-ui/dist/bits/menu/utils.js
var SELECTION_KEYS2 = [kbd_constants_exports.ENTER, kbd_constants_exports.SPACE];
var FIRST_KEYS2 = [kbd_constants_exports.ARROW_DOWN, kbd_constants_exports.PAGE_UP, kbd_constants_exports.HOME];
var LAST_KEYS2 = [kbd_constants_exports.ARROW_UP, kbd_constants_exports.PAGE_DOWN, kbd_constants_exports.END];
var FIRST_LAST_KEYS2 = [...FIRST_KEYS2, ...LAST_KEYS2];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS2, kbd_constants_exports.ARROW_RIGHT],
  rtl: [...SELECTION_KEYS2, kbd_constants_exports.ARROW_LEFT]
};
var SUB_CLOSE_KEYS = {
  ltr: [kbd_constants_exports.ARROW_LEFT],
  rtl: [kbd_constants_exports.ARROW_RIGHT]
};
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function isMouseEvent(event) {
  return event.pointerType === "mouse";
}

// node_modules/bits-ui/dist/internal/focus.js
function focus(element2, { select = false } = {}) {
  if (!element2 || !element2.focus)
    return;
  const doc = getDocument(element2);
  if (doc.activeElement === element2)
    return;
  const previouslyFocusedElement = doc.activeElement;
  element2.focus({ preventScroll: true });
  if (element2 !== previouslyFocusedElement && isSelectableInput(element2) && select) {
    element2.select();
  }
}
function focusFirst(candidates, { select = false } = {}, getActiveElement3) {
  const previouslyFocusedElement = getActiveElement3();
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (getActiveElement3() !== previouslyFocusedElement)
      return true;
  }
}
function getTabbableCandidates(container) {
  const nodes = [];
  const doc = getDocument(container);
  const walker = doc.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    // oxlint-disable-next-line no-explicit-any
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}

// node_modules/bits-ui/dist/internal/tabbable.js
function getTabbableOptions() {
  return {
    getShadowRoot: true,
    displayCheck: (
      // JSDOM does not support the `tabbable` library. To solve this we can
      // check if `ResizeObserver` is a real function (not polyfilled), which
      // determines if the current environment is JSDOM-like.
      typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
    )
  };
}
function getTabbableFrom(currentNode, direction) {
  if (!isTabbable(currentNode, getTabbableOptions())) {
    return getTabbableFromFocusable(currentNode, direction);
  }
  const doc = getDocument(currentNode);
  const allTabbable = tabbable(doc.body, getTabbableOptions());
  if (direction === "prev")
    allTabbable.reverse();
  const activeIndex = allTabbable.indexOf(currentNode);
  if (activeIndex === -1)
    return doc.body;
  const nextTabbableElements = allTabbable.slice(activeIndex + 1);
  return nextTabbableElements[0];
}
function getTabbableFromFocusable(currentNode, direction) {
  const doc = getDocument(currentNode);
  if (!isFocusable(currentNode, getTabbableOptions()))
    return doc.body;
  const allFocusable = focusable(doc.body, getTabbableOptions());
  if (direction === "prev")
    allFocusable.reverse();
  const activeIndex = allFocusable.indexOf(currentNode);
  if (activeIndex === -1)
    return doc.body;
  const nextFocusableElements = allFocusable.slice(activeIndex + 1);
  return nextFocusableElements.find((node) => isTabbable(node, getTabbableOptions())) ?? doc.body;
}

// node_modules/bits-ui/dist/internal/arrays.js
function arraysAreEqual(arr1, arr2) {
  if (arr1.length !== arr2.length)
    return false;
  return arr1.every((value, index) => isEqual(value, arr2[index]));
}
function isEqual(a2, b) {
  if (Number.isNaN(a2) && Number.isNaN(b))
    return true;
  if (Array.isArray(a2) && Array.isArray(b))
    return arraysAreEqual(a2, b);
  if (typeof a2 === "object" && typeof b === "object")
    return isDeepEqual(a2, b);
  return Object.is(a2, b);
}
function isDeepEqual(a2, b) {
  if (typeof a2 !== "object" || typeof b !== "object" || a2 === null || b === null)
    return false;
  const aKeys = Object.keys(a2);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length)
    return false;
  for (const key of aKeys) {
    if (!bKeys.includes(key))
      return false;
    if (!isEqual(a2[key], b[key])) {
      return false;
    }
  }
  return true;
}
function chunk(arr, size2) {
  if (size2 <= 0)
    return [];
  const result = [];
  for (let i = 0; i < arr.length; i += size2) {
    result.push(arr.slice(i, i + size2));
  }
  return result;
}
function isValidIndex(index, arr) {
  return index >= 0 && index < arr.length;
}
function next2(array, index, loop = true) {
  if (array.length === 0 || index < 0 || index >= array.length)
    return;
  if (array.length === 1 && index === 0)
    return array[0];
  if (index === array.length - 1)
    return loop ? array[0] : void 0;
  return array[index + 1];
}
function prev(array, index, loop = true) {
  if (array.length === 0 || index < 0 || index >= array.length)
    return;
  if (array.length === 1 && index === 0)
    return array[0];
  if (index === 0)
    return loop ? array[array.length - 1] : void 0;
  return array[index - 1];
}
function forward(array, index, increment, loop = true) {
  if (array.length === 0 || index < 0 || index >= array.length)
    return;
  let targetIndex = index + increment;
  if (loop) {
    targetIndex = (targetIndex % array.length + array.length) % array.length;
  } else {
    targetIndex = Math.max(0, Math.min(targetIndex, array.length - 1));
  }
  return array[targetIndex];
}
function backward(array, index, decrement, loop = true) {
  if (array.length === 0 || index < 0 || index >= array.length)
    return;
  let targetIndex = index - decrement;
  if (loop) {
    targetIndex = (targetIndex % array.length + array.length) % array.length;
  } else {
    targetIndex = Math.max(0, Math.min(targetIndex, array.length - 1));
  }
  return array[targetIndex];
}
function getNextMatch(values, search, currentMatch) {
  const lowerSearch = search.toLowerCase();
  if (lowerSearch.endsWith(" ")) {
    const searchWithoutSpace = lowerSearch.slice(0, -1);
    const matchesWithoutSpace = values.filter((value) => value.toLowerCase().startsWith(searchWithoutSpace));
    if (matchesWithoutSpace.length <= 1) {
      return getNextMatch(values, searchWithoutSpace, currentMatch);
    }
    const currentMatchLowercase = currentMatch == null ? void 0 : currentMatch.toLowerCase();
    if (currentMatchLowercase && currentMatchLowercase.startsWith(searchWithoutSpace) && currentMatchLowercase.charAt(searchWithoutSpace.length) === " " && search.trim() === searchWithoutSpace) {
      return currentMatch;
    }
    const spacedMatches = values.filter((value) => value.toLowerCase().startsWith(lowerSearch));
    if (spacedMatches.length > 0) {
      const currentMatchIndex2 = currentMatch ? values.indexOf(currentMatch) : -1;
      let wrappedMatches = wrapArray(spacedMatches, Math.max(currentMatchIndex2, 0));
      const nextMatch2 = wrappedMatches.find((match) => match !== currentMatch);
      return nextMatch2 || currentMatch;
    }
  }
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const normalizedLowerSearch = normalizedSearch.toLowerCase();
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find((value) => value == null ? void 0 : value.toLowerCase().startsWith(normalizedLowerSearch));
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}

// node_modules/bits-ui/dist/internal/box-auto-reset.svelte.js
var defaultOptions = { afterMs: 1e4, onChange: noop3 };
function boxAutoReset(defaultValue, options) {
  const { afterMs, onChange, getWindow: getWindow2 } = { ...defaultOptions, ...options };
  let timeout = null;
  let value = state(proxy(defaultValue));
  function resetAfter() {
    return getWindow2().setTimeout(
      () => {
        set(value, defaultValue, true);
        onChange == null ? void 0 : onChange(defaultValue);
      },
      afterMs
    );
  }
  user_effect(() => {
    return () => {
      if (timeout) getWindow2().clearTimeout(timeout);
    };
  });
  return boxWith(() => get(value), (v) => {
    set(value, v, true);
    onChange == null ? void 0 : onChange(v);
    if (timeout) getWindow2().clearTimeout(timeout);
    timeout = resetAfter();
  });
}

// node_modules/bits-ui/dist/internal/dom-typeahead.svelte.js
var _opts4, _search, _onMatch, _getCurrentItem;
var DOMTypeahead = class {
  constructor(opts) {
    __privateAdd(this, _opts4);
    __privateAdd(this, _search);
    __privateAdd(this, _onMatch, user_derived(() => {
      if (__privateGet(this, _opts4).onMatch) return __privateGet(this, _opts4).onMatch;
      return (node) => node.focus();
    }));
    __privateAdd(this, _getCurrentItem, user_derived(() => {
      if (__privateGet(this, _opts4).getCurrentItem) return __privateGet(this, _opts4).getCurrentItem;
      return __privateGet(this, _opts4).getActiveElement;
    }));
    __privateSet(this, _opts4, opts);
    __privateSet(this, _search, boxAutoReset("", { afterMs: 1e3, getWindow: opts.getWindow }));
    this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this);
    this.resetTypeahead = this.resetTypeahead.bind(this);
  }
  handleTypeaheadSearch(key, candidates) {
    var _a, _b;
    if (!candidates.length) return;
    __privateGet(this, _search).current = __privateGet(this, _search).current + key;
    const currentItem = get(__privateGet(this, _getCurrentItem))();
    const currentMatch = ((_b = (_a = candidates.find((item) => item === currentItem)) == null ? void 0 : _a.textContent) == null ? void 0 : _b.trim()) ?? "";
    const values = candidates.map((item) => {
      var _a2;
      return ((_a2 = item.textContent) == null ? void 0 : _a2.trim()) ?? "";
    });
    const nextMatch = getNextMatch(values, __privateGet(this, _search).current, currentMatch);
    const newItem = candidates.find((item) => {
      var _a2;
      return ((_a2 = item.textContent) == null ? void 0 : _a2.trim()) === nextMatch;
    });
    if (newItem) get(__privateGet(this, _onMatch))(newItem);
    return newItem;
  }
  resetTypeahead() {
    __privateGet(this, _search).current = "";
  }
  get search() {
    return __privateGet(this, _search).current;
  }
};
_opts4 = new WeakMap();
_search = new WeakMap();
_onMatch = new WeakMap();
_getCurrentItem = new WeakMap();

// node_modules/bits-ui/dist/internal/grace-area.svelte.js
var _opts5, _enabled2, _isPointerInTransit, _pointerGraceArea, _GraceArea_instances, removeGraceArea_fn, createGraceArea_fn;
var GraceArea = class {
  constructor(opts) {
    __privateAdd(this, _GraceArea_instances);
    __privateAdd(this, _opts5);
    __privateAdd(this, _enabled2);
    __privateAdd(this, _isPointerInTransit);
    __privateAdd(this, _pointerGraceArea, state(null));
    __privateSet(this, _opts5, opts);
    __privateSet(this, _enabled2, user_derived(() => __privateGet(this, _opts5).enabled()));
    __privateSet(this, _isPointerInTransit, boxAutoReset(false, {
      afterMs: opts.transitTimeout ?? 300,
      onChange: (value) => {
        var _a, _b;
        if (!get(__privateGet(this, _enabled2))) return;
        (_b = (_a = __privateGet(this, _opts5)).setIsPointerInTransit) == null ? void 0 : _b.call(_a, value);
      },
      getWindow: () => getWindow(__privateGet(this, _opts5).triggerNode())
    }));
    watch(
      [
        opts.triggerNode,
        opts.contentNode,
        opts.enabled
      ],
      ([triggerNode, contentNode, enabled]) => {
        if (!triggerNode || !contentNode || !enabled) return;
        const handleTriggerLeave = (e) => {
          __privateMethod(this, _GraceArea_instances, createGraceArea_fn).call(this, e, contentNode);
        };
        const handleContentLeave = (e) => {
          __privateMethod(this, _GraceArea_instances, createGraceArea_fn).call(this, e, triggerNode);
        };
        return executeCallbacks(on(triggerNode, "pointerleave", handleTriggerLeave), on(contentNode, "pointerleave", handleContentLeave));
      }
    );
    watch(() => get(__privateGet(this, _pointerGraceArea)), () => {
      const handleTrackPointerGrace = (e) => {
        var _a, _b;
        if (!get(__privateGet(this, _pointerGraceArea))) return;
        const target = e.target;
        if (!isElement2(target)) return;
        const pointerPosition = { x: e.clientX, y: e.clientY };
        const hasEnteredTarget = ((_a = opts.triggerNode()) == null ? void 0 : _a.contains(target)) || ((_b = opts.contentNode()) == null ? void 0 : _b.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, get(__privateGet(this, _pointerGraceArea)));
        if (hasEnteredTarget) {
          __privateMethod(this, _GraceArea_instances, removeGraceArea_fn).call(this);
        } else if (isPointerOutsideGraceArea) {
          __privateMethod(this, _GraceArea_instances, removeGraceArea_fn).call(this);
          opts.onPointerExit();
        }
      };
      const doc = getDocument(opts.triggerNode() ?? opts.contentNode());
      if (!doc) return;
      return on(doc, "pointermove", handleTrackPointerGrace);
    });
  }
};
_opts5 = new WeakMap();
_enabled2 = new WeakMap();
_isPointerInTransit = new WeakMap();
_pointerGraceArea = new WeakMap();
_GraceArea_instances = new WeakSet();
removeGraceArea_fn = function() {
  set(__privateGet(this, _pointerGraceArea), null);
  __privateGet(this, _isPointerInTransit).current = false;
};
createGraceArea_fn = function(e, hoverTarget) {
  const currentTarget = e.currentTarget;
  if (!isHTMLElement2(currentTarget)) return;
  const exitPoint = { x: e.clientX, y: e.clientY };
  const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
  const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
  const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
  const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
  set(__privateGet(this, _pointerGraceArea), graceArea, true);
  __privateGet(this, _isPointerInTransit).current = true;
};
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const tipPadding = padding * 1.5;
  switch (exitSide) {
    case "top":
      return [
        {
          x: exitPoint.x - padding,
          y: exitPoint.y + padding
        },
        { x: exitPoint.x, y: exitPoint.y - tipPadding },
        {
          x: exitPoint.x + padding,
          y: exitPoint.y + padding
        }
      ];
    case "bottom":
      return [
        {
          x: exitPoint.x - padding,
          y: exitPoint.y - padding
        },
        { x: exitPoint.x, y: exitPoint.y + tipPadding },
        {
          x: exitPoint.x + padding,
          y: exitPoint.y - padding
        }
      ];
    case "left":
      return [
        {
          x: exitPoint.x + padding,
          y: exitPoint.y - padding
        },
        { x: exitPoint.x - tipPadding, y: exitPoint.y },
        {
          x: exitPoint.x + padding,
          y: exitPoint.y + padding
        }
      ];
    case "right":
      return [
        {
          x: exitPoint.x - padding,
          y: exitPoint.y - padding
        },
        { x: exitPoint.x + tipPadding, y: exitPoint.y },
        {
          x: exitPoint.x - padding,
          y: exitPoint.y + padding
        }
      ];
  }
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j2 = polygon.length - 1; i < polygon.length; j2 = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b) => {
    if (a2.x < b.x) return -1;
    else if (a2.x > b.x) return 1;
    else if (a2.y < b.y) return -1;
    else if (a2.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p2.y - r.y) >= (q.y - r.y) * (p2.x - r.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p2 = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p2.y - r.y) >= (q.y - r.y) * (p2.x - r.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) return upperHull;
  else return upperHull.concat(lowerHull);
}

// node_modules/bits-ui/dist/bits/menu/menu.svelte.js
var CONTEXT_MENU_TRIGGER_ATTR = "data-context-menu-trigger";
var CONTEXT_MENU_CONTENT_ATTR = "data-context-menu-content";
var MenuRootContext = new Context("Menu.Root");
var MenuMenuContext = new Context("Menu.Root | Menu.Sub");
var MenuContentContext = new Context("Menu.Content");
var MenuGroupContext = new Context("Menu.Group | Menu.RadioGroup");
var MenuRadioGroupContext = new Context("Menu.RadioGroup");
var MenuCheckboxGroupContext = new Context("Menu.CheckboxGroup");
var MenuOpenEvent = new CustomEventDispatcher("bitsmenuopen", { bubbles: false, cancelable: true });
var menuAttrs = createBitsAttrs({
  component: "menu",
  parts: [
    "trigger",
    "content",
    "sub-trigger",
    "item",
    "group",
    "group-heading",
    "checkbox-group",
    "checkbox-item",
    "radio-group",
    "radio-item",
    "separator",
    "sub-content",
    "arrow"
  ]
});
var _ignoreCloseAutoFocus, _isPointerInTransit2;
var _MenuRootState = class _MenuRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "isUsingKeyboard", new IsUsingKeyboard());
    __privateAdd(this, _ignoreCloseAutoFocus, state(false));
    __privateAdd(this, _isPointerInTransit2, state(false));
    __publicField(this, "getBitsAttr", (part) => {
      return menuAttrs.getAttr(part, this.opts.variant.current);
    });
    this.opts = opts;
  }
  static create(opts) {
    const root18 = new _MenuRootState(opts);
    return MenuRootContext.set(root18);
  }
  get ignoreCloseAutoFocus() {
    return get(__privateGet(this, _ignoreCloseAutoFocus));
  }
  set ignoreCloseAutoFocus(value) {
    set(__privateGet(this, _ignoreCloseAutoFocus), value, true);
  }
  get isPointerInTransit() {
    return get(__privateGet(this, _isPointerInTransit2));
  }
  set isPointerInTransit(value) {
    set(__privateGet(this, _isPointerInTransit2), value, true);
  }
};
_ignoreCloseAutoFocus = new WeakMap();
_isPointerInTransit2 = new WeakMap();
var MenuRootState = _MenuRootState;
var _contentNode3, _triggerNode2;
var _MenuMenuState = class _MenuMenuState {
  constructor(opts, root18, parentMenu) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "parentMenu");
    __publicField(this, "contentId", boxWith(() => ""));
    __privateAdd(this, _contentNode3, state(null));
    __publicField(this, "contentPresence");
    __privateAdd(this, _triggerNode2, state(null));
    this.opts = opts;
    this.root = root18;
    this.parentMenu = parentMenu;
    this.contentPresence = new PresenceManager({
      ref: boxWith(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    if (parentMenu) {
      watch(() => parentMenu.opts.open.current, () => {
        if (parentMenu.opts.open.current) return;
        this.opts.open.current = false;
      });
    }
  }
  static create(opts, root18) {
    return MenuMenuContext.set(new _MenuMenuState(opts, root18, null));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode3));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode3), value, true);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode2));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode2), value, true);
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  onOpen() {
    this.opts.open.current = true;
  }
  onClose() {
    this.opts.open.current = false;
  }
};
_contentNode3 = new WeakMap();
_triggerNode2 = new WeakMap();
var MenuMenuState = _MenuMenuState;
var _search2, _timer, _handleTypeaheadSearch, _mounted, _isSub, _MenuContentState_instances, getCandidateNodes_fn, isPointerMovingToSubmenu_fn, _snippetProps4, _props14;
var _MenuContentState = class _MenuContentState {
  constructor(opts, parentMenu) {
    __privateAdd(this, _MenuContentState_instances);
    __publicField(this, "opts");
    __publicField(this, "parentMenu");
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "domContext");
    __publicField(this, "attachment");
    __privateAdd(this, _search2, state(""));
    __privateAdd(this, _timer, 0);
    __privateAdd(this, _handleTypeaheadSearch);
    __privateAdd(this, _mounted, state(false));
    __privateAdd(this, _isSub);
    __publicField(this, "onCloseAutoFocus", (e) => {
      var _a, _b;
      (_b = (_a = this.opts.onCloseAutoFocus).current) == null ? void 0 : _b.call(_a, e);
      if (e.defaultPrevented || __privateGet(this, _isSub)) return;
      if (this.parentMenu.triggerNode && isTabbable(this.parentMenu.triggerNode)) {
        e.preventDefault();
        this.parentMenu.triggerNode.focus();
      }
    });
    __privateAdd(this, _snippetProps4, user_derived(() => ({ open: this.parentMenu.opts.open.current })));
    __privateAdd(this, _props14, user_derived(() => ({
      id: this.opts.id.current,
      role: "menu",
      "aria-orientation": "vertical",
      [this.parentMenu.root.getBitsAttr("content")]: "",
      "data-state": getDataOpenClosed(this.parentMenu.opts.open.current),
      onkeydown: this.onkeydown,
      onblur: this.onblur,
      onfocus: this.onfocus,
      dir: this.parentMenu.root.opts.dir.current,
      style: { pointerEvents: "auto" },
      ...this.attachment
    })));
    __publicField(this, "popperProps", {
      onCloseAutoFocus: (e) => this.onCloseAutoFocus(e)
    });
    this.opts = opts;
    this.parentMenu = parentMenu;
    this.domContext = new DOMContext(opts.ref);
    this.attachment = attachRef(this.opts.ref, (v) => {
      if (this.parentMenu.contentNode !== v) {
        this.parentMenu.contentNode = v;
      }
    });
    parentMenu.contentId = opts.id;
    __privateSet(this, _isSub, opts.isSub ?? false);
    this.onkeydown = this.onkeydown.bind(this);
    this.onblur = this.onblur.bind(this);
    this.onfocus = this.onfocus.bind(this);
    this.handleInteractOutside = this.handleInteractOutside.bind(this);
    new GraceArea({
      contentNode: () => this.parentMenu.contentNode,
      triggerNode: () => this.parentMenu.triggerNode,
      enabled: () => {
        var _a;
        return this.parentMenu.opts.open.current && Boolean((_a = this.parentMenu.triggerNode) == null ? void 0 : _a.hasAttribute(this.parentMenu.root.getBitsAttr("sub-trigger")));
      },
      onPointerExit: () => {
        this.parentMenu.opts.open.current = false;
      },
      setIsPointerInTransit: (value) => {
        this.parentMenu.root.isPointerInTransit = value;
      }
    });
    __privateSet(this, _handleTypeaheadSearch, new DOMTypeahead({
      getActiveElement: () => this.domContext.getActiveElement(),
      getWindow: () => this.domContext.getWindow()
    }).handleTypeaheadSearch);
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: boxWith(() => this.parentMenu.contentNode),
      candidateAttr: this.parentMenu.root.getBitsAttr("item"),
      loop: this.opts.loop,
      orientation: boxWith(() => "vertical")
    });
    watch(() => this.parentMenu.contentNode, (contentNode) => {
      if (!contentNode) return;
      const handler = () => {
        afterTick(() => {
          if (!this.parentMenu.root.isUsingKeyboard.current) return;
          this.rovingFocusGroup.focusFirstCandidate();
        });
      };
      return MenuOpenEvent.listen(contentNode, handler);
    });
    user_effect(() => {
      if (!this.parentMenu.opts.open.current) {
        this.domContext.getWindow().clearTimeout(__privateGet(this, _timer));
      }
    });
  }
  static create(opts) {
    return MenuContentContext.set(new _MenuContentState(opts, MenuMenuContext.get()));
  }
  get search() {
    return get(__privateGet(this, _search2));
  }
  set search(value) {
    set(__privateGet(this, _search2), value, true);
  }
  get mounted() {
    return get(__privateGet(this, _mounted));
  }
  set mounted(value) {
    set(__privateGet(this, _mounted), value, true);
  }
  handleTabKeyDown(e) {
    let rootMenu = this.parentMenu;
    while (rootMenu.parentMenu !== null) {
      rootMenu = rootMenu.parentMenu;
    }
    if (!rootMenu.triggerNode) return;
    e.preventDefault();
    const nodeToFocus = getTabbableFrom(rootMenu.triggerNode, e.shiftKey ? "prev" : "next");
    if (nodeToFocus) {
      this.parentMenu.root.ignoreCloseAutoFocus = true;
      rootMenu.onClose();
      afterTick(() => {
        nodeToFocus.focus();
        afterTick(() => {
          this.parentMenu.root.ignoreCloseAutoFocus = false;
        });
      });
    } else {
      this.domContext.getDocument().body.focus();
    }
  }
  onkeydown(e) {
    var _a, _b;
    if (e.defaultPrevented) return;
    if (e.key === kbd_constants_exports.TAB) {
      this.handleTabKeyDown(e);
      return;
    }
    const target = e.target;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement2(target) || !isHTMLElement2(currentTarget)) return;
    const isKeydownInside = ((_a = target.closest(`[${this.parentMenu.root.getBitsAttr("content")}]`)) == null ? void 0 : _a.id) === this.parentMenu.contentId.current;
    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
    const isCharacterKey = e.key.length === 1;
    const kbdFocusedEl = this.rovingFocusGroup.handleKeydown(target, e);
    if (kbdFocusedEl) return;
    if (e.code === "Space") return;
    const candidateNodes = __privateMethod(this, _MenuContentState_instances, getCandidateNodes_fn).call(this);
    if (isKeydownInside) {
      if (!isModifierKey && isCharacterKey) {
        __privateGet(this, _handleTypeaheadSearch).call(this, e.key, candidateNodes);
      }
    }
    if (((_b = e.target) == null ? void 0 : _b.id) !== this.parentMenu.contentId.current) return;
    if (!FIRST_LAST_KEYS2.includes(e.key)) return;
    e.preventDefault();
    if (LAST_KEYS2.includes(e.key)) {
      candidateNodes.reverse();
    }
    focusFirst(candidateNodes, { select: false }, () => this.domContext.getActiveElement());
  }
  onblur(e) {
    var _a, _b;
    if (!isElement2(e.currentTarget)) return;
    if (!isElement2(e.target)) return;
    if (!((_b = (_a = e.currentTarget).contains) == null ? void 0 : _b.call(_a, e.target))) {
      this.domContext.getWindow().clearTimeout(__privateGet(this, _timer));
      this.search = "";
    }
  }
  onfocus(_) {
    if (!this.parentMenu.root.isUsingKeyboard.current) return;
    afterTick(() => this.rovingFocusGroup.focusFirstCandidate());
  }
  onItemEnter() {
    return __privateMethod(this, _MenuContentState_instances, isPointerMovingToSubmenu_fn).call(this);
  }
  onItemLeave(e) {
    if (e.currentTarget.hasAttribute(this.parentMenu.root.getBitsAttr("sub-trigger"))) return;
    if (__privateMethod(this, _MenuContentState_instances, isPointerMovingToSubmenu_fn).call(this) || this.parentMenu.root.isUsingKeyboard.current) return;
    const contentNode = this.parentMenu.contentNode;
    contentNode == null ? void 0 : contentNode.focus();
    this.rovingFocusGroup.setCurrentTabStopId("");
  }
  onTriggerLeave() {
    if (__privateMethod(this, _MenuContentState_instances, isPointerMovingToSubmenu_fn).call(this)) return true;
    return false;
  }
  handleInteractOutside(e) {
    var _a;
    if (!isElementOrSVGElement(e.target)) return;
    const triggerId = (_a = this.parentMenu.triggerNode) == null ? void 0 : _a.id;
    if (e.target.id === triggerId) {
      e.preventDefault();
      return;
    }
    if (e.target.closest(`#${triggerId}`)) {
      e.preventDefault();
    }
  }
  get shouldRender() {
    return this.parentMenu.contentPresence.shouldRender;
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps4));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps4), value);
  }
  get props() {
    return get(__privateGet(this, _props14));
  }
  set props(value) {
    set(__privateGet(this, _props14), value);
  }
};
_search2 = new WeakMap();
_timer = new WeakMap();
_handleTypeaheadSearch = new WeakMap();
_mounted = new WeakMap();
_isSub = new WeakMap();
_MenuContentState_instances = new WeakSet();
getCandidateNodes_fn = function() {
  const node = this.parentMenu.contentNode;
  if (!node) return [];
  const candidates = Array.from(node.querySelectorAll(`[${this.parentMenu.root.getBitsAttr("item")}]:not([data-disabled])`));
  return candidates;
};
isPointerMovingToSubmenu_fn = function() {
  return this.parentMenu.root.isPointerInTransit;
};
_snippetProps4 = new WeakMap();
_props14 = new WeakMap();
var MenuContentState = _MenuContentState;
var _isFocused, _props15;
var MenuItemSharedState = class {
  constructor(opts, content) {
    __publicField(this, "opts");
    __publicField(this, "content");
    __publicField(this, "attachment");
    __privateAdd(this, _isFocused, state(false));
    __privateAdd(this, _props15, user_derived(() => ({
      id: this.opts.id.current,
      tabindex: -1,
      role: "menuitem",
      "aria-disabled": boolToStr(this.opts.disabled.current),
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      "data-highlighted": get(__privateGet(this, _isFocused)) ? "" : void 0,
      [this.content.parentMenu.root.getBitsAttr("item")]: "",
      //
      onpointermove: this.onpointermove,
      onpointerleave: this.onpointerleave,
      onfocus: this.onfocus,
      onblur: this.onblur,
      ...this.attachment
    })));
    this.opts = opts;
    this.content = content;
    this.attachment = attachRef(this.opts.ref);
    this.onpointermove = this.onpointermove.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
    this.onfocus = this.onfocus.bind(this);
    this.onblur = this.onblur.bind(this);
  }
  onpointermove(e) {
    if (e.defaultPrevented) return;
    if (!isMouseEvent(e)) return;
    if (this.opts.disabled.current) {
      this.content.onItemLeave(e);
    } else {
      const defaultPrevented = this.content.onItemEnter();
      if (defaultPrevented) return;
      const item = e.currentTarget;
      if (!isHTMLElement2(item)) return;
      item.focus();
    }
  }
  onpointerleave(e) {
    if (e.defaultPrevented) return;
    if (!isMouseEvent(e)) return;
    this.content.onItemLeave(e);
  }
  onfocus(e) {
    afterTick(() => {
      if (e.defaultPrevented || this.opts.disabled.current) return;
      set(__privateGet(this, _isFocused), true);
    });
  }
  onblur(e) {
    afterTick(() => {
      if (e.defaultPrevented) return;
      set(__privateGet(this, _isFocused), false);
    });
  }
  get props() {
    return get(__privateGet(this, _props15));
  }
  set props(value) {
    set(__privateGet(this, _props15), value);
  }
};
_isFocused = new WeakMap();
_props15 = new WeakMap();
var _isPointerDown, _MenuItemState_instances, handleSelect_fn, _props16;
var _MenuItemState = class _MenuItemState {
  constructor(opts, item) {
    __privateAdd(this, _MenuItemState_instances);
    __publicField(this, "opts");
    __publicField(this, "item");
    __publicField(this, "root");
    __privateAdd(this, _isPointerDown, false);
    __privateAdd(this, _props16, user_derived(() => mergeProps(this.item.props, {
      onclick: this.onclick,
      onpointerdown: this.onpointerdown,
      onpointerup: this.onpointerup,
      onkeydown: this.onkeydown
    })));
    this.opts = opts;
    this.item = item;
    this.root = item.content.parentMenu.root;
    this.onkeydown = this.onkeydown.bind(this);
    this.onclick = this.onclick.bind(this);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
  }
  static create(opts) {
    const item = new MenuItemSharedState(opts, MenuContentContext.get());
    return new _MenuItemState(opts, item);
  }
  onkeydown(e) {
    const isTypingAhead = this.item.content.search !== "";
    if (this.item.opts.disabled.current || isTypingAhead && e.key === kbd_constants_exports.SPACE) return;
    if (SELECTION_KEYS2.includes(e.key)) {
      if (!isHTMLElement2(e.currentTarget)) return;
      e.currentTarget.click();
      e.preventDefault();
    }
  }
  onclick(_) {
    if (this.item.opts.disabled.current) return;
    __privateMethod(this, _MenuItemState_instances, handleSelect_fn).call(this);
  }
  onpointerup(e) {
    var _a;
    if (e.defaultPrevented) return;
    if (!__privateGet(this, _isPointerDown)) {
      if (!isHTMLElement2(e.currentTarget)) return;
      (_a = e.currentTarget) == null ? void 0 : _a.click();
    }
  }
  onpointerdown(_) {
    __privateSet(this, _isPointerDown, true);
  }
  get props() {
    return get(__privateGet(this, _props16));
  }
  set props(value) {
    set(__privateGet(this, _props16), value);
  }
};
_isPointerDown = new WeakMap();
_MenuItemState_instances = new WeakSet();
handleSelect_fn = function() {
  if (this.item.opts.disabled.current) return;
  const selectEvent = new CustomEvent("menuitemselect", { bubbles: true, cancelable: true });
  this.opts.onSelect.current(selectEvent);
  if (selectEvent.defaultPrevented) {
    this.item.content.parentMenu.root.isUsingKeyboard.current = false;
    return;
  }
  if (this.opts.closeOnSelect.current) {
    this.item.content.parentMenu.root.opts.onClose();
  }
};
_props16 = new WeakMap();
var MenuItemState = _MenuItemState;
var _openTimer, _MenuSubTriggerState_instances, clearOpenTimer_fn, _props17;
var _MenuSubTriggerState = class _MenuSubTriggerState {
  constructor(opts, item, content, submenu) {
    __privateAdd(this, _MenuSubTriggerState_instances);
    __publicField(this, "opts");
    __publicField(this, "item");
    __publicField(this, "content");
    __publicField(this, "submenu");
    __publicField(this, "attachment");
    __privateAdd(this, _openTimer, null);
    __privateAdd(this, _props17, user_derived(() => mergeProps(
      {
        "aria-haspopup": "menu",
        "aria-expanded": boolToStr(this.submenu.opts.open.current),
        "data-state": getDataOpenClosed(this.submenu.opts.open.current),
        "aria-controls": this.submenu.opts.open.current ? this.submenu.contentId.current : void 0,
        [this.submenu.root.getBitsAttr("sub-trigger")]: "",
        onclick: this.onclick,
        onpointermove: this.onpointermove,
        onpointerleave: this.onpointerleave,
        onkeydown: this.onkeydown,
        ...this.attachment
      },
      this.item.props
    )));
    this.opts = opts;
    this.item = item;
    this.content = content;
    this.submenu = submenu;
    this.attachment = attachRef(this.opts.ref, (v) => this.submenu.triggerNode = v);
    this.onpointerleave = this.onpointerleave.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.onclick = this.onclick.bind(this);
    onDestroyEffect(() => {
      __privateMethod(this, _MenuSubTriggerState_instances, clearOpenTimer_fn).call(this);
    });
  }
  static create(opts) {
    const content = MenuContentContext.get();
    const item = new MenuItemSharedState(opts, content);
    const submenu = MenuMenuContext.get();
    return new _MenuSubTriggerState(opts, item, content, submenu);
  }
  onpointermove(e) {
    if (!isMouseEvent(e)) return;
    if (!this.item.opts.disabled.current && !this.submenu.opts.open.current && !__privateGet(this, _openTimer) && !this.content.parentMenu.root.isPointerInTransit) {
      __privateSet(this, _openTimer, this.content.domContext.setTimeout(
        () => {
          this.submenu.onOpen();
          __privateMethod(this, _MenuSubTriggerState_instances, clearOpenTimer_fn).call(this);
        },
        this.opts.openDelay.current
      ));
    }
  }
  onpointerleave(e) {
    if (!isMouseEvent(e)) return;
    __privateMethod(this, _MenuSubTriggerState_instances, clearOpenTimer_fn).call(this);
  }
  onkeydown(e) {
    const isTypingAhead = this.content.search !== "";
    if (this.item.opts.disabled.current || isTypingAhead && e.key === kbd_constants_exports.SPACE) return;
    if (SUB_OPEN_KEYS[this.submenu.root.opts.dir.current].includes(e.key)) {
      e.currentTarget.click();
      e.preventDefault();
    }
  }
  onclick(e) {
    if (this.item.opts.disabled.current) return;
    if (!isHTMLElement2(e.currentTarget)) return;
    e.currentTarget.focus();
    const selectEvent = new CustomEvent("menusubtriggerselect", { bubbles: true, cancelable: true });
    this.opts.onSelect.current(selectEvent);
    if (!this.submenu.opts.open.current) {
      this.submenu.onOpen();
      afterTick(() => {
        const contentNode = this.submenu.contentNode;
        if (!contentNode) return;
        MenuOpenEvent.dispatch(contentNode);
      });
    }
  }
  get props() {
    return get(__privateGet(this, _props17));
  }
  set props(value) {
    set(__privateGet(this, _props17), value);
  }
};
_openTimer = new WeakMap();
_MenuSubTriggerState_instances = new WeakSet();
clearOpenTimer_fn = function() {
  if (__privateGet(this, _openTimer) === null) return;
  this.content.domContext.getWindow().clearTimeout(__privateGet(this, _openTimer));
  __privateSet(this, _openTimer, null);
};
_props17 = new WeakMap();
var MenuSubTriggerState = _MenuSubTriggerState;
var _snippetProps5, _props18;
var _MenuCheckboxItemState = class _MenuCheckboxItemState {
  constructor(opts, item, group = null) {
    __publicField(this, "opts");
    __publicField(this, "item");
    __publicField(this, "group");
    __privateAdd(this, _snippetProps5, user_derived(() => ({
      checked: this.opts.checked.current,
      indeterminate: this.opts.indeterminate.current
    })));
    __privateAdd(this, _props18, user_derived(() => ({
      ...this.item.props,
      role: "menuitemcheckbox",
      "aria-checked": getAriaChecked(this.opts.checked.current, this.opts.indeterminate.current),
      "data-state": getCheckedState(this.opts.checked.current),
      [this.item.root.getBitsAttr("checkbox-item")]: ""
    })));
    this.opts = opts;
    this.item = item;
    this.group = group;
    if (this.group) {
      watch(() => this.group.opts.value.current, (groupValues) => {
        this.opts.checked.current = groupValues.includes(this.opts.value.current);
      });
      watch(() => this.opts.checked.current, (checked) => {
        if (checked) {
          this.group.addValue(this.opts.value.current);
        } else {
          this.group.removeValue(this.opts.value.current);
        }
      });
    }
  }
  static create(opts, checkboxGroup) {
    const item = new MenuItemState(opts, new MenuItemSharedState(opts, MenuContentContext.get()));
    return new _MenuCheckboxItemState(opts, item, checkboxGroup);
  }
  toggleChecked() {
    if (this.opts.indeterminate.current) {
      this.opts.indeterminate.current = false;
      this.opts.checked.current = true;
    } else {
      this.opts.checked.current = !this.opts.checked.current;
    }
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps5));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps5), value);
  }
  get props() {
    return get(__privateGet(this, _props18));
  }
  set props(value) {
    set(__privateGet(this, _props18), value);
  }
};
_snippetProps5 = new WeakMap();
_props18 = new WeakMap();
var MenuCheckboxItemState = _MenuCheckboxItemState;
var _groupHeadingId, _props19;
var _MenuGroupState = class _MenuGroupState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _groupHeadingId, state(void 0));
    __privateAdd(this, _props19, user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      "aria-labelledby": this.groupHeadingId,
      [this.root.getBitsAttr("group")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return MenuGroupContext.set(new _MenuGroupState(opts, MenuRootContext.get()));
  }
  get groupHeadingId() {
    return get(__privateGet(this, _groupHeadingId));
  }
  set groupHeadingId(value) {
    set(__privateGet(this, _groupHeadingId), value, true);
  }
  get props() {
    return get(__privateGet(this, _props19));
  }
  set props(value) {
    set(__privateGet(this, _props19), value);
  }
};
_groupHeadingId = new WeakMap();
_props19 = new WeakMap();
var MenuGroupState = _MenuGroupState;
var _props20;
var _MenuGroupHeadingState = class _MenuGroupHeadingState {
  constructor(opts, group) {
    __publicField(this, "opts");
    __publicField(this, "group");
    __publicField(this, "attachment");
    __privateAdd(this, _props20, user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      [this.group.root.getBitsAttr("group-heading")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref, (v) => this.group.groupHeadingId = v == null ? void 0 : v.id);
  }
  static create(opts) {
    const checkboxGroup = MenuCheckboxGroupContext.getOr(null);
    if (checkboxGroup) return new _MenuGroupHeadingState(opts, checkboxGroup);
    const radioGroup = MenuRadioGroupContext.getOr(null);
    if (radioGroup) return new _MenuGroupHeadingState(opts, radioGroup);
    return new _MenuGroupHeadingState(opts, MenuGroupContext.get());
  }
  get props() {
    return get(__privateGet(this, _props20));
  }
  set props(value) {
    set(__privateGet(this, _props20), value);
  }
};
_props20 = new WeakMap();
var MenuGroupHeadingState = _MenuGroupHeadingState;
var _props21;
var _MenuSeparatorState = class _MenuSeparatorState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props21, user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      [this.root.getBitsAttr("separator")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _MenuSeparatorState(opts, MenuRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props21));
  }
  set props(value) {
    set(__privateGet(this, _props21), value);
  }
};
_props21 = new WeakMap();
var MenuSeparatorState = _MenuSeparatorState;
var _props22;
var _MenuArrowState = class _MenuArrowState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _props22, user_derived(() => ({ [this.root.getBitsAttr("arrow")]: "" })));
    this.root = root18;
  }
  static create() {
    return new _MenuArrowState(MenuRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props22));
  }
  set props(value) {
    set(__privateGet(this, _props22), value);
  }
};
_props22 = new WeakMap();
var MenuArrowState = _MenuArrowState;
var _groupHeadingId2, _props23;
var _MenuRadioGroupState = class _MenuRadioGroupState {
  constructor(opts, content) {
    __publicField(this, "opts");
    __publicField(this, "content");
    __publicField(this, "attachment");
    __privateAdd(this, _groupHeadingId2, state(null));
    __publicField(this, "root");
    __privateAdd(this, _props23, user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr("radio-group")]: "",
      role: "group",
      "aria-labelledby": this.groupHeadingId,
      ...this.attachment
    })));
    this.opts = opts;
    this.content = content;
    this.root = content.parentMenu.root;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return MenuGroupContext.set(MenuRadioGroupContext.set(new _MenuRadioGroupState(opts, MenuContentContext.get())));
  }
  get groupHeadingId() {
    return get(__privateGet(this, _groupHeadingId2));
  }
  set groupHeadingId(value) {
    set(__privateGet(this, _groupHeadingId2), value, true);
  }
  setValue(v) {
    this.opts.value.current = v;
  }
  get props() {
    return get(__privateGet(this, _props23));
  }
  set props(value) {
    set(__privateGet(this, _props23), value);
  }
};
_groupHeadingId2 = new WeakMap();
_props23 = new WeakMap();
var MenuRadioGroupState = _MenuRadioGroupState;
var _isChecked, _props24;
var _MenuRadioItemState = class _MenuRadioItemState {
  constructor(opts, item, group) {
    __publicField(this, "opts");
    __publicField(this, "item");
    __publicField(this, "group");
    __publicField(this, "attachment");
    __privateAdd(this, _isChecked, user_derived(() => this.group.opts.value.current === this.opts.value.current));
    __privateAdd(this, _props24, user_derived(() => ({
      [this.group.root.getBitsAttr("radio-item")]: "",
      ...this.item.props,
      role: "menuitemradio",
      "aria-checked": getAriaChecked(this.isChecked, false),
      "data-state": getCheckedState(this.isChecked),
      ...this.attachment
    })));
    this.opts = opts;
    this.item = item;
    this.group = group;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    const radioGroup = MenuRadioGroupContext.get();
    const sharedItem = new MenuItemSharedState(opts, radioGroup.content);
    const item = new MenuItemState(opts, sharedItem);
    return new _MenuRadioItemState(opts, item, radioGroup);
  }
  get isChecked() {
    return get(__privateGet(this, _isChecked));
  }
  set isChecked(value) {
    set(__privateGet(this, _isChecked), value);
  }
  selectValue() {
    this.group.setValue(this.opts.value.current);
  }
  get props() {
    return get(__privateGet(this, _props24));
  }
  set props(value) {
    set(__privateGet(this, _props24), value);
  }
};
_isChecked = new WeakMap();
_props24 = new WeakMap();
var MenuRadioItemState = _MenuRadioItemState;
var _ariaControls, _props25;
var _DropdownMenuTriggerState = class _DropdownMenuTriggerState {
  constructor(opts, parentMenu) {
    __publicField(this, "opts");
    __publicField(this, "parentMenu");
    __publicField(this, "attachment");
    __publicField(this, "onclick", (e) => {
      if (this.opts.disabled.current || e.detail !== 0) return;
      this.parentMenu.toggleOpen();
      e.preventDefault();
    });
    __publicField(this, "onpointerdown", (e) => {
      if (this.opts.disabled.current) return;
      if (e.pointerType === "touch") return e.preventDefault();
      if (e.button === 0 && e.ctrlKey === false) {
        this.parentMenu.toggleOpen();
        if (!this.parentMenu.opts.open.current) e.preventDefault();
      }
    });
    __publicField(this, "onpointerup", (e) => {
      if (this.opts.disabled.current) return;
      if (e.pointerType === "touch") {
        e.preventDefault();
        this.parentMenu.toggleOpen();
      }
    });
    __publicField(this, "onkeydown", (e) => {
      if (this.opts.disabled.current) return;
      if (e.key === kbd_constants_exports.SPACE || e.key === kbd_constants_exports.ENTER) {
        this.parentMenu.toggleOpen();
        e.preventDefault();
        return;
      }
      if (e.key === kbd_constants_exports.ARROW_DOWN) {
        this.parentMenu.onOpen();
        e.preventDefault();
      }
    });
    __privateAdd(this, _ariaControls, user_derived(() => {
      if (this.parentMenu.opts.open.current && this.parentMenu.contentId.current) return this.parentMenu.contentId.current;
      return void 0;
    }));
    __privateAdd(this, _props25, user_derived(() => ({
      id: this.opts.id.current,
      disabled: this.opts.disabled.current,
      "aria-haspopup": "menu",
      "aria-expanded": boolToStr(this.parentMenu.opts.open.current),
      "aria-controls": get(__privateGet(this, _ariaControls)),
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      "data-state": getDataOpenClosed(this.parentMenu.opts.open.current),
      [this.parentMenu.root.getBitsAttr("trigger")]: "",
      //
      onclick: this.onclick,
      onpointerdown: this.onpointerdown,
      onpointerup: this.onpointerup,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.parentMenu = parentMenu;
    this.attachment = attachRef(this.opts.ref, (v) => this.parentMenu.triggerNode = v);
  }
  static create(opts) {
    return new _DropdownMenuTriggerState(opts, MenuMenuContext.get());
  }
  get props() {
    return get(__privateGet(this, _props25));
  }
  set props(value) {
    set(__privateGet(this, _props25), value);
  }
};
_ariaControls = new WeakMap();
_props25 = new WeakMap();
var DropdownMenuTriggerState = _DropdownMenuTriggerState;
var _point, _longPressTimer, _ContextMenuTriggerState_instances, clearLongPressTimer_fn, handleOpen_fn, _props26;
var _ContextMenuTriggerState = class _ContextMenuTriggerState {
  constructor(opts, parentMenu) {
    __privateAdd(this, _ContextMenuTriggerState_instances);
    __publicField(this, "opts");
    __publicField(this, "parentMenu");
    __publicField(this, "attachment");
    __privateAdd(this, _point, state(proxy({ x: 0, y: 0 })));
    __publicField(this, "virtualElement", simpleBox({
      getBoundingClientRect: () => DOMRect.fromRect({
        width: 0,
        height: 0,
        ...get(__privateGet(this, _point))
      })
    }));
    __privateAdd(this, _longPressTimer, null);
    __privateAdd(this, _props26, user_derived(() => ({
      id: this.opts.id.current,
      disabled: this.opts.disabled.current,
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      "data-state": getDataOpenClosed(this.parentMenu.opts.open.current),
      [CONTEXT_MENU_TRIGGER_ATTR]: "",
      tabindex: -1,
      //
      onpointerdown: this.onpointerdown,
      onpointermove: this.onpointermove,
      onpointercancel: this.onpointercancel,
      onpointerup: this.onpointerup,
      oncontextmenu: this.oncontextmenu,
      ...this.attachment
    })));
    this.opts = opts;
    this.parentMenu = parentMenu;
    this.attachment = attachRef(this.opts.ref, (v) => this.parentMenu.triggerNode = v);
    this.oncontextmenu = this.oncontextmenu.bind(this);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
    this.onpointercancel = this.onpointercancel.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
    watch(() => get(__privateGet(this, _point)), (point) => {
      this.virtualElement.current = {
        getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...point })
      };
    });
    watch(() => this.opts.disabled.current, (isDisabled) => {
      if (isDisabled) {
        __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this);
      }
    });
    onDestroyEffect(() => __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this));
  }
  static create(opts) {
    return new _ContextMenuTriggerState(opts, MenuMenuContext.get());
  }
  oncontextmenu(e) {
    var _a;
    if (e.defaultPrevented || this.opts.disabled.current) return;
    __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this);
    __privateMethod(this, _ContextMenuTriggerState_instances, handleOpen_fn).call(this, e);
    e.preventDefault();
    (_a = this.parentMenu.contentNode) == null ? void 0 : _a.focus();
  }
  onpointerdown(e) {
    if (this.opts.disabled.current || isMouseEvent(e)) return;
    __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this);
    __privateSet(this, _longPressTimer, getWindow(this.opts.ref.current).setTimeout(() => __privateMethod(this, _ContextMenuTriggerState_instances, handleOpen_fn).call(this, e), 700));
  }
  onpointermove(e) {
    if (this.opts.disabled.current || isMouseEvent(e)) return;
    __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this);
  }
  onpointercancel(e) {
    if (this.opts.disabled.current || isMouseEvent(e)) return;
    __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this);
  }
  onpointerup(e) {
    if (this.opts.disabled.current || isMouseEvent(e)) return;
    __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this);
  }
  get props() {
    return get(__privateGet(this, _props26));
  }
  set props(value) {
    set(__privateGet(this, _props26), value);
  }
};
_point = new WeakMap();
_longPressTimer = new WeakMap();
_ContextMenuTriggerState_instances = new WeakSet();
clearLongPressTimer_fn = function() {
  if (__privateGet(this, _longPressTimer) === null) return;
  getWindow(this.opts.ref.current).clearTimeout(__privateGet(this, _longPressTimer));
};
handleOpen_fn = function(e) {
  set(__privateGet(this, _point), { x: e.clientX, y: e.clientY }, true);
  this.parentMenu.onOpen();
};
_props26 = new WeakMap();
var ContextMenuTriggerState = _ContextMenuTriggerState;
var _groupHeadingId3, _props27;
var _MenuCheckboxGroupState = class _MenuCheckboxGroupState {
  constructor(opts, content) {
    __publicField(this, "opts");
    __publicField(this, "content");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _groupHeadingId3, state(null));
    __privateAdd(this, _props27, user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr("checkbox-group")]: "",
      role: "group",
      "aria-labelledby": this.groupHeadingId,
      ...this.attachment
    })));
    this.opts = opts;
    this.content = content;
    this.root = content.parentMenu.root;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return MenuCheckboxGroupContext.set(new _MenuCheckboxGroupState(opts, MenuContentContext.get()));
  }
  get groupHeadingId() {
    return get(__privateGet(this, _groupHeadingId3));
  }
  set groupHeadingId(value) {
    set(__privateGet(this, _groupHeadingId3), value, true);
  }
  addValue(checkboxValue) {
    if (!checkboxValue) return;
    if (!this.opts.value.current.includes(checkboxValue)) {
      const newValue = [
        ...snapshot(this.opts.value.current),
        checkboxValue
      ];
      this.opts.value.current = newValue;
      this.opts.onValueChange.current(newValue);
    }
  }
  removeValue(checkboxValue) {
    if (!checkboxValue) return;
    const index = this.opts.value.current.indexOf(checkboxValue);
    if (index === -1) return;
    const newValue = this.opts.value.current.filter((v) => v !== checkboxValue);
    this.opts.value.current = newValue;
    this.opts.onValueChange.current(newValue);
  }
  get props() {
    return get(__privateGet(this, _props27));
  }
  set props(value) {
    set(__privateGet(this, _props27), value);
  }
};
_groupHeadingId3 = new WeakMap();
_props27 = new WeakMap();
var MenuCheckboxGroupState = _MenuCheckboxGroupState;
var MenuSubmenuState = class {
  static create(opts) {
    const menu = MenuMenuContext.get();
    return MenuMenuContext.set(new MenuMenuState(opts, menu.root, menu));
  }
};

// node_modules/bits-ui/dist/bits/utilities/dismissible-layer/use-dismissable-layer.svelte.js
globalThis.bitsDismissableLayers ?? (globalThis.bitsDismissableLayers = /* @__PURE__ */ new Map());
var _interactOutsideProp, _behaviorType, _interceptedEvents, _isResponsibleLayer, _isFocusInsideDOMTree, _documentObj, _onFocusOutside, _unsubClickListener, _handleFocus, _DismissibleLayerState_instances, addEventListeners_fn, _handleDismiss, _handleInteractOutside, _markInterceptedEvent, _markNonInterceptedEvent, _markResponsibleLayer, _isTargetWithinLayer, _resetState, isAnyEventIntercepted_fn, _onfocuscapture, _onblurcapture;
var _DismissibleLayerState = class _DismissibleLayerState {
  constructor(opts) {
    __privateAdd(this, _DismissibleLayerState_instances);
    __publicField(this, "opts");
    __privateAdd(this, _interactOutsideProp);
    __privateAdd(this, _behaviorType);
    __privateAdd(this, _interceptedEvents, { pointerdown: false });
    __privateAdd(this, _isResponsibleLayer, false);
    __privateAdd(this, _isFocusInsideDOMTree, false);
    __privateAdd(this, _documentObj);
    __privateAdd(this, _onFocusOutside);
    __privateAdd(this, _unsubClickListener, noop3);
    __privateAdd(this, _handleFocus, (event) => {
      if (event.defaultPrevented) return;
      if (!this.opts.ref.current) return;
      afterTick(() => {
        var _a, _b;
        if (!this.opts.ref.current || __privateGet(this, _isTargetWithinLayer).call(this, event.target)) return;
        if (event.target && !__privateGet(this, _isFocusInsideDOMTree)) {
          (_b = (_a = __privateGet(this, _onFocusOutside)).current) == null ? void 0 : _b.call(_a, event);
        }
      });
    });
    __privateAdd(this, _handleDismiss, (e) => {
      let event = e;
      if (event.defaultPrevented) {
        event = createWrappedEvent(e);
      }
      __privateGet(this, _interactOutsideProp).current(e);
    });
    __privateAdd(this, _handleInteractOutside, debounce2(
      (e) => {
        if (!this.opts.ref.current) {
          __privateGet(this, _unsubClickListener).call(this);
          return;
        }
        const isEventValid = this.opts.isValidEvent.current(e, this.opts.ref.current) || isValidEvent(e, this.opts.ref.current);
        if (!__privateGet(this, _isResponsibleLayer) || __privateMethod(this, _DismissibleLayerState_instances, isAnyEventIntercepted_fn).call(this) || !isEventValid) {
          __privateGet(this, _unsubClickListener).call(this);
          return;
        }
        let event = e;
        if (event.defaultPrevented) {
          event = createWrappedEvent(event);
        }
        if (__privateGet(this, _behaviorType).current !== "close" && __privateGet(this, _behaviorType).current !== "defer-otherwise-close") {
          __privateGet(this, _unsubClickListener).call(this);
          return;
        }
        if (e.pointerType === "touch") {
          __privateGet(this, _unsubClickListener).call(this);
          __privateSet(this, _unsubClickListener, on(__privateGet(this, _documentObj), "click", __privateGet(this, _handleDismiss), { once: true }));
        } else {
          __privateGet(this, _interactOutsideProp).current(event);
        }
      },
      10
    ));
    __privateAdd(this, _markInterceptedEvent, (e) => {
      __privateGet(this, _interceptedEvents)[e.type] = true;
    });
    __privateAdd(this, _markNonInterceptedEvent, (e) => {
      __privateGet(this, _interceptedEvents)[e.type] = false;
    });
    __privateAdd(this, _markResponsibleLayer, () => {
      if (!this.opts.ref.current) return;
      __privateSet(this, _isResponsibleLayer, isResponsibleLayer(this.opts.ref.current));
    });
    __privateAdd(this, _isTargetWithinLayer, (target) => {
      if (!this.opts.ref.current) return false;
      return isOrContainsTarget2(this.opts.ref.current, target);
    });
    __privateAdd(this, _resetState, debounce2(
      () => {
        for (const eventType in __privateGet(this, _interceptedEvents)) {
          __privateGet(this, _interceptedEvents)[eventType] = false;
        }
        __privateSet(this, _isResponsibleLayer, false);
      },
      20
    ));
    __privateAdd(this, _onfocuscapture, () => {
      __privateSet(this, _isFocusInsideDOMTree, true);
    });
    __privateAdd(this, _onblurcapture, () => {
      __privateSet(this, _isFocusInsideDOMTree, false);
    });
    __publicField(this, "props", {
      onfocuscapture: __privateGet(this, _onfocuscapture),
      onblurcapture: __privateGet(this, _onblurcapture)
    });
    this.opts = opts;
    __privateSet(this, _behaviorType, opts.interactOutsideBehavior);
    __privateSet(this, _interactOutsideProp, opts.onInteractOutside);
    __privateSet(this, _onFocusOutside, opts.onFocusOutside);
    user_effect(() => {
      __privateSet(this, _documentObj, getOwnerDocument2(this.opts.ref.current));
    });
    let unsubEvents = noop3;
    const cleanup = () => {
      __privateGet(this, _resetState).call(this);
      globalThis.bitsDismissableLayers.delete(this);
      __privateGet(this, _handleInteractOutside).destroy();
      unsubEvents();
    };
    watch(
      [
        () => this.opts.enabled.current,
        () => this.opts.ref.current
      ],
      () => {
        if (!this.opts.enabled.current || !this.opts.ref.current) return;
        afterSleep(1, () => {
          if (!this.opts.ref.current) return;
          globalThis.bitsDismissableLayers.set(this, __privateGet(this, _behaviorType));
          unsubEvents();
          unsubEvents = __privateMethod(this, _DismissibleLayerState_instances, addEventListeners_fn).call(this);
        });
        return cleanup;
      }
    );
    onDestroyEffect(() => {
      __privateGet(this, _resetState).destroy();
      globalThis.bitsDismissableLayers.delete(this);
      __privateGet(this, _handleInteractOutside).destroy();
      __privateGet(this, _unsubClickListener).call(this);
      unsubEvents();
    });
  }
  static create(opts) {
    return new _DismissibleLayerState(opts);
  }
};
_interactOutsideProp = new WeakMap();
_behaviorType = new WeakMap();
_interceptedEvents = new WeakMap();
_isResponsibleLayer = new WeakMap();
_isFocusInsideDOMTree = new WeakMap();
_documentObj = new WeakMap();
_onFocusOutside = new WeakMap();
_unsubClickListener = new WeakMap();
_handleFocus = new WeakMap();
_DismissibleLayerState_instances = new WeakSet();
addEventListeners_fn = function() {
  return executeCallbacks(
    /**
    * CAPTURE INTERACTION START
    * mark interaction-start event as intercepted.
    * mark responsible layer during interaction start
    * to avoid checking if is responsible layer during interaction end
    * when a new floating element may have been opened.
    */
    on(__privateGet(this, _documentObj), "pointerdown", executeCallbacks(__privateGet(this, _markInterceptedEvent), __privateGet(this, _markResponsibleLayer)), { capture: true }),
    /**
    * BUBBLE INTERACTION START
    * Mark interaction-start event as non-intercepted. Debounce `onInteractOutsideStart`
    * to avoid prematurely checking if other events were intercepted.
    */
    on(__privateGet(this, _documentObj), "pointerdown", executeCallbacks(__privateGet(this, _markNonInterceptedEvent), __privateGet(this, _handleInteractOutside))),
    /**
    * HANDLE FOCUS OUTSIDE
    */
    on(__privateGet(this, _documentObj), "focusin", __privateGet(this, _handleFocus))
  );
};
_handleDismiss = new WeakMap();
_handleInteractOutside = new WeakMap();
_markInterceptedEvent = new WeakMap();
_markNonInterceptedEvent = new WeakMap();
_markResponsibleLayer = new WeakMap();
_isTargetWithinLayer = new WeakMap();
_resetState = new WeakMap();
isAnyEventIntercepted_fn = function() {
  const i = Object.values(__privateGet(this, _interceptedEvents)).some(Boolean);
  return i;
};
_onfocuscapture = new WeakMap();
_onblurcapture = new WeakMap();
var DismissibleLayerState = _DismissibleLayerState;
function getTopMostDismissableLayer(layersArr = [...globalThis.bitsDismissableLayers]) {
  return layersArr.findLast(([_, { current: behaviorType }]) => behaviorType === "close" || behaviorType === "ignore");
}
function isResponsibleLayer(node) {
  const layersArr = [...globalThis.bitsDismissableLayers];
  const topMostLayer = getTopMostDismissableLayer(layersArr);
  if (topMostLayer) return topMostLayer[0].opts.ref.current === node;
  const [firstLayerNode] = layersArr[0];
  return firstLayerNode.opts.ref.current === node;
}
function isValidEvent(e, node) {
  const target = e.target;
  if (!isElementOrSVGElement(target)) return false;
  const targetIsContextMenuTrigger = Boolean(target.closest(`[${CONTEXT_MENU_TRIGGER_ATTR}]`));
  if ("button" in e && e.button > 0 && !targetIsContextMenuTrigger) return false;
  if ("button" in e && e.button === 0 && targetIsContextMenuTrigger) return true;
  const nodeIsContextMenu = Boolean(node.closest(`[${CONTEXT_MENU_CONTENT_ATTR}]`));
  if (targetIsContextMenuTrigger && nodeIsContextMenu) return false;
  const ownerDocument = getOwnerDocument2(target);
  const isValid = ownerDocument.documentElement.contains(target) && !isOrContainsTarget2(node, target) && isClickTrulyOutside(e, node);
  return isValid;
}
function createWrappedEvent(e) {
  const capturedCurrentTarget = e.currentTarget;
  const capturedTarget = e.target;
  let newEvent;
  if (e instanceof PointerEvent) {
    newEvent = new PointerEvent(e.type, e);
  } else {
    newEvent = new PointerEvent("pointerdown", e);
  }
  let isPrevented = false;
  const wrappedEvent = new Proxy(newEvent, {
    get: (target, prop2) => {
      if (prop2 === "currentTarget") {
        return capturedCurrentTarget;
      }
      if (prop2 === "target") {
        return capturedTarget;
      }
      if (prop2 === "preventDefault") {
        return () => {
          isPrevented = true;
          if (typeof target.preventDefault === "function") {
            target.preventDefault();
          }
        };
      }
      if (prop2 === "defaultPrevented") {
        return isPrevented;
      }
      if (prop2 in target) {
        return target[prop2];
      }
      return e[prop2];
    }
  });
  return wrappedEvent;
}

// node_modules/bits-ui/dist/bits/utilities/dismissible-layer/dismissible-layer.svelte
function Dismissible_layer($$anchor, $$props) {
  push($$props, true);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false);
  const dismissibleLayerState = DismissibleLayerState.create({
    id: boxWith(() => $$props.id),
    interactOutsideBehavior: boxWith(() => interactOutsideBehavior()),
    onInteractOutside: boxWith(() => onInteractOutside()),
    enabled: boxWith(() => $$props.enabled),
    onFocusOutside: boxWith(() => onFocusOutside()),
    isValidEvent: boxWith(() => isValidEvent2()),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop, () => ({ props: dismissibleLayerState.props }));
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/escape-layer/use-escape-layer.svelte.js
globalThis.bitsEscapeLayers ?? (globalThis.bitsEscapeLayers = /* @__PURE__ */ new Map());
var _addEventListener, _onkeydown;
var _EscapeLayerState = class _EscapeLayerState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "domContext");
    __privateAdd(this, _addEventListener, () => {
      return on(this.domContext.getDocument(), "keydown", __privateGet(this, _onkeydown), { passive: false });
    });
    __privateAdd(this, _onkeydown, (e) => {
      if (e.key !== kbd_constants_exports.ESCAPE || !isResponsibleEscapeLayer(this)) return;
      const clonedEvent = new KeyboardEvent(e.type, e);
      e.preventDefault();
      const behaviorType = this.opts.escapeKeydownBehavior.current;
      if (behaviorType !== "close" && behaviorType !== "defer-otherwise-close") return;
      this.opts.onEscapeKeydown.current(clonedEvent);
    });
    this.opts = opts;
    this.domContext = new DOMContext(this.opts.ref);
    let unsubEvents = noop3;
    watch(() => opts.enabled.current, (enabled) => {
      if (enabled) {
        globalThis.bitsEscapeLayers.set(this, opts.escapeKeydownBehavior);
        unsubEvents = __privateGet(this, _addEventListener).call(this);
      }
      return () => {
        unsubEvents();
        globalThis.bitsEscapeLayers.delete(this);
      };
    });
  }
  static create(opts) {
    return new _EscapeLayerState(opts);
  }
};
_addEventListener = new WeakMap();
_onkeydown = new WeakMap();
var EscapeLayerState = _EscapeLayerState;
function isResponsibleEscapeLayer(instance) {
  const layersArr = [...globalThis.bitsEscapeLayers];
  const topMostLayer = layersArr.findLast(([_, { current: behaviorType }]) => behaviorType === "close" || behaviorType === "ignore");
  if (topMostLayer) return topMostLayer[0] === instance;
  const [firstLayerNode] = layersArr[0];
  return firstLayerNode === instance;
}

// node_modules/bits-ui/dist/bits/utilities/escape-layer/escape-layer.svelte
function Escape_layer($$anchor, $$props) {
  push($$props, true);
  let escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "close"), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3);
  EscapeLayerState.create({
    escapeKeydownBehavior: boxWith(() => escapeKeydownBehavior()),
    onEscapeKeydown: boxWith(() => onEscapeKeydown()),
    enabled: boxWith(() => $$props.enabled),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope-manager.js
var _scopeStack, _focusHistory, _preFocusHistory;
var _FocusScopeManager = class _FocusScopeManager {
  constructor() {
    __privateAdd(this, _scopeStack, simpleBox([]));
    __privateAdd(this, _focusHistory, /* @__PURE__ */ new WeakMap());
    __privateAdd(this, _preFocusHistory, /* @__PURE__ */ new WeakMap());
  }
  static getInstance() {
    if (!this.instance) {
      this.instance = new _FocusScopeManager();
    }
    return this.instance;
  }
  register(scope) {
    const current = this.getActive();
    if (current && current !== scope) {
      current.pause();
    }
    const activeElement2 = document.activeElement;
    if (activeElement2 && activeElement2 !== document.body) {
      __privateGet(this, _preFocusHistory).set(scope, activeElement2);
    }
    __privateGet(this, _scopeStack).current = __privateGet(this, _scopeStack).current.filter((s) => s !== scope);
    __privateGet(this, _scopeStack).current.unshift(scope);
  }
  unregister(scope) {
    __privateGet(this, _scopeStack).current = __privateGet(this, _scopeStack).current.filter((s) => s !== scope);
    const next3 = this.getActive();
    if (next3) {
      next3.resume();
    }
  }
  getActive() {
    return __privateGet(this, _scopeStack).current[0];
  }
  setFocusMemory(scope, element2) {
    __privateGet(this, _focusHistory).set(scope, element2);
  }
  getFocusMemory(scope) {
    return __privateGet(this, _focusHistory).get(scope);
  }
  isActiveScope(scope) {
    return this.getActive() === scope;
  }
  setPreFocusMemory(scope, element2) {
    __privateGet(this, _preFocusHistory).set(scope, element2);
  }
  getPreFocusMemory(scope) {
    return __privateGet(this, _preFocusHistory).get(scope);
  }
  clearPreFocusMemory(scope) {
    __privateGet(this, _preFocusHistory).delete(scope);
  }
};
_scopeStack = new WeakMap();
_focusHistory = new WeakMap();
_preFocusHistory = new WeakMap();
__publicField(_FocusScopeManager, "instance");
var FocusScopeManager = _FocusScopeManager;

// node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte.js
var _paused, _container, _manager, _cleanupFns, _opts6, _FocusScope_instances, cleanup_fn2, handleOpenAutoFocus_fn, handleCloseAutoFocus_fn, setupEventListeners_fn, getTabbables_fn, getFirstTabbable_fn, getAllFocusables_fn;
var _FocusScope = class _FocusScope {
  constructor(opts) {
    __privateAdd(this, _FocusScope_instances);
    __privateAdd(this, _paused, false);
    __privateAdd(this, _container, null);
    __privateAdd(this, _manager, FocusScopeManager.getInstance());
    __privateAdd(this, _cleanupFns, []);
    __privateAdd(this, _opts6);
    __privateSet(this, _opts6, opts);
  }
  get paused() {
    return __privateGet(this, _paused);
  }
  pause() {
    __privateSet(this, _paused, true);
  }
  resume() {
    __privateSet(this, _paused, false);
  }
  mount(container) {
    if (__privateGet(this, _container)) {
      this.unmount();
    }
    __privateSet(this, _container, container);
    __privateGet(this, _manager).register(this);
    __privateMethod(this, _FocusScope_instances, setupEventListeners_fn).call(this);
    __privateMethod(this, _FocusScope_instances, handleOpenAutoFocus_fn).call(this);
  }
  unmount() {
    if (!__privateGet(this, _container)) return;
    __privateMethod(this, _FocusScope_instances, cleanup_fn2).call(this);
    __privateMethod(this, _FocusScope_instances, handleCloseAutoFocus_fn).call(this);
    __privateGet(this, _manager).unregister(this);
    __privateGet(this, _manager).clearPreFocusMemory(this);
    __privateSet(this, _container, null);
  }
  static use(opts) {
    let scope = null;
    watch(
      [
        () => opts.ref.current,
        () => opts.enabled.current
      ],
      ([ref, enabled]) => {
        if (ref && enabled) {
          if (!scope) {
            scope = new _FocusScope(opts);
          }
          scope.mount(ref);
        } else if (scope) {
          scope.unmount();
          scope = null;
        }
      }
    );
    onDestroyEffect(() => {
      scope == null ? void 0 : scope.unmount();
    });
    return {
      get props() {
        return { tabindex: -1 };
      }
    };
  }
};
_paused = new WeakMap();
_container = new WeakMap();
_manager = new WeakMap();
_cleanupFns = new WeakMap();
_opts6 = new WeakMap();
_FocusScope_instances = new WeakSet();
cleanup_fn2 = function() {
  for (const fn of __privateGet(this, _cleanupFns)) {
    fn();
  }
  __privateSet(this, _cleanupFns, []);
};
handleOpenAutoFocus_fn = function() {
  if (!__privateGet(this, _container)) return;
  const event = new CustomEvent("focusScope.onOpenAutoFocus", { bubbles: false, cancelable: true });
  __privateGet(this, _opts6).onOpenAutoFocus.current(event);
  if (!event.defaultPrevented) {
    requestAnimationFrame(() => {
      if (!__privateGet(this, _container)) return;
      const firstTabbable = __privateMethod(this, _FocusScope_instances, getFirstTabbable_fn).call(this);
      if (firstTabbable) {
        firstTabbable.focus();
        __privateGet(this, _manager).setFocusMemory(this, firstTabbable);
      } else {
        __privateGet(this, _container).focus();
      }
    });
  }
};
handleCloseAutoFocus_fn = function() {
  var _a, _b;
  const event = new CustomEvent("focusScope.onCloseAutoFocus", { bubbles: false, cancelable: true });
  (_b = (_a = __privateGet(this, _opts6).onCloseAutoFocus).current) == null ? void 0 : _b.call(_a, event);
  if (!event.defaultPrevented) {
    const preFocusedElement = __privateGet(this, _manager).getPreFocusMemory(this);
    if (preFocusedElement && document.contains(preFocusedElement)) {
      try {
        preFocusedElement.focus();
      } catch {
        document.body.focus();
      }
    }
  }
};
setupEventListeners_fn = function() {
  if (!__privateGet(this, _container) || !__privateGet(this, _opts6).trap.current) return;
  const container = __privateGet(this, _container);
  const doc = container.ownerDocument;
  const handleFocus = (e) => {
    if (__privateGet(this, _paused) || !__privateGet(this, _manager).isActiveScope(this)) return;
    const target = e.target;
    if (!target) return;
    const isInside = container.contains(target);
    if (isInside) {
      __privateGet(this, _manager).setFocusMemory(this, target);
    } else {
      const lastFocused = __privateGet(this, _manager).getFocusMemory(this);
      if (lastFocused && container.contains(lastFocused) && isFocusable(lastFocused)) {
        e.preventDefault();
        lastFocused.focus();
      } else {
        const firstTabbable = __privateMethod(this, _FocusScope_instances, getFirstTabbable_fn).call(this);
        const firstFocusable = __privateMethod(this, _FocusScope_instances, getAllFocusables_fn).call(this)[0];
        (firstTabbable || firstFocusable || container).focus();
      }
    }
  };
  const handleKeydown = (e) => {
    if (!__privateGet(this, _opts6).loop || __privateGet(this, _paused) || e.key !== "Tab") return;
    if (!__privateGet(this, _manager).isActiveScope(this)) return;
    const tabbables = __privateMethod(this, _FocusScope_instances, getTabbables_fn).call(this);
    if (tabbables.length < 2) return;
    const first = tabbables[0];
    const last = tabbables[tabbables.length - 1];
    if (!e.shiftKey && doc.activeElement === last) {
      e.preventDefault();
      first.focus();
    } else if (e.shiftKey && doc.activeElement === first) {
      e.preventDefault();
      last.focus();
    }
  };
  __privateGet(this, _cleanupFns).push(on(doc, "focusin", handleFocus, { capture: true }), on(container, "keydown", handleKeydown));
  const observer = new MutationObserver(() => {
    const lastFocused = __privateGet(this, _manager).getFocusMemory(this);
    if (lastFocused && !container.contains(lastFocused)) {
      const firstTabbable = __privateMethod(this, _FocusScope_instances, getFirstTabbable_fn).call(this);
      const firstFocusable = __privateMethod(this, _FocusScope_instances, getAllFocusables_fn).call(this)[0];
      const elementToFocus = firstTabbable || firstFocusable;
      if (elementToFocus) {
        elementToFocus.focus();
        __privateGet(this, _manager).setFocusMemory(this, elementToFocus);
      } else {
        container.focus();
      }
    }
  });
  observer.observe(container, { childList: true, subtree: true });
  __privateGet(this, _cleanupFns).push(() => observer.disconnect());
};
getTabbables_fn = function() {
  if (!__privateGet(this, _container)) return [];
  return tabbable(__privateGet(this, _container), { includeContainer: false, getShadowRoot: true });
};
getFirstTabbable_fn = function() {
  const tabbables = __privateMethod(this, _FocusScope_instances, getTabbables_fn).call(this);
  return tabbables[0] || null;
};
getAllFocusables_fn = function() {
  if (!__privateGet(this, _container)) return [];
  return focusable(__privateGet(this, _container), { includeContainer: false, getShadowRoot: true });
};
var FocusScope = _FocusScope;

// node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte
function Focus_scope($$anchor, $$props) {
  push($$props, true);
  let enabled = prop($$props, "enabled", 3, false), trapFocus = prop($$props, "trapFocus", 3, false), loop = prop($$props, "loop", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3);
  const focusScopeState = FocusScope.use({
    enabled: boxWith(() => enabled()),
    trap: boxWith(() => trapFocus()),
    loop: loop(),
    onCloseAutoFocus: boxWith(() => onCloseAutoFocus()),
    onOpenAutoFocus: boxWith(() => onOpenAutoFocus()),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.focusScope ?? noop, () => ({ props: focusScopeState.props }));
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/text-selection-layer/use-text-selection-layer.svelte.js
globalThis.bitsTextSelectionLayers ?? (globalThis.bitsTextSelectionLayers = /* @__PURE__ */ new Map());
var _unsubSelectionLock, _TextSelectionLayerState_instances, addEventListeners_fn2, _pointerdown, _resetSelectionLock;
var _TextSelectionLayerState = class _TextSelectionLayerState {
  constructor(opts) {
    __privateAdd(this, _TextSelectionLayerState_instances);
    __publicField(this, "opts");
    __publicField(this, "domContext");
    __privateAdd(this, _unsubSelectionLock, noop3);
    __privateAdd(this, _pointerdown, (e) => {
      const node = this.opts.ref.current;
      const target = e.target;
      if (!isHTMLElement2(node) || !isHTMLElement2(target) || !this.opts.enabled.current) return;
      if (!isHighestLayer(this) || !contains(node, target)) return;
      this.opts.onPointerDown.current(e);
      if (e.defaultPrevented) return;
      __privateSet(this, _unsubSelectionLock, preventTextSelectionOverflow(node, this.domContext.getDocument().body));
    });
    __privateAdd(this, _resetSelectionLock, () => {
      __privateGet(this, _unsubSelectionLock).call(this);
      __privateSet(this, _unsubSelectionLock, noop3);
    });
    this.opts = opts;
    this.domContext = new DOMContext(opts.ref);
    let unsubEvents = noop3;
    watch(() => this.opts.enabled.current, (isEnabled) => {
      if (isEnabled) {
        globalThis.bitsTextSelectionLayers.set(this, this.opts.enabled);
        unsubEvents();
        unsubEvents = __privateMethod(this, _TextSelectionLayerState_instances, addEventListeners_fn2).call(this);
      }
      return () => {
        unsubEvents();
        __privateGet(this, _resetSelectionLock).call(this);
        globalThis.bitsTextSelectionLayers.delete(this);
      };
    });
  }
  static create(opts) {
    return new _TextSelectionLayerState(opts);
  }
};
_unsubSelectionLock = new WeakMap();
_TextSelectionLayerState_instances = new WeakSet();
addEventListeners_fn2 = function() {
  return executeCallbacks(on(this.domContext.getDocument(), "pointerdown", __privateGet(this, _pointerdown)), on(this.domContext.getDocument(), "pointerup", composeHandlers(__privateGet(this, _resetSelectionLock), this.opts.onPointerUp.current)));
};
_pointerdown = new WeakMap();
_resetSelectionLock = new WeakMap();
var TextSelectionLayerState = _TextSelectionLayerState;
var getUserSelect = (node) => node.style.userSelect || node.style.webkitUserSelect;
function preventTextSelectionOverflow(node, body) {
  const originalBodyUserSelect = getUserSelect(body);
  const originalNodeUserSelect = getUserSelect(node);
  setUserSelect(body, "none");
  setUserSelect(node, "text");
  return () => {
    setUserSelect(body, originalBodyUserSelect);
    setUserSelect(node, originalNodeUserSelect);
  };
}
function setUserSelect(node, value) {
  node.style.userSelect = value;
  node.style.webkitUserSelect = value;
}
function isHighestLayer(instance) {
  const layersArr = [...globalThis.bitsTextSelectionLayers];
  if (!layersArr.length) return false;
  const highestLayer = layersArr.at(-1);
  if (!highestLayer) return false;
  return highestLayer[0] === instance;
}

// node_modules/bits-ui/dist/bits/utilities/text-selection-layer/text-selection-layer.svelte
function Text_selection_layer($$anchor, $$props) {
  push($$props, true);
  let preventOverflowTextSelection = prop($$props, "preventOverflowTextSelection", 3, true), onPointerDown = prop($$props, "onPointerDown", 3, noop3), onPointerUp = prop($$props, "onPointerUp", 3, noop3);
  TextSelectionLayerState.create({
    id: boxWith(() => $$props.id),
    onPointerDown: boxWith(() => onPointerDown()),
    onPointerUp: boxWith(() => onPointerUp()),
    enabled: boxWith(() => $$props.enabled && preventOverflowTextSelection()),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/internal/use-id.js
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = { current: 0 });
function useId(prefix = "bits") {
  globalThis.bitsIdCounter.current++;
  return `${prefix}-${globalThis.bitsIdCounter.current}`;
}

// node_modules/bits-ui/dist/internal/shared-state.svelte.js
var _factory, _subscribers, _state, _scope, _SharedState_instances, dispose_fn;
var SharedState = class {
  constructor(factory) {
    __privateAdd(this, _SharedState_instances);
    __privateAdd(this, _factory);
    __privateAdd(this, _subscribers, 0);
    __privateAdd(this, _state, state());
    __privateAdd(this, _scope);
    __privateSet(this, _factory, factory);
  }
  get(...args) {
    __privateSet(this, _subscribers, __privateGet(this, _subscribers) + 1);
    if (get(__privateGet(this, _state)) === void 0) {
      __privateSet(this, _scope, effect_root(() => {
        set(__privateGet(this, _state), __privateGet(this, _factory).call(this, ...args), true);
      }));
    }
    user_effect(() => {
      return () => {
        __privateMethod(this, _SharedState_instances, dispose_fn).call(this);
      };
    });
    return get(__privateGet(this, _state));
  }
};
_factory = new WeakMap();
_subscribers = new WeakMap();
_state = new WeakMap();
_scope = new WeakMap();
_SharedState_instances = new WeakSet();
dispose_fn = function() {
  __privateSet(this, _subscribers, __privateGet(this, _subscribers) - 1);
  if (__privateGet(this, _scope) && __privateGet(this, _subscribers) <= 0) {
    __privateGet(this, _scope).call(this);
    set(__privateGet(this, _state), void 0);
    __privateSet(this, _scope, void 0);
  }
};

// node_modules/bits-ui/dist/internal/body-scroll-lock.svelte.js
var lockMap = new SvelteMap();
var initialBodyStyle = state(null);
var stopTouchMoveListener = null;
var cleanupTimeoutId = null;
var isInCleanupTransition = false;
var anyLocked = boxWith(() => {
  for (const value of lockMap.values()) {
    if (value) return true;
  }
  return false;
});
var cleanupScheduledAt = null;
var bodyLockStackCount = new SharedState(() => {
  function resetBodyStyle() {
    if (!true_default) return;
    document.body.setAttribute("style", get(initialBodyStyle) ?? "");
    document.body.style.removeProperty("--scrollbar-width");
    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());
    set(initialBodyStyle, null);
  }
  function cancelPendingCleanup() {
    if (cleanupTimeoutId === null) return;
    window.clearTimeout(cleanupTimeoutId);
    cleanupTimeoutId = null;
  }
  function scheduleCleanupIfNoNewLocks(delay, callback) {
    cancelPendingCleanup();
    isInCleanupTransition = true;
    cleanupScheduledAt = Date.now();
    const currentCleanupId = cleanupScheduledAt;
    const cleanupFn = () => {
      cleanupTimeoutId = null;
      if (cleanupScheduledAt !== currentCleanupId) return;
      if (!isAnyLocked(lockMap)) {
        isInCleanupTransition = false;
        callback();
      } else {
        isInCleanupTransition = false;
      }
    };
    const actualDelay = delay === null ? 24 : delay;
    cleanupTimeoutId = window.setTimeout(cleanupFn, actualDelay);
  }
  function ensureInitialStyleCaptured() {
    if (get(initialBodyStyle) === null && lockMap.size === 0 && !isInCleanupTransition) {
      set(initialBodyStyle, document.body.getAttribute("style"), true);
    }
  }
  watch(() => anyLocked.current, () => {
    if (!anyLocked.current) return;
    ensureInitialStyleCaptured();
    isInCleanupTransition = false;
    const bodyStyle = getComputedStyle(document.body);
    const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    const paddingRight = Number.parseInt(bodyStyle.paddingRight ?? "0", 10);
    const config = {
      padding: paddingRight + verticalScrollbarWidth,
      margin: Number.parseInt(bodyStyle.marginRight ?? "0", 10)
    };
    if (verticalScrollbarWidth > 0) {
      document.body.style.paddingRight = `${config.padding}px`;
      document.body.style.marginRight = `${config.margin}px`;
      document.body.style.setProperty("--scrollbar-width", `${verticalScrollbarWidth}px`);
      document.body.style.overflow = "hidden";
    }
    if (isIOS) {
      stopTouchMoveListener = on(
        document,
        "touchmove",
        (e) => {
          if (e.target !== document.documentElement) return;
          if (e.touches.length > 1) return;
          e.preventDefault();
        },
        { passive: false }
      );
    }
    afterTick(() => {
      document.body.style.pointerEvents = "none";
      document.body.style.overflow = "hidden";
    });
  });
  onDestroyEffect(() => {
    return () => {
      stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();
    };
  });
  return {
    get lockMap() {
      return lockMap;
    },
    resetBodyStyle,
    scheduleCleanupIfNoNewLocks,
    cancelPendingCleanup,
    ensureInitialStyleCaptured
  };
});
var _id, _initialState, _restoreScrollDelay, _countState;
var BodyScrollLock = class {
  constructor(initialState, restoreScrollDelay = () => null) {
    __privateAdd(this, _id, useId());
    __privateAdd(this, _initialState);
    __privateAdd(this, _restoreScrollDelay, () => null);
    __privateAdd(this, _countState);
    __publicField(this, "locked");
    __privateSet(this, _initialState, initialState);
    __privateSet(this, _restoreScrollDelay, restoreScrollDelay);
    __privateSet(this, _countState, bodyLockStackCount.get());
    if (!__privateGet(this, _countState)) return;
    __privateGet(this, _countState).cancelPendingCleanup();
    __privateGet(this, _countState).ensureInitialStyleCaptured();
    __privateGet(this, _countState).lockMap.set(__privateGet(this, _id), __privateGet(this, _initialState) ?? false);
    this.locked = boxWith(() => __privateGet(this, _countState).lockMap.get(__privateGet(this, _id)) ?? false, (v) => __privateGet(this, _countState).lockMap.set(__privateGet(this, _id), v));
    onDestroyEffect(() => {
      __privateGet(this, _countState).lockMap.delete(__privateGet(this, _id));
      if (isAnyLocked(__privateGet(this, _countState).lockMap)) return;
      const restoreScrollDelay2 = __privateGet(this, _restoreScrollDelay).call(this);
      __privateGet(this, _countState).scheduleCleanupIfNoNewLocks(restoreScrollDelay2, () => {
        __privateGet(this, _countState).resetBodyStyle();
      });
    });
  }
};
_id = new WeakMap();
_initialState = new WeakMap();
_restoreScrollDelay = new WeakMap();
_countState = new WeakMap();
function isAnyLocked(map) {
  for (const [_, value] of map) {
    if (value) return true;
  }
  return false;
}

// node_modules/bits-ui/dist/bits/utilities/scroll-lock/scroll-lock.svelte
function Scroll_lock($$anchor, $$props) {
  push($$props, true);
  let preventScroll = prop($$props, "preventScroll", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null);
  if (preventScroll()) {
    new BodyScrollLock(preventScroll(), () => restoreScrollDelay());
  }
  pop();
}

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-content.svelte
var root_6 = from_html(`<!> <!>`, 1);
var root_8 = from_html(`<!> <div><!></div>`, 1);
function Alert_dialog_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "ignore"), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, true), trapFocus = prop($$props, "trapFocus", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "children",
    "child",
    "ref",
    "forceMount",
    "interactOutsideBehavior",
    "onCloseAutoFocus",
    "onEscapeKeydown",
    "onOpenAutoFocus",
    "onInteractOutside",
    "preventScroll",
    "trapFocus",
    "restoreScrollDelay"
  ]);
  const contentState = DialogContentState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_2 = ($$anchor2) => {
      {
        const focusScope = ($$anchor3, $$arg0) => {
          let focusScopeProps = () => $$arg0 == null ? void 0 : $$arg0().props;
          Escape_layer($$anchor3, spread_props(() => get(mergedProps), {
            get enabled() {
              return contentState.root.opts.open.current;
            },
            get ref() {
              return contentState.opts.ref;
            },
            onEscapeKeydown: (e) => {
              onEscapeKeydown()(e);
              if (e.defaultPrevented) return;
              contentState.root.handleClose();
            },
            children: ($$anchor4, $$slotProps) => {
              Dismissible_layer($$anchor4, spread_props(() => get(mergedProps), {
                get ref() {
                  return contentState.opts.ref;
                },
                get enabled() {
                  return contentState.root.opts.open.current;
                },
                get interactOutsideBehavior() {
                  return interactOutsideBehavior();
                },
                onInteractOutside: (e) => {
                  onInteractOutside()(e);
                  if (e.defaultPrevented) return;
                  contentState.root.handleClose();
                },
                children: ($$anchor5, $$slotProps2) => {
                  Text_selection_layer($$anchor5, spread_props(() => get(mergedProps), {
                    get ref() {
                      return contentState.opts.ref;
                    },
                    get enabled() {
                      return contentState.root.opts.open.current;
                    },
                    children: ($$anchor6, $$slotProps3) => {
                      var fragment_5 = comment();
                      var node_1 = first_child(fragment_5);
                      {
                        var consequent_1 = ($$anchor7) => {
                          var fragment_6 = root_6();
                          var node_2 = first_child(fragment_6);
                          {
                            var consequent = ($$anchor8) => {
                              Scroll_lock($$anchor8, {
                                get preventScroll() {
                                  return preventScroll();
                                },
                                get restoreScrollDelay() {
                                  return restoreScrollDelay();
                                }
                              });
                            };
                            if_block(node_2, ($$render) => {
                              if (contentState.root.opts.open.current) $$render(consequent);
                            });
                          }
                          var node_3 = sibling(node_2, 2);
                          var render_arg = derived_safe_equal(() => ({
                            props: mergeProps(get(mergedProps), focusScopeProps()),
                            ...contentState.snippetProps
                          }));
                          snippet(node_3, () => $$props.child, () => get(render_arg));
                          append($$anchor7, fragment_6);
                        };
                        var alternate = ($$anchor7) => {
                          var fragment_8 = root_8();
                          var node_4 = first_child(fragment_8);
                          Scroll_lock(node_4, {
                            get preventScroll() {
                              return preventScroll();
                            }
                          });
                          var div = sibling(node_4, 2);
                          attribute_effect(div, ($0) => ({ ...$0 }), [
                            () => mergeProps(get(mergedProps), focusScopeProps())
                          ]);
                          var node_5 = child(div);
                          snippet(node_5, () => $$props.children ?? noop);
                          reset(div);
                          append($$anchor7, fragment_8);
                        };
                        if_block(node_1, ($$render) => {
                          if ($$props.child) $$render(consequent_1);
                          else $$render(alternate, false);
                        });
                      }
                      append($$anchor6, fragment_5);
                    },
                    $$slots: { default: true }
                  }));
                },
                $$slots: { default: true }
              }));
            },
            $$slots: { default: true }
          }));
        };
        Focus_scope($$anchor2, {
          get ref() {
            return contentState.opts.ref;
          },
          loop: true,
          get trapFocus() {
            return trapFocus();
          },
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get onCloseAutoFocus() {
            return onCloseAutoFocus();
          },
          onOpenAutoFocus: (e) => {
            onOpenAutoFocus()(e);
            if (e.defaultPrevented) return;
            e.preventDefault();
            afterSleep(0, () => {
              var _a;
              return (_a = contentState.opts.ref.current) == null ? void 0 : _a.focus();
            });
          },
          focusScope,
          $$slots: { focusScope: true }
        });
      }
    };
    if_block(node, ($$render) => {
      if (contentState.shouldRender || forceMount()) $$render(consequent_2);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/dialog/components/dialog-overlay.svelte
var root_3 = from_html(`<div><!></div>`);
function Dialog_overlay($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "forceMount",
    "child",
    "children",
    "ref"
  ]);
  const overlayState = DialogOverlayState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, overlayState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          var render_arg = derived_safe_equal(() => ({
            props: mergeProps(get(mergedProps)),
            ...overlayState.snippetProps
          }));
          snippet(node_2, () => $$props.child, () => get(render_arg));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_3();
          attribute_effect(div, ($0) => ({ ...$0 }), [() => mergeProps(get(mergedProps))]);
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop, () => overlayState.snippetProps);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (overlayState.shouldRender || forceMount()) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/dialog/components/dialog-trigger.svelte
var root_29 = from_html(`<button><!></button>`);
function Dialog_trigger($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child",
    "disabled"
  ]);
  const triggerState = DialogTriggerState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    disabled: boxWith(() => Boolean(disabled()))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_29();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/dialog/components/dialog-description.svelte
var root_210 = from_html(`<div><!></div>`);
function Dialog_description($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "children",
    "child",
    "ref"
  ]);
  const descriptionState = DialogDescriptionState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, descriptionState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_210();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/aspect-ratio/exports.js
var exports_exports3 = {};
__export(exports_exports3, {
  Root: () => Aspect_ratio
});

// node_modules/bits-ui/dist/bits/aspect-ratio/aspect-ratio.svelte.js
var aspectRatioAttrs = createBitsAttrs({
  component: "aspect-ratio",
  parts: ["root"]
});
var _props28;
var _AspectRatioRootState = class _AspectRatioRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props28, user_derived(() => ({
      id: this.opts.id.current,
      style: {
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      },
      [aspectRatioAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _AspectRatioRootState(opts);
  }
  get props() {
    return get(__privateGet(this, _props28));
  }
  set props(value) {
    set(__privateGet(this, _props28), value);
  }
};
_props28 = new WeakMap();
var AspectRatioRootState = _AspectRatioRootState;

// node_modules/bits-ui/dist/bits/aspect-ratio/components/aspect-ratio.svelte
var root_211 = from_html(`<div><!></div>`);
var root = from_html(`<div><!></div>`);
function Aspect_ratio($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), ratio = prop($$props, "ratio", 3, 1), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "ratio",
    "children",
    "child"
  ]);
  const rootState = AspectRatioRootState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    ratio: boxWith(() => ratio())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var div = root();
  let styles;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var div_1 = root_211();
      attribute_effect(div_1, () => ({ ...get(mergedProps) }));
      var node_2 = child(div_1);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div_1);
      append($$anchor2, div_1);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  reset(div);
  template_effect(() => styles = set_style(div, "", styles, {
    position: "relative",
    width: "100%",
    "padding-bottom": `${ratio() ? 100 / ratio() : 0}%`
  }));
  append($$anchor, div);
  pop();
}

// node_modules/bits-ui/dist/bits/avatar/exports.js
var exports_exports4 = {};
__export(exports_exports4, {
  Fallback: () => Avatar_fallback,
  Image: () => Avatar_image,
  Root: () => Avatar
});

// node_modules/bits-ui/dist/bits/avatar/avatar.svelte.js
var avatarAttrs = createBitsAttrs({
  component: "avatar",
  parts: ["root", "image", "fallback"]
});
var AvatarRootContext = new Context("Avatar.Root");
var _props29;
var _AvatarRootState = class _AvatarRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "domContext");
    __publicField(this, "attachment");
    __privateAdd(this, _props29, user_derived(() => ({
      id: this.opts.id.current,
      [avatarAttrs.root]: "",
      "data-status": this.opts.loadingStatus.current,
      ...this.attachment
    })));
    this.opts = opts;
    this.domContext = new DOMContext(this.opts.ref);
    this.loadImage = this.loadImage.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return AvatarRootContext.set(new _AvatarRootState(opts));
  }
  loadImage(src, crossorigin, referrerPolicy) {
    if (this.opts.loadingStatus.current === "loaded") return;
    let imageTimerId;
    const image = new Image();
    image.src = src;
    if (crossorigin !== void 0) image.crossOrigin = crossorigin;
    if (referrerPolicy) image.referrerPolicy = referrerPolicy;
    this.opts.loadingStatus.current = "loading";
    image.onload = () => {
      imageTimerId = this.domContext.setTimeout(
        () => {
          this.opts.loadingStatus.current = "loaded";
        },
        this.opts.delayMs.current
      );
    };
    image.onerror = () => {
      this.opts.loadingStatus.current = "error";
    };
    return () => {
      if (!imageTimerId) return;
      this.domContext.clearTimeout(imageTimerId);
    };
  }
  get props() {
    return get(__privateGet(this, _props29));
  }
  set props(value) {
    set(__privateGet(this, _props29), value);
  }
};
_props29 = new WeakMap();
var AvatarRootState = _AvatarRootState;
var _props30;
var _AvatarImageState = class _AvatarImageState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props30, user_derived(() => ({
      id: this.opts.id.current,
      style: {
        display: this.root.opts.loadingStatus.current === "loaded" ? "block" : "none"
      },
      "data-status": this.root.opts.loadingStatus.current,
      [avatarAttrs.image]: "",
      src: this.opts.src.current,
      crossorigin: this.opts.crossOrigin.current,
      referrerpolicy: this.opts.referrerPolicy.current,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    watch.pre(
      [
        () => this.opts.src.current,
        () => this.opts.crossOrigin.current
      ],
      ([src, crossOrigin]) => {
        if (!src) {
          this.root.opts.loadingStatus.current = "error";
          return;
        }
        this.root.loadImage(src, crossOrigin, this.opts.referrerPolicy.current);
      }
    );
  }
  static create(opts) {
    return new _AvatarImageState(opts, AvatarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props30));
  }
  set props(value) {
    set(__privateGet(this, _props30), value);
  }
};
_props30 = new WeakMap();
var AvatarImageState = _AvatarImageState;
var _style, _props31;
var _AvatarFallbackState = class _AvatarFallbackState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _style, user_derived(() => this.root.opts.loadingStatus.current === "loaded" ? { display: "none" } : void 0));
    __privateAdd(this, _props31, user_derived(() => ({
      style: this.style,
      "data-status": this.root.opts.loadingStatus.current,
      [avatarAttrs.fallback]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _AvatarFallbackState(opts, AvatarRootContext.get());
  }
  get style() {
    return get(__privateGet(this, _style));
  }
  set style(value) {
    set(__privateGet(this, _style), value);
  }
  get props() {
    return get(__privateGet(this, _props31));
  }
  set props(value) {
    set(__privateGet(this, _props31), value);
  }
};
_style = new WeakMap();
_props31 = new WeakMap();
var AvatarFallbackState = _AvatarFallbackState;

// node_modules/bits-ui/dist/bits/avatar/components/avatar.svelte
var root_212 = from_html(`<div><!></div>`);
function Avatar($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let delayMs = prop($$props, "delayMs", 3, 0), loadingStatus = prop($$props, "loadingStatus", 15, "loading"), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "delayMs",
    "loadingStatus",
    "onLoadingStatusChange",
    "child",
    "children",
    "id",
    "ref"
  ]);
  const rootState = AvatarRootState.create({
    delayMs: boxWith(() => delayMs()),
    loadingStatus: boxWith(() => loadingStatus(), (v) => {
      var _a;
      if (loadingStatus() !== v) {
        loadingStatus(v);
        (_a = $$props.onLoadingStatusChange) == null ? void 0 : _a.call($$props, v);
      }
    }),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_212();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/avatar/components/avatar-image.svelte
var root_213 = from_html(`<img/>`);
function Avatar_image($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), crossorigin = prop($$props, "crossorigin", 3, void 0), referrerpolicy = prop($$props, "referrerpolicy", 3, void 0), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "src",
    "child",
    "id",
    "ref",
    "crossorigin",
    "referrerpolicy"
  ]);
  const imageState = AvatarImageState.create({
    src: boxWith(() => $$props.src),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    crossOrigin: boxWith(() => crossorigin()),
    referrerPolicy: boxWith(() => referrerpolicy())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, imageState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var img = root_213();
      attribute_effect(img, () => ({ ...get(mergedProps), src: $$props.src }));
      replay_events(img);
      append($$anchor2, img);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/avatar/components/avatar-fallback.svelte
var root_214 = from_html(`<span><!></span>`);
function Avatar_fallback($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref"
  ]);
  const fallbackState = AvatarFallbackState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, fallbackState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_214();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/config/components/bits-config.svelte
function Bits_config($$anchor, $$props) {
  push($$props, true);
  useBitsConfig({
    defaultPortalTo: boxWith(() => $$props.defaultPortalTo),
    defaultLocale: boxWith(() => $$props.defaultLocale)
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/button/exports.js
var exports_exports5 = {};
__export(exports_exports5, {
  Root: () => Button
});

// node_modules/bits-ui/dist/bits/button/components/button.svelte
function Button($$anchor, $$props) {
  push($$props, true);
  let disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "href",
    "type",
    "children",
    "disabled",
    "ref"
  ]);
  var fragment = comment();
  var node = first_child(fragment);
  element(node, () => $$props.href ? "a" : "button", false, ($$element, $$anchor2) => {
    bind_this($$element, ($$value) => ref($$value), () => ref());
    attribute_effect($$element, () => ({
      "data-button-root": true,
      type: $$props.href ? void 0 : $$props.type,
      href: $$props.href && !disabled() ? $$props.href : void 0,
      disabled: $$props.href ? void 0 : disabled(),
      "aria-disabled": $$props.href ? disabled() : void 0,
      role: $$props.href && disabled() ? "link" : void 0,
      tabindex: $$props.href && disabled() ? -1 : 0,
      ...restProps
    }));
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    snippet(node_1, () => $$props.children ?? noop);
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/exports.js
var exports_exports6 = {};
__export(exports_exports6, {
  Cell: () => Calendar_cell,
  Day: () => Calendar_day,
  Grid: () => Calendar_grid,
  GridBody: () => Calendar_grid_body,
  GridHead: () => Calendar_grid_head,
  GridRow: () => Calendar_grid_row,
  HeadCell: () => Calendar_head_cell,
  Header: () => Calendar_header,
  Heading: () => Calendar_heading,
  MonthSelect: () => Calendar_month_select,
  NextButton: () => Calendar_next_button,
  PrevButton: () => Calendar_prev_button,
  Root: () => Calendar,
  YearSelect: () => Calendar_year_select
});

// node_modules/bits-ui/dist/internal/date-time/announcer.js
function initAnnouncer(doc) {
  if (!isBrowser || !doc)
    return null;
  let el = doc.querySelector("[data-bits-announcer]");
  const createLog = (kind) => {
    const log = doc.createElement("div");
    log.role = "log";
    log.ariaLive = kind;
    log.setAttribute("aria-relevant", "additions");
    return log;
  };
  if (!isHTMLElement2(el)) {
    const div = doc.createElement("div");
    div.style.cssText = srOnlyStylesString;
    div.setAttribute("data-bits-announcer", "");
    div.appendChild(createLog("assertive"));
    div.appendChild(createLog("polite"));
    el = div;
    doc.body.insertBefore(el, doc.body.firstChild);
  }
  const getLog = (kind) => {
    if (!isHTMLElement2(el))
      return null;
    const log = el.querySelector(`[aria-live="${kind}"]`);
    if (!isHTMLElement2(log))
      return null;
    return log;
  };
  return {
    getLog
  };
}
function getAnnouncer(doc) {
  const announcer = initAnnouncer(doc);
  function announce(value, kind = "assertive", timeout = 7500) {
    if (!announcer || !isBrowser || !doc)
      return;
    const log = announcer.getLog(kind);
    const content = doc.createElement("div");
    if (typeof value === "number") {
      value = value.toString();
    } else if (value === null) {
      value = "Empty";
    } else {
      value = value.trim();
    }
    content.innerText = value;
    if (kind === "assertive") {
      log == null ? void 0 : log.replaceChildren(content);
    } else {
      log == null ? void 0 : log.appendChild(content);
    }
    return setTimeout(() => {
      content.remove();
    }, timeout);
  }
  return {
    announce
  };
}

// node_modules/bits-ui/dist/internal/date-time/utils.js
var defaultDateDefaults = {
  defaultValue: void 0,
  granularity: "day"
};
var defaultTimeDefaults = {
  defaultValue: void 0,
  granularity: "minute"
};
function getDefaultDate(opts) {
  const withDefaults = { ...defaultDateDefaults, ...opts };
  const { defaultValue, granularity } = withDefaults;
  if (Array.isArray(defaultValue) && defaultValue.length) {
    return defaultValue[defaultValue.length - 1];
  }
  if (defaultValue && !Array.isArray(defaultValue)) {
    return defaultValue;
  } else {
    const date = /* @__PURE__ */ new Date();
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const calendarDateTimeGranularities = ["hour", "minute", "second"];
    if (calendarDateTimeGranularities.includes(granularity ?? "day")) {
      return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(year, month, day, 0, 0, 0);
    }
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(year, month, day);
  }
}
function getDefaultTime(opts) {
  const withDefaults = { ...defaultTimeDefaults, ...opts };
  const { defaultValue } = withDefaults;
  if (defaultValue) {
    return defaultValue;
  } else {
    return new $35ea8db9cb2ccb90$export$680ea196effce5f(0, 0, 0);
  }
}
function parseStringToDateValue(dateStr, referenceVal) {
  let dateValue;
  if (referenceVal instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
    dateValue = $fae977aafc393c5c$export$fd7893f06e92a6a4(dateStr);
  } else if (referenceVal instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f) {
    dateValue = $fae977aafc393c5c$export$588937bcd60ade55(dateStr);
  } else {
    dateValue = $fae977aafc393c5c$export$6b862160d295c8e(dateStr);
  }
  return dateValue.calendar !== referenceVal.calendar ? $11d87f3f76e88657$export$b4a036af3fc0b032(dateValue, referenceVal.calendar) : dateValue;
}
function toDate(dateValue, tz = $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) {
  if (dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
    return dateValue.toDate();
  } else {
    return dateValue.toDate(tz);
  }
}
function getDateValueType(date) {
  if (date instanceof $35ea8db9cb2ccb90$export$99faa760c7908e4f)
    return "date";
  if (date instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f)
    return "datetime";
  if (date instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea)
    return "zoneddatetime";
  throw new Error("Unknown date type");
}
function parseAnyDateValue(value, type) {
  switch (type) {
    case "date":
      return $fae977aafc393c5c$export$6b862160d295c8e(value);
    case "datetime":
      return $fae977aafc393c5c$export$588937bcd60ade55(value);
    case "zoneddatetime":
      return $fae977aafc393c5c$export$fd7893f06e92a6a4(value);
    default:
      throw new Error(`Unknown date type: ${type}`);
  }
}
function isCalendarDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f;
}
function isZonedDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea;
}
function hasTime(dateValue) {
  return isCalendarDateTime(dateValue) || isZonedDateTime(dateValue);
}
function getDaysInMonth(date) {
  if (date instanceof Date) {
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    return new Date(year, month, 0).getDate();
  } else {
    return date.set({ day: 100 }).day;
  }
}
function isBefore(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) < 0;
}
function isAfter(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) > 0;
}
function isBeforeOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) <= 0;
}
function isAfterOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) >= 0;
}
function isBetweenInclusive(date, start, end) {
  return isAfterOrSame(date, start) && isBeforeOrSame(date, end);
}
function getLastFirstDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  if (firstDayOfWeek > day) {
    return date.subtract({ days: day + 7 - firstDayOfWeek });
  }
  if (firstDayOfWeek === day) {
    return date;
  }
  return date.subtract({ days: day - firstDayOfWeek });
}
function getNextLastDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  const lastDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
  if (day === lastDayOfWeek) {
    return date;
  }
  if (day > lastDayOfWeek) {
    return date.add({ days: 7 - day + lastDayOfWeek });
  }
  return date.add({ days: lastDayOfWeek - day });
}
function areAllDaysBetweenValid(start, end, isUnavailable, isDisabled) {
  if (isUnavailable === void 0 && isDisabled === void 0) {
    return true;
  }
  let dCurrent = start.add({ days: 1 });
  if ((isDisabled == null ? void 0 : isDisabled(dCurrent)) || (isUnavailable == null ? void 0 : isUnavailable(dCurrent))) {
    return false;
  }
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    dCurrent = dCurrent.add({ days: 1 });
    if ((isDisabled == null ? void 0 : isDisabled(dCurrent)) || (isUnavailable == null ? void 0 : isUnavailable(dCurrent))) {
      return false;
    }
  }
  return true;
}

// node_modules/bits-ui/dist/internal/date-time/field/parts.js
var DATE_SEGMENT_PARTS = ["day", "month", "year"];
var EDITABLE_TIME_SEGMENT_PARTS = ["hour", "minute", "second", "dayPeriod"];
var NON_EDITABLE_SEGMENT_PARTS = ["literal", "timeZoneName"];
var EDITABLE_SEGMENT_PARTS = [
  ...DATE_SEGMENT_PARTS,
  ...EDITABLE_TIME_SEGMENT_PARTS
];
var ALL_SEGMENT_PARTS = [
  ...EDITABLE_SEGMENT_PARTS,
  ...NON_EDITABLE_SEGMENT_PARTS
];
var ALL_TIME_SEGMENT_PARTS = [
  ...EDITABLE_TIME_SEGMENT_PARTS,
  ...NON_EDITABLE_SEGMENT_PARTS
];
var ALL_EXCEPT_LITERAL_PARTS = ALL_SEGMENT_PARTS.filter((part) => part !== "literal");
var ALL_TIME_EXCEPT_LITERAL_PARTS = ALL_TIME_SEGMENT_PARTS.filter((part) => part !== "literal");

// node_modules/bits-ui/dist/internal/date-time/placeholders.js
var supportedLocales = [
  "ach",
  "af",
  "am",
  "an",
  "ar",
  "ast",
  "az",
  "be",
  "bg",
  "bn",
  "br",
  "bs",
  "ca",
  "cak",
  "ckb",
  "cs",
  "cy",
  "da",
  "de",
  "dsb",
  "el",
  "en",
  "eo",
  "es",
  "et",
  "eu",
  "fa",
  "ff",
  "fi",
  "fr",
  "fy",
  "ga",
  "gd",
  "gl",
  "he",
  "hr",
  "hsb",
  "hu",
  "ia",
  "id",
  "it",
  "ja",
  "ka",
  "kk",
  "kn",
  "ko",
  "lb",
  "lo",
  "lt",
  "lv",
  "meh",
  "ml",
  "ms",
  "nl",
  "nn",
  "no",
  "oc",
  "pl",
  "pt",
  "rm",
  "ro",
  "ru",
  "sc",
  "scn",
  "sk",
  "sl",
  "sr",
  "sv",
  "szl",
  "tg",
  "th",
  "tr",
  "uk",
  "zh-CN",
  "zh-TW"
];
var placeholderFields = ["year", "month", "day"];
var placeholders = {
  ach: { year: "mwaka", month: "dwe", day: "nino" },
  af: { year: "jjjj", month: "mm", day: "dd" },
  am: { year: "", month: "", day: "" },
  an: { year: "aaaa", month: "mm", day: "dd" },
  ar: { year: "", month: "", day: "" },
  ast: { year: "aaaa", month: "mm", day: "dd" },
  az: { year: "iiii", month: "aa", day: "gg" },
  be: { year: "", month: "", day: "" },
  bg: { year: "", month: "", day: "" },
  bn: { year: "yyyy", month: "", day: "dd" },
  br: { year: "bbbb", month: "mm", day: "dd" },
  bs: { year: "gggg", month: "mm", day: "dd" },
  ca: { year: "aaaa", month: "mm", day: "dd" },
  cak: { year: "jjjj", month: "ii", day: "q'q'" },
  ckb: { year: "", month: "", day: "" },
  cs: { year: "rrrr", month: "mm", day: "dd" },
  cy: { year: "bbbb", month: "mm", day: "dd" },
  da: { year: "", month: "mm", day: "dd" },
  de: { year: "jjjj", month: "mm", day: "tt" },
  dsb: { year: "llll", month: "mm", day: "" },
  el: { year: "", month: "", day: "" },
  en: { year: "yyyy", month: "mm", day: "dd" },
  eo: { year: "jjjj", month: "mm", day: "tt" },
  es: { year: "aaaa", month: "mm", day: "dd" },
  et: { year: "aaaa", month: "kk", day: "pp" },
  eu: { year: "uuuu", month: "hh", day: "ee" },
  fa: { year: "", month: "", day: "" },
  ff: { year: "hhhh", month: "ll", day: "" },
  fi: { year: "vvvv", month: "kk", day: "pp" },
  fr: { year: "aaaa", month: "mm", day: "jj" },
  fy: { year: "jjjj", month: "mm", day: "dd" },
  ga: { year: "bbbb", month: "mm", day: "ll" },
  gd: { year: "bbbb", month: "mm", day: "ll" },
  gl: { year: "aaaa", month: "mm", day: "dd" },
  he: { year: "", month: "", day: "" },
  hr: { year: "gggg", month: "mm", day: "dd" },
  hsb: { year: "llll", month: "mm", day: "dd" },
  hu: { year: "", month: "hh", day: "nn" },
  ia: { year: "aaaa", month: "mm", day: "dd" },
  id: { year: "tttt", month: "bb", day: "hh" },
  it: { year: "aaaa", month: "mm", day: "gg" },
  ja: { year: "  ", month: "", day: "" },
  ka: { year: "", month: "", day: "" },
  kk: { year: "", month: "", day: "" },
  kn: { year: "", month: "", day: "" },
  ko: { year: "", month: "", day: "" },
  lb: { year: "jjjj", month: "mm", day: "dd" },
  lo: { year: "", month: "", day: "" },
  lt: { year: "mmmm", month: "mm", day: "dd" },
  lv: { year: "gggg", month: "mm", day: "dd" },
  meh: { year: "aaaa", month: "mm", day: "dd" },
  ml: { year: "", month: "", day: "" },
  ms: { year: "tttt", month: "mm", day: "hh" },
  nl: { year: "jjjj", month: "mm", day: "dd" },
  nn: { year: "", month: "mm", day: "dd" },
  no: { year: "", month: "mm", day: "dd" },
  oc: { year: "aaaa", month: "mm", day: "jj" },
  pl: { year: "rrrr", month: "mm", day: "dd" },
  pt: { year: "aaaa", month: "mm", day: "dd" },
  rm: { year: "oooo", month: "mm", day: "dd" },
  ro: { year: "aaaa", month: "ll", day: "zz" },
  ru: { year: "", month: "", day: "" },
  sc: { year: "aaaa", month: "mm", day: "dd" },
  scn: { year: "aaaa", month: "mm", day: "jj" },
  sk: { year: "rrrr", month: "mm", day: "dd" },
  sl: { year: "llll", month: "mm", day: "dd" },
  sr: { year: "", month: "", day: "" },
  sv: { year: "", month: "mm", day: "dd" },
  szl: { year: "rrrr", month: "mm", day: "dd" },
  tg: { year: "", month: "", day: "" },
  th: { year: "", month: "", day: "" },
  tr: { year: "yyyy", month: "aa", day: "gg" },
  uk: { year: "", month: "", day: "" },
  "zh-CN": { year: "", month: "", day: "" },
  "zh-TW": { year: "", month: "", day: "" }
};
function getPlaceholderObj(locale) {
  if (!isSupportedLocale(locale)) {
    const localeLanguage = getLocaleLanguage(locale);
    if (!isSupportedLocale(localeLanguage)) {
      return placeholders.en;
    } else {
      return placeholders[localeLanguage];
    }
  } else {
    return placeholders[locale];
  }
}
function getPlaceholder(field, value, locale) {
  if (isPlaceholderField(field))
    return getPlaceholderObj(locale)[field];
  if (isDefaultField(field))
    return value;
  if (isTimeField(field))
    return "";
  return "";
}
function isSupportedLocale(locale) {
  return supportedLocales.includes(locale);
}
function isPlaceholderField(field) {
  return placeholderFields.includes(field);
}
function isTimeField(field) {
  return field === "hour" || field === "minute" || field === "second";
}
function isDefaultField(field) {
  return field === "era" || field === "dayPeriod";
}
function getLocaleLanguage(locale) {
  if (Intl.Locale) {
    return new Intl.Locale(locale).language;
  }
  return locale.split("-")[0];
}

// node_modules/bits-ui/dist/internal/date-time/field/helpers.js
function initializeSegmentValues(granularity) {
  const calendarDateTimeGranularities = ["hour", "minute", "second"];
  const initialParts = EDITABLE_SEGMENT_PARTS.map((part) => {
    if (part === "dayPeriod") {
      return [part, "AM"];
    }
    return [part, null];
  }).filter(([key]) => {
    if (key === "literal" || key === null)
      return false;
    if (granularity === "day") {
      return !calendarDateTimeGranularities.includes(key);
    } else {
      return true;
    }
  });
  return Object.fromEntries(initialParts);
}
function createContentObj(props) {
  const { segmentValues, formatter, locale, dateRef } = props;
  const content = Object.keys(segmentValues).reduce((obj, part) => {
    if (!isSegmentPart(part))
      return obj;
    if ("hour" in segmentValues && part === "dayPeriod") {
      const value = segmentValues[part];
      if (!isNull(value)) {
        obj[part] = value;
      } else {
        obj[part] = getPlaceholder(part, "AM", locale);
      }
    } else {
      obj[part] = getPartContent(part);
    }
    return obj;
  }, {});
  function getPartContent(part) {
    if ("hour" in segmentValues) {
      const value = segmentValues[part];
      const leadingZero = typeof value === "string" && (value == null ? void 0 : value.startsWith("0"));
      const intValue = value !== null ? Number.parseInt(value) : null;
      if (value === "0" && part !== "year") {
        return "0";
      } else if (!isNull(value) && !isNull(intValue)) {
        const formatted = formatter.part(dateRef.set({ [part]: value }), part, {
          hourCycle: props.hourCycle === 24 ? "h23" : void 0
        });
        const is12HourMode = props.hourCycle === 12 || props.hourCycle === void 0 && getDefaultHourCycle(locale) === 12;
        if (part === "hour" && is12HourMode) {
          if (intValue > 12) {
            const hour = intValue - 12;
            if (hour === 0) {
              return "12";
            } else if (hour < 10) {
              return `0${hour}`;
            } else {
              return `${hour}`;
            }
          }
          if (intValue === 0) {
            return "12";
          }
          if (intValue < 10) {
            return `0${intValue}`;
          }
          return `${intValue}`;
        }
        if (part === "year") {
          return `${value}`;
        }
        if (leadingZero && formatted.length === 1) {
          return `0${formatted}`;
        }
        return formatted;
      } else {
        return getPlaceholder(part, "", locale);
      }
    } else {
      if (isDateSegmentPart(part)) {
        const value = segmentValues[part];
        const leadingZero = typeof value === "string" && (value == null ? void 0 : value.startsWith("0"));
        if (value === "0") {
          return "0";
        } else if (!isNull(value)) {
          const formatted = formatter.part(dateRef.set({ [part]: value }), part);
          if (part === "year") {
            return `${value}`;
          }
          if (leadingZero && formatted.length === 1) {
            return `0${formatted}`;
          }
          return formatted;
        } else {
          return getPlaceholder(part, "", locale);
        }
      }
      return "";
    }
  }
  return content;
}
function createContentArr(props) {
  const { granularity, dateRef, formatter, contentObj, hideTimeZone, hourCycle } = props;
  const parts = formatter.toParts(dateRef, getOptsByGranularity(granularity, hourCycle));
  const segmentContentArr = parts.map((part) => {
    const defaultParts = ["literal", "dayPeriod", "timeZoneName", null];
    if (defaultParts.includes(part.type) || !isSegmentPart(part.type)) {
      return {
        part: part.type,
        value: part.value
      };
    }
    return {
      part: part.type,
      value: contentObj[part.type]
    };
  }).filter((segment) => {
    if (isNull(segment.part) || isNull(segment.value))
      return false;
    if (segment.part === "timeZoneName" && (!isZonedDateTime(dateRef) || hideTimeZone)) {
      return false;
    }
    return true;
  });
  return segmentContentArr;
}
function createContent(props) {
  const contentObj = createContentObj(props);
  const contentArr = createContentArr({
    contentObj,
    ...props
  });
  return {
    obj: contentObj,
    arr: contentArr
  };
}
function getOptsByGranularity(granularity, hourCycle) {
  const opts = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short",
    hourCycle: hourCycle === 24 ? "h23" : void 0,
    hour12: hourCycle === 24 ? false : void 0
  };
  if (granularity === "day") {
    delete opts.second;
    delete opts.hour;
    delete opts.minute;
    delete opts.timeZoneName;
  }
  if (granularity === "hour") {
    delete opts.minute;
  }
  if (granularity === "minute") {
    delete opts.second;
  }
  return opts;
}
function initSegmentStates() {
  return EDITABLE_SEGMENT_PARTS.reduce((acc, key) => {
    acc[key] = {
      lastKeyZero: false,
      hasLeftFocus: true,
      updating: null
    };
    return acc;
  }, {});
}
function isDateSegmentPart(part) {
  return DATE_SEGMENT_PARTS.includes(part);
}
function isSegmentPart(part) {
  return EDITABLE_SEGMENT_PARTS.includes(part);
}
function isAnySegmentPart(part) {
  return ALL_SEGMENT_PARTS.includes(part);
}
function getUsedSegments(fieldNode) {
  if (!isBrowser || !fieldNode)
    return [];
  const usedSegments = getSegments(fieldNode).map((el) => el.dataset.segment).filter((part) => {
    return EDITABLE_SEGMENT_PARTS.includes(part);
  });
  return usedSegments;
}
function getValueFromSegments(props) {
  const { segmentObj, fieldNode, dateRef } = props;
  const usedSegments = getUsedSegments(fieldNode);
  let date = dateRef;
  for (const part of usedSegments) {
    if ("hour" in segmentObj) {
      const value = segmentObj[part];
      if (isNull(value))
        continue;
      date = date.set({ [part]: segmentObj[part] });
    } else if (isDateSegmentPart(part)) {
      const value = segmentObj[part];
      if (isNull(value))
        continue;
      date = date.set({ [part]: segmentObj[part] });
    }
  }
  return date;
}
function areAllSegmentsFilled(segmentValues, fieldNode) {
  const usedSegments = getUsedSegments(fieldNode);
  for (const part of usedSegments) {
    if ("hour" in segmentValues) {
      if (segmentValues[part] === null) {
        return false;
      }
    } else if (isDateSegmentPart(part)) {
      if (segmentValues[part] === null) {
        return false;
      }
    }
  }
  return true;
}
function isDateAndTimeSegmentObj(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  return Object.entries(obj).every(([key, value]) => {
    const validKey = EDITABLE_TIME_SEGMENT_PARTS.includes(key) || DATE_SEGMENT_PARTS.includes(key);
    const validValue = key === "dayPeriod" ? value === "AM" || value === "PM" || value === null : typeof value === "string" || typeof value === "number" || value === null;
    return validKey && validValue;
  });
}
function inferGranularity(value, granularity) {
  if (granularity)
    return granularity;
  if (hasTime(value))
    return "minute";
  return "day";
}
function isAcceptableSegmentKey(key) {
  const acceptableSegmentKeys = [
    kbd_constants_exports.ENTER,
    kbd_constants_exports.ARROW_UP,
    kbd_constants_exports.ARROW_DOWN,
    kbd_constants_exports.ARROW_LEFT,
    kbd_constants_exports.ARROW_RIGHT,
    kbd_constants_exports.BACKSPACE,
    kbd_constants_exports.SPACE
  ];
  if (acceptableSegmentKeys.includes(key))
    return true;
  if (isNumberString(key))
    return true;
  return false;
}
function isFirstSegment(id, fieldNode) {
  if (!isBrowser)
    return false;
  const segments = getSegments(fieldNode);
  return segments.length ? segments[0].id === id : false;
}
function setDescription(props) {
  const { id, formatter, value, doc } = props;
  if (!isBrowser)
    return;
  const valueString = formatter.selectedDate(value);
  const el = doc.getElementById(id);
  if (!el) {
    const div = doc.createElement("div");
    div.style.cssText = styleToString({
      display: "none"
    });
    div.id = id;
    div.innerText = `Selected Date: ${valueString}`;
    doc.body.appendChild(div);
  } else {
    el.innerText = `Selected Date: ${valueString}`;
  }
}
function removeDescriptionElement(id, doc) {
  if (!isBrowser)
    return;
  const el = doc.getElementById(id);
  if (!el)
    return;
  doc.body.removeChild(el);
}
function getDefaultHourCycle(locale) {
  const formatter = new Intl.DateTimeFormat(locale, { hour: "numeric" });
  const parts = formatter.formatToParts(/* @__PURE__ */ new Date("2023-01-01T13:00:00"));
  const hourPart = parts.find((part) => part.type === "hour");
  return (hourPart == null ? void 0 : hourPart.value) === "1" ? 12 : 24;
}

// node_modules/bits-ui/dist/internal/date-time/field/segments.js
function handleSegmentNavigation(e, fieldNode) {
  const currentTarget = e.currentTarget;
  if (!isHTMLElement2(currentTarget))
    return;
  const { prev: prev2, next: next3 } = getPrevNextSegments(currentTarget, fieldNode);
  if (e.key === kbd_constants_exports.ARROW_LEFT) {
    if (!prev2)
      return;
    prev2.focus();
  } else if (e.key === kbd_constants_exports.ARROW_RIGHT) {
    if (!next3)
      return;
    next3.focus();
  }
}
function handleTimeSegmentNavigation(e, fieldNode) {
  const currentTarget = e.currentTarget;
  if (!isHTMLElement2(currentTarget))
    return;
  const { prev: prev2, next: next3 } = getPrevNextTimeSegments(currentTarget, fieldNode);
  if (e.key === kbd_constants_exports.ARROW_LEFT) {
    if (!prev2)
      return;
    prev2.focus();
  } else if (e.key === kbd_constants_exports.ARROW_RIGHT) {
    if (!next3)
      return;
    next3.focus();
  }
}
function getNextSegment(node, segments) {
  const index = segments.indexOf(node);
  if (index === segments.length - 1 || index === -1)
    return null;
  const nextIndex = index + 1;
  const nextSegment = segments[nextIndex];
  return nextSegment;
}
function getPrevSegment(node, segments) {
  const index = segments.indexOf(node);
  if (index === 0 || index === -1)
    return null;
  const prevIndex = index - 1;
  const prevSegment = segments[prevIndex];
  return prevSegment;
}
function getPrevNextSegments(startingNode, fieldNode) {
  const segments = getSegments(fieldNode);
  if (!segments.length) {
    return {
      next: null,
      prev: null
    };
  }
  return {
    next: getNextSegment(startingNode, segments),
    prev: getPrevSegment(startingNode, segments)
  };
}
function getPrevNextTimeSegments(startingNode, fieldNode) {
  const segments = getTimeSegments(fieldNode);
  if (!segments.length) {
    return {
      next: null,
      prev: null
    };
  }
  return {
    next: getNextSegment(startingNode, segments),
    prev: getPrevSegment(startingNode, segments)
  };
}
function moveToNextSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement2(node))
    return;
  const { next: next3 } = getPrevNextSegments(node, fieldNode);
  if (!next3)
    return;
  next3.focus();
}
function moveToNextTimeSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement2(node))
    return;
  const { next: next3 } = getPrevNextTimeSegments(node, fieldNode);
  if (!next3)
    return;
  next3.focus();
}
function moveToPrevTimeSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement2(node))
    return;
  const { prev: prev2 } = getPrevNextTimeSegments(node, fieldNode);
  if (!prev2)
    return;
  prev2.focus();
}
function moveToPrevSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement2(node))
    return;
  const { prev: prev2 } = getPrevNextSegments(node, fieldNode);
  if (!prev2)
    return;
  prev2.focus();
}
function isSegmentNavigationKey(key) {
  if (key === kbd_constants_exports.ARROW_RIGHT || key === kbd_constants_exports.ARROW_LEFT)
    return true;
  return false;
}
function getSegments(fieldNode) {
  if (!fieldNode)
    return [];
  const segments = Array.from(fieldNode.querySelectorAll("[data-segment]")).filter((el) => {
    if (!isHTMLElement2(el))
      return false;
    const segment = el.dataset.segment;
    if (segment === "trigger")
      return true;
    if (!isAnySegmentPart(segment) || segment === "literal")
      return false;
    return true;
  });
  return segments;
}
function getTimeSegments(fieldNode) {
  if (!fieldNode)
    return [];
  const segments = Array.from(fieldNode.querySelectorAll("[data-segment]")).filter((el) => {
    if (!isHTMLElement2(el))
      return false;
    const segment = el.dataset.segment;
    if (segment === "trigger")
      return true;
    if (segment === "literal")
      return false;
    return true;
  });
  return segments;
}
function getFirstTimeSegment(fieldNode) {
  return getTimeSegments(fieldNode)[0];
}
function getFirstSegment(fieldNode) {
  return getSegments(fieldNode)[0];
}

// node_modules/bits-ui/dist/internal/date-time/field/time-helpers.js
function createTimeContentObj(props) {
  const { segmentValues, formatter, locale, timeRef } = props;
  const content = Object.keys(segmentValues).reduce((obj, part) => {
    if (!isEditableTimeSegmentPart(part))
      return obj;
    if (part === "dayPeriod") {
      const value = segmentValues[part];
      if (!isNull(value)) {
        obj[part] = value;
      } else {
        obj[part] = getPlaceholder(part, "AM", locale);
      }
    } else {
      obj[part] = getPartContent(part);
    }
    return obj;
  }, {});
  function getPartContent(part) {
    const value = segmentValues[part];
    const leadingZero = typeof value === "string" && (value == null ? void 0 : value.startsWith("0"));
    const intValue = value !== null ? Number.parseInt(value) : null;
    if (!isNull(value) && !isNull(intValue)) {
      const formatted = formatter.part(timeRef.set({ [part]: value }), part, {
        hourCycle: props.hourCycle === 24 ? "h23" : void 0
      });
      const is12HourMode = props.hourCycle === 12 || props.hourCycle === void 0 && getDefaultHourCycle(locale) === 12;
      if (part === "hour" && is12HourMode) {
        if (intValue > 12) {
          const hour = intValue - 12;
          if (hour === 0) {
            return "12";
          } else if (hour < 10) {
            return `0${hour}`;
          } else {
            return `${hour}`;
          }
        }
        if (intValue === 0) {
          return "12";
        }
        if (intValue < 10) {
          return `0${intValue}`;
        }
        return `${intValue}`;
      }
      if (leadingZero && formatted.length === 1) {
        return `0${formatted}`;
      }
      return formatted;
    } else {
      return getPlaceholder(part, "", locale);
    }
  }
  return content;
}
function createTimeContentArr(props) {
  const { granularity, timeRef, formatter, contentObj, hideTimeZone, hourCycle } = props;
  const parts = formatter.toParts(timeRef, getOptsByGranularity2(granularity, hourCycle));
  const timeSegmentContentArr = parts.map((part) => {
    const defaultParts = ["literal", "timeZoneName", null];
    if (defaultParts.includes(part.type) || !isEditableTimeSegmentPart(part.type)) {
      return {
        part: part.type,
        value: part.value
      };
    }
    return {
      part: part.type,
      value: contentObj[part.type]
    };
  }).filter((segment) => {
    if (isNull(segment.part) || isNull(segment.value))
      return false;
    if (segment.part === "timeZoneName" && (!isZonedDateTime(timeRef) || hideTimeZone)) {
      return false;
    }
    return true;
  });
  return timeSegmentContentArr;
}
function createTimeContent(props) {
  const contentObj = createTimeContentObj(props);
  const contentArr = createTimeContentArr({
    contentObj,
    ...props
  });
  return {
    obj: contentObj,
    arr: contentArr
  };
}
function getOptsByGranularity2(granularity, hourCycle) {
  const opts = {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short",
    hourCycle: hourCycle === 24 ? "h23" : void 0,
    hour12: hourCycle === 24 ? false : void 0
  };
  if (granularity === "hour") {
    delete opts.minute;
    delete opts.second;
  }
  if (granularity === "minute") {
    delete opts.second;
  }
  return opts;
}
function initTimeSegmentStates() {
  return EDITABLE_TIME_SEGMENT_PARTS.reduce((acc, key) => {
    acc[key] = {
      lastKeyZero: false,
      hasLeftFocus: true,
      updating: null
    };
    return acc;
  }, {});
}
function isEditableTimeSegmentPart(part) {
  return EDITABLE_TIME_SEGMENT_PARTS.includes(part);
}
function getUsedTimeSegments(fieldNode) {
  if (!isBrowser || !fieldNode)
    return [];
  const usedSegments = getTimeSegments(fieldNode).map((el) => el.dataset.segment).filter((part) => {
    return EDITABLE_TIME_SEGMENT_PARTS.includes(part);
  });
  return usedSegments;
}
function getTimeValueFromSegments(props) {
  const usedSegments = getUsedTimeSegments(props.fieldNode);
  for (const part of usedSegments) {
    const value = props.segmentObj[part];
    if (isNull(value))
      continue;
    props.timeRef = props.timeRef.set({ [part]: props.segmentObj[part] });
  }
  return props.timeRef;
}
function areAllTimeSegmentsFilled(segmentValues, fieldNode) {
  const usedSegments = getUsedTimeSegments(fieldNode);
  for (const part of usedSegments) {
    if (segmentValues[part] === null)
      return false;
  }
  return true;
}
function isFirstTimeSegment(id, fieldNode) {
  if (!isBrowser)
    return false;
  const segments = getTimeSegments(fieldNode);
  return segments.length ? segments[0].id === id : false;
}
function setTimeDescription(props) {
  if (!isBrowser)
    return;
  const valueString = props.formatter.selectedTime(props.value);
  const el = props.doc.getElementById(props.id);
  if (!el) {
    const div = props.doc.createElement("div");
    div.style.cssText = styleToString({
      display: "none"
    });
    div.id = props.id;
    div.innerText = `Selected Time: ${valueString}`;
    props.doc.body.appendChild(div);
  } else {
    el.innerText = `Selected Time: ${valueString}`;
  }
}
function removeTimeDescriptionElement(id, doc) {
  if (!isBrowser)
    return;
  const el = doc.getElementById(id);
  if (!el)
    return;
  doc.body.removeChild(el);
}
function convertTimeValueToDateValue(time) {
  if (time instanceof $35ea8db9cb2ccb90$export$680ea196effce5f) {
    return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(2020, 1, 1, time.hour, time.minute, time.second, time.millisecond);
  }
  return time;
}
function convertTimeValueToTime(time) {
  if (time instanceof $35ea8db9cb2ccb90$export$680ea196effce5f)
    return time;
  return new $35ea8db9cb2ccb90$export$680ea196effce5f(time.hour, time.minute, time.second, time.millisecond);
}
function isTimeBefore(timeToCompare, referenceTime) {
  return timeToCompare.compare(referenceTime) < 0;
}
function getISOTimeValue(time) {
  return convertTimeValueToTime(time).toString();
}

// node_modules/bits-ui/dist/internal/date-time/formatter.js
var defaultPartOptions = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
};
function createFormatter(opts) {
  let locale = opts.initialLocale;
  function setLocale(newLocale) {
    locale = newLocale;
  }
  function getLocale() {
    return locale;
  }
  function custom(date, options) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).format(date);
  }
  function selectedDate(date, includeTime = true) {
    if (hasTime(date) && includeTime) {
      return custom(toDate(date), {
        dateStyle: "long",
        timeStyle: "long"
      });
    } else {
      return custom(toDate(date), {
        dateStyle: "long"
      });
    }
  }
  function fullMonthAndYear(date) {
    if (typeof opts.monthFormat.current !== "function" && typeof opts.yearFormat.current !== "function") {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
        month: opts.monthFormat.current,
        year: opts.yearFormat.current
      }).format(date);
    }
    const formattedMonth = typeof opts.monthFormat.current === "function" ? opts.monthFormat.current(date.getMonth() + 1) : new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { month: opts.monthFormat.current }).format(date);
    const formattedYear = typeof opts.yearFormat.current === "function" ? opts.yearFormat.current(date.getFullYear()) : new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { year: opts.yearFormat.current }).format(date);
    return `${formattedMonth} ${formattedYear}`;
  }
  function fullMonth(date) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { month: "long" }).format(date);
  }
  function fullYear(date) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { year: "numeric" }).format(date);
  }
  function toParts(date, options) {
    if (isZonedDateTime(date)) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
        ...options,
        timeZone: date.timeZone
      }).formatToParts(toDate(date));
    } else {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).formatToParts(toDate(date));
    }
  }
  function dayOfWeek(date, length = "narrow") {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: length }).format(date);
  }
  function dayPeriod(date, hourCycle = void 0) {
    var _a;
    const parts = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
      hour: "numeric",
      minute: "numeric",
      hourCycle: hourCycle === 24 ? "h23" : void 0
    }).formatToParts(date);
    const value = (_a = parts.find((p2) => p2.type === "dayPeriod")) == null ? void 0 : _a.value;
    if (value === "PM") {
      return "PM";
    }
    return "AM";
  }
  function part(dateObj, type, options = {}) {
    const opts2 = { ...defaultPartOptions, ...options };
    const parts = toParts(dateObj, opts2);
    const part2 = parts.find((p2) => p2.type === type);
    return part2 ? part2.value : "";
  }
  return {
    setLocale,
    getLocale,
    fullMonth,
    fullYear,
    fullMonthAndYear,
    toParts,
    custom,
    part,
    dayPeriod,
    selectedDate,
    dayOfWeek
  };
}
function createTimeFormatter(initialLocale) {
  let locale = initialLocale;
  function setLocale(newLocale) {
    locale = newLocale;
  }
  function getLocale() {
    return locale;
  }
  function custom(date, options) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).format(date);
  }
  function selectedTime(date) {
    return custom(toDate(convertTimeValueToDateValue(date)), {
      timeStyle: "long"
    });
  }
  function toParts(timeValue, options) {
    const dateValue = convertTimeValueToDateValue(timeValue);
    if (isZonedDateTime(dateValue)) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
        ...options,
        timeZone: dateValue.timeZone
      }).formatToParts(toDate(dateValue));
    } else {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).formatToParts(toDate(dateValue));
    }
  }
  function dayPeriod(date, hourCycle = void 0) {
    var _a;
    const parts = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
      hour: "numeric",
      minute: "numeric",
      hourCycle: hourCycle === 24 ? "h23" : void 0
    }).formatToParts(date);
    const value = (_a = parts.find((p2) => p2.type === "dayPeriod")) == null ? void 0 : _a.value;
    if (value === "PM")
      return "PM";
    return "AM";
  }
  function part(dateObj, type, options = {}) {
    const opts = { ...defaultPartOptions, ...options };
    const parts = toParts(dateObj, opts);
    const part2 = parts.find((p2) => p2.type === type);
    return part2 ? part2.value : "";
  }
  return {
    setLocale,
    getLocale,
    toParts,
    custom,
    part,
    dayPeriod,
    selectedTime
  };
}

// node_modules/bits-ui/dist/internal/date-time/calendar-helpers.svelte.js
function isCalendarDayNode(node) {
  if (!isHTMLElement2(node)) return false;
  if (!node.hasAttribute("data-bits-day")) return false;
  return true;
}
function getDaysBetween(start, end) {
  const days = [];
  let dCurrent = start.add({ days: 1 });
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    days.push(dCurrent);
    dCurrent = dCurrent.add({ days: 1 });
  }
  return days;
}
function createMonth(props) {
  const { dateObj, weekStartsOn, fixedWeeks, locale } = props;
  const daysInMonth = getDaysInMonth(dateObj);
  const datesArray = Array.from({ length: daysInMonth }, (_, i) => dateObj.set({ day: i + 1 }));
  const firstDayOfMonth = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(dateObj);
  const lastDayOfMonth = $14e0f24ef4ac5c92$export$a2258d9c4118825c(dateObj);
  const lastSunday = weekStartsOn !== void 0 ? getLastFirstDayOfWeek(firstDayOfMonth, weekStartsOn, "en-US") : getLastFirstDayOfWeek(firstDayOfMonth, 0, locale);
  const nextSaturday = weekStartsOn !== void 0 ? getNextLastDayOfWeek(lastDayOfMonth, weekStartsOn, "en-US") : getNextLastDayOfWeek(lastDayOfMonth, 0, locale);
  const lastMonthDays = getDaysBetween(lastSunday.subtract({ days: 1 }), firstDayOfMonth);
  const nextMonthDays = getDaysBetween(lastDayOfMonth, nextSaturday.add({ days: 1 }));
  const totalDays = lastMonthDays.length + datesArray.length + nextMonthDays.length;
  if (fixedWeeks && totalDays < 42) {
    const extraDays = 42 - totalDays;
    let startFrom = nextMonthDays[nextMonthDays.length - 1];
    if (!startFrom) {
      startFrom = dateObj.add({ months: 1 }).set({ day: 1 });
    }
    let length = extraDays;
    if (nextMonthDays.length === 0) {
      length = extraDays - 1;
      nextMonthDays.push(startFrom);
    }
    const extraDaysArray = Array.from({ length }, (_, i) => {
      const incr = i + 1;
      return startFrom.add({ days: incr });
    });
    nextMonthDays.push(...extraDaysArray);
  }
  const allDays = lastMonthDays.concat(datesArray, nextMonthDays);
  const weeks = chunk(allDays, 7);
  return { value: dateObj, dates: allDays, weeks };
}
function createMonths(props) {
  const { numberOfMonths, dateObj, ...monthProps } = props;
  const months = [];
  if (!numberOfMonths || numberOfMonths === 1) {
    months.push(createMonth({ ...monthProps, dateObj }));
    return months;
  }
  months.push(createMonth({ ...monthProps, dateObj }));
  for (let i = 1; i < numberOfMonths; i++) {
    const nextMonth = dateObj.add({ months: i });
    months.push(createMonth({ ...monthProps, dateObj: nextMonth }));
  }
  return months;
}
function getSelectableCells(calendarNode) {
  if (!calendarNode) return [];
  const selectableSelector = `[data-bits-day]:not([data-disabled]):not([data-outside-visible-months])`;
  return Array.from(calendarNode.querySelectorAll(selectableSelector)).filter((el) => isHTMLElement2(el));
}
function setPlaceholderToNodeValue(node, placeholder) {
  const cellValue = node.getAttribute("data-value");
  if (!cellValue) return;
  placeholder.current = parseStringToDateValue(cellValue, placeholder.current);
}
function shiftCalendarFocus({
  node,
  add,
  placeholder,
  calendarNode,
  isPrevButtonDisabled,
  isNextButtonDisabled,
  months,
  numberOfMonths
}) {
  var _a, _b;
  const candidateCells = getSelectableCells(calendarNode);
  if (!candidateCells.length) return;
  const index = candidateCells.indexOf(node);
  const nextIndex = index + add;
  if (isValidIndex(nextIndex, candidateCells)) {
    const nextCell = candidateCells[nextIndex];
    setPlaceholderToNodeValue(nextCell, placeholder);
    return nextCell.focus();
  }
  if (nextIndex < 0) {
    if (isPrevButtonDisabled) return;
    const firstMonth = (_a = months[0]) == null ? void 0 : _a.value;
    if (!firstMonth) return;
    placeholder.current = firstMonth.subtract({ months: numberOfMonths });
    afterTick(() => {
      const newCandidateCells = getSelectableCells(calendarNode);
      if (!newCandidateCells.length) return;
      const newIndex = newCandidateCells.length - Math.abs(nextIndex);
      if (isValidIndex(newIndex, newCandidateCells)) {
        const newCell = newCandidateCells[newIndex];
        setPlaceholderToNodeValue(newCell, placeholder);
        return newCell.focus();
      }
    });
  }
  if (nextIndex >= candidateCells.length) {
    if (isNextButtonDisabled) return;
    const firstMonth = (_b = months[0]) == null ? void 0 : _b.value;
    if (!firstMonth) return;
    placeholder.current = firstMonth.add({ months: numberOfMonths });
    afterTick(() => {
      const newCandidateCells = getSelectableCells(calendarNode);
      if (!newCandidateCells.length) return;
      const newIndex = nextIndex - candidateCells.length;
      if (isValidIndex(newIndex, newCandidateCells)) {
        const nextCell = newCandidateCells[newIndex];
        return nextCell.focus();
      }
    });
  }
}
var ARROW_KEYS = [
  kbd_constants_exports.ARROW_DOWN,
  kbd_constants_exports.ARROW_UP,
  kbd_constants_exports.ARROW_LEFT,
  kbd_constants_exports.ARROW_RIGHT
];
var SELECT_KEYS = [kbd_constants_exports.ENTER, kbd_constants_exports.SPACE];
function handleCalendarKeydown({
  event,
  handleCellClick,
  shiftFocus,
  placeholderValue
}) {
  const currentCell = event.target;
  if (!isCalendarDayNode(currentCell)) return;
  if (!ARROW_KEYS.includes(event.key) && !SELECT_KEYS.includes(event.key)) return;
  event.preventDefault();
  const kbdFocusMap = {
    [kbd_constants_exports.ARROW_DOWN]: 7,
    [kbd_constants_exports.ARROW_UP]: -7,
    [kbd_constants_exports.ARROW_LEFT]: -1,
    [kbd_constants_exports.ARROW_RIGHT]: 1
  };
  if (ARROW_KEYS.includes(event.key)) {
    const add = kbdFocusMap[event.key];
    if (add !== void 0) {
      shiftFocus(currentCell, add);
    }
  }
  if (SELECT_KEYS.includes(event.key)) {
    const cellValue = currentCell.getAttribute("data-value");
    if (!cellValue) return;
    handleCellClick(event, parseStringToDateValue(cellValue, placeholderValue));
  }
}
function handleCalendarNextPage({
  months,
  setMonths,
  numberOfMonths,
  pagedNavigation,
  weekStartsOn,
  locale,
  fixedWeeks,
  setPlaceholder
}) {
  var _a;
  const firstMonth = (_a = months[0]) == null ? void 0 : _a.value;
  if (!firstMonth) return;
  if (pagedNavigation) {
    setPlaceholder(firstMonth.add({ months: numberOfMonths }));
  } else {
    const targetDate = firstMonth.add({ months: 1 });
    const newMonths = createMonths({
      dateObj: targetDate,
      weekStartsOn,
      locale,
      fixedWeeks,
      numberOfMonths
    });
    setPlaceholder(targetDate);
    setMonths(newMonths);
  }
}
function handleCalendarPrevPage({
  months,
  setMonths,
  numberOfMonths,
  pagedNavigation,
  weekStartsOn,
  locale,
  fixedWeeks,
  setPlaceholder
}) {
  var _a;
  const firstMonth = (_a = months[0]) == null ? void 0 : _a.value;
  if (!firstMonth) return;
  if (pagedNavigation) {
    setPlaceholder(firstMonth.subtract({ months: numberOfMonths }));
  } else {
    const targetDate = firstMonth.subtract({ months: 1 });
    const newMonths = createMonths({
      dateObj: targetDate,
      weekStartsOn,
      locale,
      fixedWeeks,
      numberOfMonths
    });
    setPlaceholder(targetDate);
    setMonths(newMonths);
  }
}
function getWeekdays({ months, formatter, weekdayFormat }) {
  if (!months.length) return [];
  const firstMonth = months[0];
  const firstWeek = firstMonth.weeks[0];
  if (!firstWeek) return [];
  return firstWeek.map((date) => formatter.dayOfWeek(toDate(date), weekdayFormat));
}
function useMonthViewOptionsSync(props) {
  user_effect(() => {
    const weekStartsOn = props.weekStartsOn.current;
    const locale = props.locale.current;
    const fixedWeeks = props.fixedWeeks.current;
    const numberOfMonths = props.numberOfMonths.current;
    untrack(() => {
      const placeholder = props.placeholder.current;
      if (!placeholder) return;
      const defaultMonthProps = {
        weekStartsOn,
        locale,
        fixedWeeks,
        numberOfMonths
      };
      props.setMonths(createMonths({ ...defaultMonthProps, dateObj: placeholder }));
    });
  });
}
function createAccessibleHeading({ calendarNode, label, accessibleHeadingId }) {
  const doc = getDocument(calendarNode);
  const div = doc.createElement("div");
  div.style.cssText = styleToString({
    border: "0px",
    clip: "rect(0px, 0px, 0px, 0px)",
    clipPath: "inset(50%)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0px",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  });
  const h2 = doc.createElement("div");
  h2.textContent = label;
  h2.id = accessibleHeadingId;
  h2.role = "heading";
  h2.ariaLevel = "2";
  calendarNode.insertBefore(div, calendarNode.firstChild);
  div.appendChild(h2);
  return () => {
    var _a;
    const h22 = doc.getElementById(accessibleHeadingId);
    if (!h22) return;
    (_a = div.parentElement) == null ? void 0 : _a.removeChild(div);
    h22.remove();
  };
}
function useMonthViewPlaceholderSync({
  placeholder,
  getVisibleMonths,
  weekStartsOn,
  locale,
  fixedWeeks,
  numberOfMonths,
  setMonths
}) {
  user_effect(() => {
    placeholder.current;
    untrack(() => {
      if (getVisibleMonths().some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(month, placeholder.current))) {
        return;
      }
      const defaultMonthProps = {
        weekStartsOn: weekStartsOn.current,
        locale: locale.current,
        fixedWeeks: fixedWeeks.current,
        numberOfMonths: numberOfMonths.current
      };
      setMonths(createMonths({
        ...defaultMonthProps,
        dateObj: placeholder.current
      }));
    });
  });
}
function getIsNextButtonDisabled({ maxValue, months, disabled }) {
  var _a;
  if (!maxValue || !months.length) return false;
  if (disabled) return true;
  const lastMonthInView = (_a = months[months.length - 1]) == null ? void 0 : _a.value;
  if (!lastMonthInView) return false;
  const firstMonthOfNextPage = lastMonthInView.add({ months: 1 }).set({ day: 1 });
  return isAfter(firstMonthOfNextPage, maxValue);
}
function getIsPrevButtonDisabled({ minValue, months, disabled }) {
  var _a;
  if (!minValue || !months.length) return false;
  if (disabled) return true;
  const firstMonthInView = (_a = months[0]) == null ? void 0 : _a.value;
  if (!firstMonthInView) return false;
  const lastMonthOfPrevPage = firstMonthInView.subtract({ months: 1 }).set({ day: 35 });
  return isBefore(lastMonthOfPrevPage, minValue);
}
function getCalendarHeadingValue({ months, locale, formatter }) {
  if (!months.length) return "";
  if (locale !== formatter.getLocale()) {
    formatter.setLocale(locale);
  }
  if (months.length === 1) {
    const month = toDate(months[0].value);
    return `${formatter.fullMonthAndYear(month)}`;
  }
  const startMonth = toDate(months[0].value);
  const endMonth = toDate(months[months.length - 1].value);
  const startMonthName = formatter.fullMonth(startMonth);
  const endMonthName = formatter.fullMonth(endMonth);
  const startMonthYear = formatter.fullYear(startMonth);
  const endMonthYear = formatter.fullYear(endMonth);
  const content = startMonthYear === endMonthYear ? `${startMonthName} - ${endMonthName} ${endMonthYear}` : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;
  return content;
}
function getCalendarElementProps({
  fullCalendarLabel,
  id,
  isInvalid,
  disabled,
  readonly
}) {
  return {
    id,
    role: "application",
    "aria-label": fullCalendarLabel,
    "data-invalid": boolToEmptyStrOrUndef(isInvalid),
    "data-disabled": boolToEmptyStrOrUndef(disabled),
    "data-readonly": boolToEmptyStrOrUndef(readonly)
  };
}
function pickerOpenFocus(e) {
  const doc = getDocument(e.target);
  const nodeToFocus = doc.querySelector("[data-bits-day][data-focused]");
  if (nodeToFocus) {
    e.preventDefault();
    nodeToFocus == null ? void 0 : nodeToFocus.focus();
  }
}
function getFirstNonDisabledDateInView(calendarRef) {
  if (!isBrowser) return;
  const daysInView = Array.from(calendarRef.querySelectorAll("[data-bits-day]:not([aria-disabled=true])"));
  if (daysInView.length === 0) return;
  const element2 = daysInView[0];
  const value = element2 == null ? void 0 : element2.getAttribute("data-value");
  const type = element2 == null ? void 0 : element2.getAttribute("data-type");
  if (!value || !type) return;
  return parseAnyDateValue(value, type);
}
function useEnsureNonDisabledPlaceholder({
  ref,
  placeholder,
  defaultPlaceholder,
  minValue,
  maxValue,
  isDateDisabled
}) {
  function isDisabled(date) {
    if (isDateDisabled.current(date)) return true;
    if (minValue.current && isBefore(date, minValue.current)) return true;
    if (maxValue.current && isBefore(maxValue.current, date)) return true;
    return false;
  }
  watch(() => ref.current, () => {
    if (!ref.current) return;
    if (placeholder.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(placeholder.current, defaultPlaceholder) && isDisabled(defaultPlaceholder)) {
      placeholder.current = getFirstNonDisabledDateInView(ref.current) ?? defaultPlaceholder;
    }
  });
}
function getDateWithPreviousTime(date, prev2) {
  if (!date || !prev2) return date;
  if (hasTime(date) && hasTime(prev2)) {
    return date.set({
      hour: prev2.hour,
      minute: prev2.minute,
      millisecond: prev2.millisecond,
      second: prev2.second
    });
  }
  return date;
}
var calendarAttrs = createBitsAttrs({
  component: "calendar",
  parts: [
    "root",
    "grid",
    "cell",
    "next-button",
    "prev-button",
    "day",
    "grid-body",
    "grid-head",
    "grid-row",
    "head-cell",
    "header",
    "heading",
    "month-select",
    "year-select"
  ]
});
function getDefaultYears(opts) {
  const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  const latestYear = Math.max(opts.placeholderYear, currentYear);
  let minYear;
  let maxYear;
  if (opts.minValue) {
    minYear = opts.minValue.year;
  } else {
    const initialMinYear = latestYear - 100;
    minYear = opts.placeholderYear < initialMinYear ? opts.placeholderYear - 10 : initialMinYear;
  }
  if (opts.maxValue) {
    maxYear = opts.maxValue.year;
  } else {
    maxYear = latestYear + 10;
  }
  if (minYear > maxYear) {
    minYear = maxYear;
  }
  const totalYears = maxYear - minYear + 1;
  return Array.from({ length: totalYears }, (_, i) => minYear + i);
}

// node_modules/bits-ui/dist/bits/calendar/calendar.svelte.js
var CalendarRootContext = new Context("Calendar.Root | RangeCalender.Root");
var _visibleMonths, _months, _weekdays, _initialPlaceholderYear, _defaultYears, _CalendarRootState_instances, setupInitialFocusEffect_fn, setupAccessibleHeadingEffect_fn, setupFormatterEffect_fn, _isNextButtonDisabled, _isPrevButtonDisabled, _isInvalid, _headingValue, _fullCalendarLabel, isMultipleSelectionValid_fn, _snippetProps6, _props32;
var _CalendarRootState = class _CalendarRootState {
  constructor(opts) {
    __privateAdd(this, _CalendarRootState_instances);
    __publicField(this, "opts");
    __privateAdd(this, _visibleMonths, user_derived(() => this.months.map((month) => month.value)));
    __publicField(this, "formatter");
    __publicField(this, "accessibleHeadingId", useId());
    __publicField(this, "domContext");
    __publicField(this, "attachment");
    __privateAdd(this, _months, state(proxy([])));
    __publicField(this, "announcer");
    __privateAdd(this, _weekdays, user_derived(() => {
      return getWeekdays({
        months: this.months,
        formatter: this.formatter,
        weekdayFormat: this.opts.weekdayFormat.current
      });
    }));
    __privateAdd(this, _initialPlaceholderYear, user_derived(() => untrack(() => this.opts.placeholder.current.year)));
    __privateAdd(this, _defaultYears, user_derived(() => {
      return getDefaultYears({
        minValue: this.opts.minValue.current,
        maxValue: this.opts.maxValue.current,
        placeholderYear: this.initialPlaceholderYear
      });
    }));
    __privateAdd(this, _isNextButtonDisabled, user_derived(() => {
      return getIsNextButtonDisabled({
        maxValue: this.opts.maxValue.current,
        months: this.months,
        disabled: this.opts.disabled.current
      });
    }));
    __privateAdd(this, _isPrevButtonDisabled, user_derived(() => {
      return getIsPrevButtonDisabled({
        minValue: this.opts.minValue.current,
        months: this.months,
        disabled: this.opts.disabled.current
      });
    }));
    __privateAdd(this, _isInvalid, user_derived(() => {
      const value = this.opts.value.current;
      const isDateDisabled = this.opts.isDateDisabled.current;
      const isDateUnavailable = this.opts.isDateUnavailable.current;
      if (Array.isArray(value)) {
        if (!value.length) return false;
        for (const date of value) {
          if (isDateDisabled(date)) return true;
          if (isDateUnavailable(date)) return true;
        }
      } else {
        if (!value) return false;
        if (isDateDisabled(value)) return true;
        if (isDateUnavailable(value)) return true;
      }
      return false;
    }));
    __privateAdd(this, _headingValue, user_derived(() => {
      this.opts.monthFormat.current;
      this.opts.yearFormat.current;
      return getCalendarHeadingValue({
        months: this.months,
        formatter: this.formatter,
        locale: this.opts.locale.current
      });
    }));
    __privateAdd(this, _fullCalendarLabel, user_derived(() => {
      return `${this.opts.calendarLabel.current} ${this.headingValue}`;
    }));
    __privateAdd(this, _snippetProps6, user_derived(() => ({ months: this.months, weekdays: this.weekdays })));
    __publicField(this, "getBitsAttr", (part) => {
      return calendarAttrs.getAttr(part);
    });
    __privateAdd(this, _props32, user_derived(() => ({
      ...getCalendarElementProps({
        fullCalendarLabel: this.fullCalendarLabel,
        id: this.opts.id.current,
        isInvalid: this.isInvalid,
        disabled: this.opts.disabled.current,
        readonly: this.opts.readonly.current
      }),
      [this.getBitsAttr("root")]: "",
      //
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.domContext = new DOMContext(opts.ref);
    this.announcer = getAnnouncer(null);
    this.formatter = createFormatter({
      initialLocale: this.opts.locale.current,
      monthFormat: this.opts.monthFormat,
      yearFormat: this.opts.yearFormat
    });
    this.setMonths = this.setMonths.bind(this);
    this.nextPage = this.nextPage.bind(this);
    this.prevPage = this.prevPage.bind(this);
    this.prevYear = this.prevYear.bind(this);
    this.nextYear = this.nextYear.bind(this);
    this.setYear = this.setYear.bind(this);
    this.setMonth = this.setMonth.bind(this);
    this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this);
    this.isDateDisabled = this.isDateDisabled.bind(this);
    this.isDateSelected = this.isDateSelected.bind(this);
    this.shiftFocus = this.shiftFocus.bind(this);
    this.handleCellClick = this.handleCellClick.bind(this);
    this.handleMultipleUpdate = this.handleMultipleUpdate.bind(this);
    this.handleSingleUpdate = this.handleSingleUpdate.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.getBitsAttr = this.getBitsAttr.bind(this);
    onMount(() => {
      this.announcer = getAnnouncer(this.domContext.getDocument());
    });
    this.months = createMonths({
      dateObj: this.opts.placeholder.current,
      weekStartsOn: this.opts.weekStartsOn.current,
      locale: this.opts.locale.current,
      fixedWeeks: this.opts.fixedWeeks.current,
      numberOfMonths: this.opts.numberOfMonths.current
    });
    __privateMethod(this, _CalendarRootState_instances, setupInitialFocusEffect_fn).call(this);
    __privateMethod(this, _CalendarRootState_instances, setupAccessibleHeadingEffect_fn).call(this);
    __privateMethod(this, _CalendarRootState_instances, setupFormatterEffect_fn).call(this);
    useMonthViewPlaceholderSync({
      placeholder: this.opts.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.opts.weekStartsOn,
      locale: this.opts.locale,
      fixedWeeks: this.opts.fixedWeeks,
      numberOfMonths: this.opts.numberOfMonths,
      setMonths: (months) => this.months = months
    });
    useMonthViewOptionsSync({
      fixedWeeks: this.opts.fixedWeeks,
      locale: this.opts.locale,
      numberOfMonths: this.opts.numberOfMonths,
      placeholder: this.opts.placeholder,
      setMonths: this.setMonths,
      weekStartsOn: this.opts.weekStartsOn
    });
    watch(() => this.fullCalendarLabel, (label) => {
      const node = this.domContext.getElementById(this.accessibleHeadingId);
      if (!node) return;
      node.textContent = label;
    });
    watch(() => this.opts.value.current, () => {
      const value = this.opts.value.current;
      if (Array.isArray(value) && value.length) {
        const lastValue = value[value.length - 1];
        if (lastValue && this.opts.placeholder.current !== lastValue) {
          this.opts.placeholder.current = lastValue;
        }
      } else if (!Array.isArray(value) && value && this.opts.placeholder.current !== value) {
        this.opts.placeholder.current = value;
      }
    });
    useEnsureNonDisabledPlaceholder({
      placeholder: opts.placeholder,
      defaultPlaceholder: opts.defaultPlaceholder,
      isDateDisabled: opts.isDateDisabled,
      maxValue: opts.maxValue,
      minValue: opts.minValue,
      ref: opts.ref
    });
  }
  static create(opts) {
    return CalendarRootContext.set(new _CalendarRootState(opts));
  }
  get visibleMonths() {
    return get(__privateGet(this, _visibleMonths));
  }
  set visibleMonths(value) {
    set(__privateGet(this, _visibleMonths), value);
  }
  get months() {
    return get(__privateGet(this, _months));
  }
  set months(value) {
    set(__privateGet(this, _months), value, true);
  }
  setMonths(months) {
    this.months = months;
  }
  get weekdays() {
    return get(__privateGet(this, _weekdays));
  }
  set weekdays(value) {
    set(__privateGet(this, _weekdays), value);
  }
  get initialPlaceholderYear() {
    return get(__privateGet(this, _initialPlaceholderYear));
  }
  set initialPlaceholderYear(value) {
    set(__privateGet(this, _initialPlaceholderYear), value);
  }
  get defaultYears() {
    return get(__privateGet(this, _defaultYears));
  }
  set defaultYears(value) {
    set(__privateGet(this, _defaultYears), value);
  }
  /**
   * Navigates to the next page of the calendar.
   */
  nextPage() {
    handleCalendarNextPage({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (date) => this.opts.placeholder.current = date,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  /**
   * Navigates to the previous page of the calendar.
   */
  prevPage() {
    handleCalendarPrevPage({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (date) => this.opts.placeholder.current = date,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  nextYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.add({ years: 1 });
  }
  prevYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.subtract({ years: 1 });
  }
  setYear(year) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ year });
  }
  setMonth(month) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ month });
  }
  get isNextButtonDisabled() {
    return get(__privateGet(this, _isNextButtonDisabled));
  }
  set isNextButtonDisabled(value) {
    set(__privateGet(this, _isNextButtonDisabled), value);
  }
  get isPrevButtonDisabled() {
    return get(__privateGet(this, _isPrevButtonDisabled));
  }
  set isPrevButtonDisabled(value) {
    set(__privateGet(this, _isPrevButtonDisabled), value);
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid));
  }
  set isInvalid(value) {
    set(__privateGet(this, _isInvalid), value);
  }
  get headingValue() {
    return get(__privateGet(this, _headingValue));
  }
  set headingValue(value) {
    set(__privateGet(this, _headingValue), value);
  }
  get fullCalendarLabel() {
    return get(__privateGet(this, _fullCalendarLabel));
  }
  set fullCalendarLabel(value) {
    set(__privateGet(this, _fullCalendarLabel), value);
  }
  isOutsideVisibleMonths(date) {
    return !this.visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, month));
  }
  isDateDisabled(date) {
    if (this.opts.isDateDisabled.current(date) || this.opts.disabled.current) return true;
    const minValue = this.opts.minValue.current;
    const maxValue = this.opts.maxValue.current;
    if (minValue && isBefore(date, minValue)) return true;
    if (maxValue && isBefore(maxValue, date)) return true;
    return false;
  }
  isDateSelected(date) {
    const value = this.opts.value.current;
    if (Array.isArray(value)) {
      return value.some((d) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
    } else if (!value) {
      return false;
    }
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(value, date);
  }
  shiftFocus(node, add) {
    return shiftCalendarFocus({
      node,
      add,
      placeholder: this.opts.placeholder,
      calendarNode: this.opts.ref.current,
      isPrevButtonDisabled: this.isPrevButtonDisabled,
      isNextButtonDisabled: this.isNextButtonDisabled,
      months: this.months,
      numberOfMonths: this.opts.numberOfMonths.current
    });
  }
  handleCellClick(_, date) {
    var _a, _b, _c, _d, _e, _f;
    if (this.opts.readonly.current || ((_b = (_a = this.opts.isDateDisabled).current) == null ? void 0 : _b.call(_a, date)) || ((_d = (_c = this.opts.isDateUnavailable).current) == null ? void 0 : _d.call(_c, date))) {
      return;
    }
    const prev2 = this.opts.value.current;
    const multiple = this.opts.type.current === "multiple";
    if (multiple) {
      if (Array.isArray(prev2) || prev2 === void 0) {
        this.opts.value.current = this.handleMultipleUpdate(prev2, date);
      }
    } else if (!Array.isArray(prev2)) {
      const next3 = this.handleSingleUpdate(prev2, date);
      if (!next3) {
        this.announcer.announce("Selected date is now empty.", "polite", 5e3);
      } else {
        this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(next3, false)}`, "polite");
      }
      this.opts.value.current = getDateWithPreviousTime(next3, prev2);
      if (next3 !== void 0) {
        (_f = (_e = this.opts.onDateSelect) == null ? void 0 : _e.current) == null ? void 0 : _f.call(_e);
      }
    }
  }
  handleMultipleUpdate(prev2, date) {
    if (!prev2) {
      const newSelection = [date];
      return __privateMethod(this, _CalendarRootState_instances, isMultipleSelectionValid_fn).call(this, newSelection) ? newSelection : [date];
    }
    if (!Array.isArray(prev2)) {
      if (false_default) throw new Error("Invalid value for multiple prop.");
      return;
    }
    const index = prev2.findIndex((d) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
    const preventDeselect = this.opts.preventDeselect.current;
    if (index === -1) {
      const newSelection = [...prev2, date];
      if (__privateMethod(this, _CalendarRootState_instances, isMultipleSelectionValid_fn).call(this, newSelection)) {
        return newSelection;
      } else {
        return [date];
      }
    } else if (preventDeselect) {
      return prev2;
    } else {
      const next3 = prev2.filter((d) => !$14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
      if (!next3.length) {
        this.opts.placeholder.current = date;
        return void 0;
      }
      return next3;
    }
  }
  handleSingleUpdate(prev2, date) {
    if (Array.isArray(prev2)) {
      if (false_default) throw new Error("Invalid value for single prop.");
    }
    if (!prev2) return date;
    const preventDeselect = this.opts.preventDeselect.current;
    if (!preventDeselect && $14e0f24ef4ac5c92$export$ea39ec197993aef0(prev2, date)) {
      this.opts.placeholder.current = date;
      return void 0;
    }
    return date;
  }
  onkeydown(event) {
    handleCalendarKeydown({
      event,
      handleCellClick: this.handleCellClick,
      shiftFocus: this.shiftFocus,
      placeholderValue: this.opts.placeholder.current
    });
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps6));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps6), value);
  }
  get props() {
    return get(__privateGet(this, _props32));
  }
  set props(value) {
    set(__privateGet(this, _props32), value);
  }
};
_visibleMonths = new WeakMap();
_months = new WeakMap();
_weekdays = new WeakMap();
_initialPlaceholderYear = new WeakMap();
_defaultYears = new WeakMap();
_CalendarRootState_instances = new WeakSet();
setupInitialFocusEffect_fn = function() {
  user_effect(() => {
    var _a;
    const initialFocus = untrack(() => this.opts.initialFocus.current);
    if (initialFocus) {
      const firstFocusedDay = (_a = this.opts.ref.current) == null ? void 0 : _a.querySelector(`[data-focused]`);
      if (firstFocusedDay) {
        firstFocusedDay.focus();
      }
    }
  });
};
setupAccessibleHeadingEffect_fn = function() {
  user_effect(() => {
    if (!this.opts.ref.current) return;
    const removeHeading = createAccessibleHeading({
      calendarNode: this.opts.ref.current,
      label: this.fullCalendarLabel,
      accessibleHeadingId: this.accessibleHeadingId
    });
    return removeHeading;
  });
};
setupFormatterEffect_fn = function() {
  user_pre_effect(() => {
    if (this.formatter.getLocale() === this.opts.locale.current) return;
    this.formatter.setLocale(this.opts.locale.current);
  });
};
_isNextButtonDisabled = new WeakMap();
_isPrevButtonDisabled = new WeakMap();
_isInvalid = new WeakMap();
_headingValue = new WeakMap();
_fullCalendarLabel = new WeakMap();
isMultipleSelectionValid_fn = function(selectedDates) {
  if (this.opts.type.current !== "multiple") return true;
  if (!this.opts.maxDays.current) return true;
  const selectedCount = selectedDates.length;
  if (this.opts.maxDays.current && selectedCount > this.opts.maxDays.current) return false;
  return true;
};
_snippetProps6 = new WeakMap();
_props32 = new WeakMap();
var CalendarRootState = _CalendarRootState;
var _props33;
var _CalendarHeadingState = class _CalendarHeadingState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props33, user_derived(() => ({
      id: this.opts.id.current,
      "aria-hidden": boolToStrTrueOrUndef(true),
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      "data-readonly": boolToEmptyStrOrUndef(this.root.opts.readonly.current),
      [this.root.getBitsAttr("heading")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarHeadingState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props33));
  }
  set props(value) {
    set(__privateGet(this, _props33), value);
  }
};
_props33 = new WeakMap();
var CalendarHeadingState = _CalendarHeadingState;
var CalendarCellContext = new Context("Calendar.Cell | RangeCalendar.Cell");
var _cellDate, _isUnavailable, _isDateToday, _isOutsideMonth, _isOutsideVisibleMonths, _isDisabled3, _isFocusedDate, _isSelectedDate, _labelText, _snippetProps7, _ariaDisabled, _sharedDataAttrs, _props34;
var _CalendarCellState = class _CalendarCellState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _cellDate, user_derived(() => toDate(this.opts.date.current)));
    __privateAdd(this, _isUnavailable, user_derived(() => this.root.opts.isDateUnavailable.current(this.opts.date.current)));
    __privateAdd(this, _isDateToday, user_derived(() => $14e0f24ef4ac5c92$export$629b0a497aa65267(this.opts.date.current, $14e0f24ef4ac5c92$export$aa8b41735afcabd2())));
    __privateAdd(this, _isOutsideMonth, user_derived(() => !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(this.opts.date.current, this.opts.month.current)));
    __privateAdd(this, _isOutsideVisibleMonths, user_derived(() => this.root.isOutsideVisibleMonths(this.opts.date.current)));
    __privateAdd(this, _isDisabled3, user_derived(() => this.root.isDateDisabled(this.opts.date.current) || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current));
    __privateAdd(this, _isFocusedDate, user_derived(() => $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.date.current, this.root.opts.placeholder.current)));
    __privateAdd(this, _isSelectedDate, user_derived(() => this.root.isDateSelected(this.opts.date.current)));
    __privateAdd(this, _labelText, user_derived(() => this.root.formatter.custom(this.cellDate, {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })));
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps7, user_derived(() => ({
      disabled: this.isDisabled,
      unavailable: this.isUnavailable,
      selected: this.isSelectedDate,
      day: `${this.opts.date.current.day}`
    })));
    __privateAdd(this, _ariaDisabled, user_derived(() => {
      return this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current || this.isUnavailable;
    }));
    __privateAdd(this, _sharedDataAttrs, user_derived(() => ({
      "data-unavailable": boolToEmptyStrOrUndef(this.isUnavailable),
      "data-today": this.isDateToday ? "" : void 0,
      "data-outside-month": this.isOutsideMonth ? "" : void 0,
      "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
      "data-focused": this.isFocusedDate ? "" : void 0,
      "data-selected": boolToEmptyStrOrUndef(this.isSelectedDate),
      "data-value": this.opts.date.current.toString(),
      "data-type": getDateValueType(this.opts.date.current),
      "data-disabled": boolToEmptyStrOrUndef(this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current)
    })));
    __privateAdd(this, _props34, user_derived(() => ({
      id: this.opts.id.current,
      role: "gridcell",
      "aria-selected": boolToStr(this.isSelectedDate),
      "aria-disabled": boolToStr(this.ariaDisabled),
      ...this.sharedDataAttrs,
      [this.root.getBitsAttr("cell")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return CalendarCellContext.set(new _CalendarCellState(opts, CalendarRootContext.get()));
  }
  get cellDate() {
    return get(__privateGet(this, _cellDate));
  }
  set cellDate(value) {
    set(__privateGet(this, _cellDate), value);
  }
  get isUnavailable() {
    return get(__privateGet(this, _isUnavailable));
  }
  set isUnavailable(value) {
    set(__privateGet(this, _isUnavailable), value);
  }
  get isDateToday() {
    return get(__privateGet(this, _isDateToday));
  }
  set isDateToday(value) {
    set(__privateGet(this, _isDateToday), value);
  }
  get isOutsideMonth() {
    return get(__privateGet(this, _isOutsideMonth));
  }
  set isOutsideMonth(value) {
    set(__privateGet(this, _isOutsideMonth), value);
  }
  get isOutsideVisibleMonths() {
    return get(__privateGet(this, _isOutsideVisibleMonths));
  }
  set isOutsideVisibleMonths(value) {
    set(__privateGet(this, _isOutsideVisibleMonths), value);
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled3));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled3), value);
  }
  get isFocusedDate() {
    return get(__privateGet(this, _isFocusedDate));
  }
  set isFocusedDate(value) {
    set(__privateGet(this, _isFocusedDate), value);
  }
  get isSelectedDate() {
    return get(__privateGet(this, _isSelectedDate));
  }
  set isSelectedDate(value) {
    set(__privateGet(this, _isSelectedDate), value);
  }
  get labelText() {
    return get(__privateGet(this, _labelText));
  }
  set labelText(value) {
    set(__privateGet(this, _labelText), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps7));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps7), value);
  }
  get ariaDisabled() {
    return get(__privateGet(this, _ariaDisabled));
  }
  set ariaDisabled(value) {
    set(__privateGet(this, _ariaDisabled), value);
  }
  get sharedDataAttrs() {
    return get(__privateGet(this, _sharedDataAttrs));
  }
  set sharedDataAttrs(value) {
    set(__privateGet(this, _sharedDataAttrs), value);
  }
  get props() {
    return get(__privateGet(this, _props34));
  }
  set props(value) {
    set(__privateGet(this, _props34), value);
  }
};
_cellDate = new WeakMap();
_isUnavailable = new WeakMap();
_isDateToday = new WeakMap();
_isOutsideMonth = new WeakMap();
_isOutsideVisibleMonths = new WeakMap();
_isDisabled3 = new WeakMap();
_isFocusedDate = new WeakMap();
_isSelectedDate = new WeakMap();
_labelText = new WeakMap();
_snippetProps7 = new WeakMap();
_ariaDisabled = new WeakMap();
_sharedDataAttrs = new WeakMap();
_props34 = new WeakMap();
var CalendarCellState = _CalendarCellState;
var _tabindex, _snippetProps8, _props35;
var _CalendarDayState = class _CalendarDayState {
  constructor(opts, cell) {
    __publicField(this, "opts");
    __publicField(this, "cell");
    __publicField(this, "attachment");
    __privateAdd(this, _tabindex, user_derived(() => this.cell.isOutsideMonth && this.cell.root.opts.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : this.cell.isFocusedDate ? 0 : -1));
    __privateAdd(this, _snippetProps8, user_derived(() => ({
      disabled: this.cell.isDisabled,
      unavailable: this.cell.isUnavailable,
      selected: this.cell.isSelectedDate,
      day: `${this.cell.opts.date.current.day}`
    })));
    __privateAdd(this, _props35, user_derived(() => ({
      id: this.opts.id.current,
      role: "button",
      "aria-label": this.cell.labelText,
      "aria-disabled": boolToStr(this.cell.ariaDisabled),
      ...this.cell.sharedDataAttrs,
      tabindex: get(__privateGet(this, _tabindex)),
      [this.cell.root.getBitsAttr("day")]: "",
      // Shared logic for range calendar and calendar
      "data-bits-day": "",
      //
      onclick: this.onclick,
      ...this.attachment
    })));
    this.opts = opts;
    this.cell = cell;
    this.onclick = this.onclick.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarDayState(opts, CalendarCellContext.get());
  }
  onclick(e) {
    if (this.cell.isDisabled) return;
    this.cell.root.handleCellClick(e, this.cell.opts.date.current);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps8));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps8), value);
  }
  get props() {
    return get(__privateGet(this, _props35));
  }
  set props(value) {
    set(__privateGet(this, _props35), value);
  }
};
_tabindex = new WeakMap();
_snippetProps8 = new WeakMap();
_props35 = new WeakMap();
var CalendarDayState = _CalendarDayState;
var _isDisabled4, _props36;
var _CalendarNextButtonState = class _CalendarNextButtonState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _isDisabled4, user_derived(() => this.root.isNextButtonDisabled));
    __publicField(this, "attachment");
    __privateAdd(this, _props36, user_derived(() => ({
      id: this.opts.id.current,
      role: "button",
      type: "button",
      "aria-label": "Next",
      "aria-disabled": boolToStr(this.isDisabled),
      "data-disabled": boolToEmptyStrOrUndef(this.isDisabled),
      disabled: this.isDisabled,
      [this.root.getBitsAttr("next-button")]: "",
      //
      onclick: this.onclick,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.onclick = this.onclick.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarNextButtonState(opts, CalendarRootContext.get());
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled4));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled4), value);
  }
  onclick(_) {
    if (this.isDisabled) return;
    this.root.nextPage();
  }
  get props() {
    return get(__privateGet(this, _props36));
  }
  set props(value) {
    set(__privateGet(this, _props36), value);
  }
};
_isDisabled4 = new WeakMap();
_props36 = new WeakMap();
var CalendarNextButtonState = _CalendarNextButtonState;
var _isDisabled5, _props37;
var _CalendarPrevButtonState = class _CalendarPrevButtonState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _isDisabled5, user_derived(() => this.root.isPrevButtonDisabled));
    __publicField(this, "attachment");
    __privateAdd(this, _props37, user_derived(() => ({
      id: this.opts.id.current,
      role: "button",
      type: "button",
      "aria-label": "Previous",
      "aria-disabled": boolToStr(this.isDisabled),
      "data-disabled": boolToEmptyStrOrUndef(this.isDisabled),
      disabled: this.isDisabled,
      [this.root.getBitsAttr("prev-button")]: "",
      //
      onclick: this.onclick,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.onclick = this.onclick.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarPrevButtonState(opts, CalendarRootContext.get());
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled5));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled5), value);
  }
  onclick(_) {
    if (this.isDisabled) return;
    this.root.prevPage();
  }
  get props() {
    return get(__privateGet(this, _props37));
  }
  set props(value) {
    set(__privateGet(this, _props37), value);
  }
};
_isDisabled5 = new WeakMap();
_props37 = new WeakMap();
var CalendarPrevButtonState = _CalendarPrevButtonState;
var _props38;
var _CalendarGridState = class _CalendarGridState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props38, user_derived(() => ({
      id: this.opts.id.current,
      tabindex: -1,
      role: "grid",
      "aria-readonly": boolToStr(this.root.opts.readonly.current),
      "aria-disabled": boolToStr(this.root.opts.disabled.current),
      "data-readonly": boolToEmptyStrOrUndef(this.root.opts.readonly.current),
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      [this.root.getBitsAttr("grid")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarGridState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props38));
  }
  set props(value) {
    set(__privateGet(this, _props38), value);
  }
};
_props38 = new WeakMap();
var CalendarGridState = _CalendarGridState;
var _props39;
var _CalendarGridBodyState = class _CalendarGridBodyState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props39, user_derived(() => ({
      id: this.opts.id.current,
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      "data-readonly": boolToEmptyStrOrUndef(this.root.opts.readonly.current),
      [this.root.getBitsAttr("grid-body")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarGridBodyState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props39));
  }
  set props(value) {
    set(__privateGet(this, _props39), value);
  }
};
_props39 = new WeakMap();
var CalendarGridBodyState = _CalendarGridBodyState;
var _props40;
var _CalendarGridHeadState = class _CalendarGridHeadState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props40, user_derived(() => ({
      id: this.opts.id.current,
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      "data-readonly": boolToEmptyStrOrUndef(this.root.opts.readonly.current),
      [this.root.getBitsAttr("grid-head")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarGridHeadState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props40));
  }
  set props(value) {
    set(__privateGet(this, _props40), value);
  }
};
_props40 = new WeakMap();
var CalendarGridHeadState = _CalendarGridHeadState;
var _props41;
var _CalendarGridRowState = class _CalendarGridRowState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props41, user_derived(() => ({
      id: this.opts.id.current,
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      "data-readonly": boolToEmptyStrOrUndef(this.root.opts.readonly.current),
      [this.root.getBitsAttr("grid-row")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarGridRowState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props41));
  }
  set props(value) {
    set(__privateGet(this, _props41), value);
  }
};
_props41 = new WeakMap();
var CalendarGridRowState = _CalendarGridRowState;
var _props42;
var _CalendarHeadCellState = class _CalendarHeadCellState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props42, user_derived(() => ({
      id: this.opts.id.current,
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      "data-readonly": boolToEmptyStrOrUndef(this.root.opts.readonly.current),
      [this.root.getBitsAttr("head-cell")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarHeadCellState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props42));
  }
  set props(value) {
    set(__privateGet(this, _props42), value);
  }
};
_props42 = new WeakMap();
var CalendarHeadCellState = _CalendarHeadCellState;
var _props43;
var _CalendarHeaderState = class _CalendarHeaderState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props43, user_derived(() => ({
      id: this.opts.id.current,
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      "data-readonly": boolToEmptyStrOrUndef(this.root.opts.readonly.current),
      [this.root.getBitsAttr("header")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarHeaderState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props43));
  }
  set props(value) {
    set(__privateGet(this, _props43), value);
  }
};
_props43 = new WeakMap();
var CalendarHeaderState = _CalendarHeaderState;
var _monthItems, _currentMonth, _isDisabled6, _snippetProps9, _props44;
var _CalendarMonthSelectState = class _CalendarMonthSelectState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _monthItems, user_derived(() => {
      this.root.opts.locale.current;
      const monthNumbers = this.opts.months.current;
      const monthFormat = this.opts.monthFormat.current;
      const months = [];
      for (const month of monthNumbers) {
        const date = this.root.opts.placeholder.current.set({ month });
        let label;
        if (typeof monthFormat === "function") {
          label = monthFormat(month);
        } else {
          label = this.root.formatter.custom(toDate(date), { month: monthFormat });
        }
        months.push({ value: month, label });
      }
      return months;
    }));
    __privateAdd(this, _currentMonth, user_derived(() => this.root.opts.placeholder.current.month));
    __privateAdd(this, _isDisabled6, user_derived(() => this.root.opts.disabled.current || this.opts.disabled.current));
    __privateAdd(this, _snippetProps9, user_derived(() => {
      return {
        monthItems: this.monthItems,
        selectedMonthItem: this.monthItems.find((month) => month.value === this.currentMonth)
      };
    }));
    __privateAdd(this, _props44, user_derived(() => ({
      id: this.opts.id.current,
      value: this.currentMonth,
      disabled: this.isDisabled,
      "data-disabled": boolToEmptyStrOrUndef(this.isDisabled),
      [this.root.getBitsAttr("month-select")]: "",
      //
      onchange: this.onchange,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.onchange = this.onchange.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarMonthSelectState(opts, CalendarRootContext.get());
  }
  get monthItems() {
    return get(__privateGet(this, _monthItems));
  }
  set monthItems(value) {
    set(__privateGet(this, _monthItems), value);
  }
  get currentMonth() {
    return get(__privateGet(this, _currentMonth));
  }
  set currentMonth(value) {
    set(__privateGet(this, _currentMonth), value);
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled6));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled6), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps9));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps9), value);
  }
  onchange(event) {
    if (this.isDisabled) return;
    const target = event.target;
    const month = parseInt(target.value, 10);
    if (!isNaN(month)) {
      this.root.opts.placeholder.current = this.root.opts.placeholder.current.set({ month });
    }
  }
  get props() {
    return get(__privateGet(this, _props44));
  }
  set props(value) {
    set(__privateGet(this, _props44), value);
  }
};
_monthItems = new WeakMap();
_currentMonth = new WeakMap();
_isDisabled6 = new WeakMap();
_snippetProps9 = new WeakMap();
_props44 = new WeakMap();
var CalendarMonthSelectState = _CalendarMonthSelectState;
var _years, _yearItems, _currentYear, _isDisabled7, _snippetProps10, _props45;
var _CalendarYearSelectState = class _CalendarYearSelectState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _years, user_derived(() => {
      if (this.opts.years.current && this.opts.years.current.length) return this.opts.years.current;
      return this.root.defaultYears;
    }));
    __privateAdd(this, _yearItems, user_derived(() => {
      this.root.opts.locale.current;
      const yearFormat = this.opts.yearFormat.current;
      const localYears = [];
      for (const year of this.years) {
        const date = this.root.opts.placeholder.current.set({ year });
        let label;
        if (typeof yearFormat === "function") {
          label = yearFormat(year);
        } else {
          label = this.root.formatter.custom(toDate(date), { year: yearFormat });
        }
        localYears.push({ value: year, label });
      }
      return localYears;
    }));
    __privateAdd(this, _currentYear, user_derived(() => this.root.opts.placeholder.current.year));
    __privateAdd(this, _isDisabled7, user_derived(() => this.root.opts.disabled.current || this.opts.disabled.current));
    __privateAdd(this, _snippetProps10, user_derived(() => {
      return {
        yearItems: this.yearItems,
        selectedYearItem: this.yearItems.find((year) => year.value === this.currentYear)
      };
    }));
    __privateAdd(this, _props45, user_derived(() => ({
      id: this.opts.id.current,
      value: this.currentYear,
      disabled: this.isDisabled,
      "data-disabled": boolToEmptyStrOrUndef(this.isDisabled),
      [this.root.getBitsAttr("year-select")]: "",
      //
      onchange: this.onchange,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.onchange = this.onchange.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarYearSelectState(opts, CalendarRootContext.get());
  }
  get years() {
    return get(__privateGet(this, _years));
  }
  set years(value) {
    set(__privateGet(this, _years), value);
  }
  get yearItems() {
    return get(__privateGet(this, _yearItems));
  }
  set yearItems(value) {
    set(__privateGet(this, _yearItems), value);
  }
  get currentYear() {
    return get(__privateGet(this, _currentYear));
  }
  set currentYear(value) {
    set(__privateGet(this, _currentYear), value);
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled7));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled7), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps10));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps10), value);
  }
  onchange(event) {
    if (this.isDisabled) return;
    const target = event.target;
    const year = parseInt(target.value, 10);
    if (!isNaN(year)) {
      this.root.opts.placeholder.current = this.root.opts.placeholder.current.set({ year });
    }
  }
  get props() {
    return get(__privateGet(this, _props45));
  }
  set props(value) {
    set(__privateGet(this, _props45), value);
  }
};
_years = new WeakMap();
_yearItems = new WeakMap();
_currentYear = new WeakMap();
_isDisabled7 = new WeakMap();
_snippetProps10 = new WeakMap();
_props45 = new WeakMap();
var CalendarYearSelectState = _CalendarYearSelectState;

// node_modules/bits-ui/dist/bits/calendar/components/calendar.svelte
var root_215 = from_html(`<div><!></div>`);
function Calendar($$anchor, $$props) {
  push($$props, true);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), pagedNavigation = prop($$props, "pagedNavigation", 3, false), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), minValue = prop($$props, "minValue", 3, void 0), maxValue = prop($$props, "maxValue", 3, void 0), preventDeselect = prop($$props, "preventDeselect", 3, false), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), initialFocus = prop($$props, "initialFocus", 3, false), monthFormat = prop($$props, "monthFormat", 3, "long"), yearFormat = prop($$props, "yearFormat", 3, "numeric"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "id",
    "ref",
    "value",
    "onValueChange",
    "placeholder",
    "onPlaceholderChange",
    "weekdayFormat",
    "weekStartsOn",
    "pagedNavigation",
    "isDateDisabled",
    "isDateUnavailable",
    "fixedWeeks",
    "numberOfMonths",
    "locale",
    "calendarLabel",
    "disabled",
    "readonly",
    "minValue",
    "maxValue",
    "preventDeselect",
    "type",
    "disableDaysOutsideMonth",
    "initialFocus",
    "maxDays",
    "monthFormat",
    "yearFormat"
  ]);
  const defaultPlaceholder = getDefaultDate({ defaultValue: value() });
  function handleDefaultPlaceholder() {
    if (placeholder() !== void 0) return;
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function handleDefaultValue() {
    if (value() !== void 0) return;
    value($$props.type === "single" ? void 0 : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = CalendarRootState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    weekdayFormat: boxWith(() => weekdayFormat()),
    weekStartsOn: boxWith(() => $$props.weekStartsOn),
    pagedNavigation: boxWith(() => pagedNavigation()),
    isDateDisabled: boxWith(() => isDateDisabled()),
    isDateUnavailable: boxWith(() => isDateUnavailable()),
    fixedWeeks: boxWith(() => fixedWeeks()),
    numberOfMonths: boxWith(() => numberOfMonths()),
    locale: resolveLocaleProp(() => $$props.locale),
    calendarLabel: boxWith(() => calendarLabel()),
    readonly: boxWith(() => readonly()),
    disabled: boxWith(() => disabled()),
    minValue: boxWith(() => minValue()),
    maxValue: boxWith(() => maxValue()),
    disableDaysOutsideMonth: boxWith(() => disableDaysOutsideMonth()),
    initialFocus: boxWith(() => initialFocus()),
    maxDays: boxWith(() => $$props.maxDays),
    placeholder: boxWith(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    preventDeselect: boxWith(() => preventDeselect()),
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    type: boxWith(() => $$props.type),
    monthFormat: boxWith(() => monthFormat()),
    yearFormat: boxWith(() => yearFormat()),
    defaultPlaceholder
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_215();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-day.svelte
var root_216 = from_html(`<div><!></div>`);
function Calendar_day($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const dayState = CalendarDayState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, dayState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...dayState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_216();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => dayState.snippetProps);
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, dayState.cell.opts.date.current.day));
          append($$anchor3, text2);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid.svelte
var root_217 = from_html(`<table><!></table>`);
function Calendar_grid($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const gridState = CalendarGridState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, gridState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var table = root_217();
      attribute_effect(table, () => ({ ...get(mergedProps) }));
      var node_2 = child(table);
      snippet(node_2, () => $$props.children ?? noop);
      reset(table);
      append($$anchor2, table);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-body.svelte
var root_218 = from_html(`<tbody><!></tbody>`);
function Calendar_grid_body($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const gridBodyState = CalendarGridBodyState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, gridBodyState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var tbody = root_218();
      attribute_effect(tbody, () => ({ ...get(mergedProps) }));
      var node_2 = child(tbody);
      snippet(node_2, () => $$props.children ?? noop);
      reset(tbody);
      append($$anchor2, tbody);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-cell.svelte
var root_219 = from_html(`<td><!></td>`);
function Calendar_cell($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id",
    "date",
    "month"
  ]);
  const cellState = CalendarCellState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    date: boxWith(() => $$props.date),
    month: boxWith(() => $$props.month)
  });
  const mergedProps = user_derived(() => mergeProps(restProps, cellState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...cellState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var td = root_219();
      attribute_effect(td, () => ({ ...get(mergedProps) }));
      var node_2 = child(td);
      snippet(node_2, () => $$props.children ?? noop, () => cellState.snippetProps);
      reset(td);
      append($$anchor2, td);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-head.svelte
var root_220 = from_html(`<thead><!></thead>`);
function Calendar_grid_head($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const gridHeadState = CalendarGridHeadState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, gridHeadState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var thead = root_220();
      attribute_effect(thead, () => ({ ...get(mergedProps) }));
      var node_2 = child(thead);
      snippet(node_2, () => $$props.children ?? noop);
      reset(thead);
      append($$anchor2, thead);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-head-cell.svelte
var root_221 = from_html(`<th><!></th>`);
function Calendar_head_cell($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const headCellState = CalendarHeadCellState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, headCellState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var th = root_221();
      attribute_effect(th, () => ({ ...get(mergedProps) }));
      var node_2 = child(th);
      snippet(node_2, () => $$props.children ?? noop);
      reset(th);
      append($$anchor2, th);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-row.svelte
var root_222 = from_html(`<tr><!></tr>`);
function Calendar_grid_row($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const gridRowState = CalendarGridRowState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, gridRowState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var tr = root_222();
      attribute_effect(tr, () => ({ ...get(mergedProps) }));
      var node_2 = child(tr);
      snippet(node_2, () => $$props.children ?? noop);
      reset(tr);
      append($$anchor2, tr);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-header.svelte
var root_223 = from_html(`<header><!></header>`);
function Calendar_header($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const headerState = CalendarHeaderState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, headerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var header = root_223();
      attribute_effect(header, () => ({ ...get(mergedProps) }));
      var node_2 = child(header);
      snippet(node_2, () => $$props.children ?? noop);
      reset(header);
      append($$anchor2, header);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-heading.svelte
var root_224 = from_html(`<div><!></div>`);
function Calendar_heading($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const headingState = CalendarHeadingState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, headingState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        headingValue: headingState.root.headingValue
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_224();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => ({ headingValue: headingState.root.headingValue }));
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, headingState.root.headingValue));
          append($$anchor3, text2);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-month-select.svelte
var root_5 = from_html(`<option> </option>`);
var root_225 = from_html(`<select><!></select>`);
function Calendar_month_select($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), months = prop($$props, "months", 19, () => [
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12
  ]), monthFormat = prop($$props, "monthFormat", 3, "long"), disabled = prop($$props, "disabled", 3, false), ariaLabel = prop($$props, "aria-label", 3, "Select a month"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id",
    "months",
    "monthFormat",
    "disabled",
    "aria-label"
  ]);
  const monthSelectState = CalendarMonthSelectState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    months: boxWith(() => months()),
    monthFormat: boxWith(() => monthFormat()),
    disabled: boxWith(() => Boolean(disabled()))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, monthSelectState.props, { "aria-label": ariaLabel() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...monthSelectState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var select = root_225();
      attribute_effect(select, () => ({ ...get(mergedProps) }));
      var node_2 = child(select);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => monthSelectState.snippetProps);
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          each(node_4, 17, () => monthSelectState.monthItems, (month) => month.value, ($$anchor4, month) => {
            var option = root_5();
            var option_value = {};
            var text2 = child(option, true);
            reset(option);
            template_effect(() => {
              if (option_value !== (option_value = get(month).value)) {
                option.value = (option.__value = get(month).value) ?? "";
              }
              set_selected(option, get(month).value === monthSelectState.currentMonth);
              set_text(text2, get(month).label);
            });
            append($$anchor4, option);
          });
          append($$anchor3, fragment_3);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(select);
      append($$anchor2, select);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-next-button.svelte
var root_226 = from_html(`<button><!></button>`);
function Calendar_next_button($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "tabindex"
  ]);
  const nextButtonState = CalendarNextButtonState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, nextButtonState.props, { tabindex: tabindex() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_226();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-prev-button.svelte
var root_227 = from_html(`<button><!></button>`);
function Calendar_prev_button($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "tabindex"
  ]);
  const prevButtonState = CalendarPrevButtonState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, prevButtonState.props, { tabindex: tabindex() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_227();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/calendar/components/calendar-year-select.svelte
var root_52 = from_html(`<option> </option>`);
var root_228 = from_html(`<select><!></select>`);
function Calendar_year_select($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), yearFormat = prop($$props, "yearFormat", 3, "numeric"), disabled = prop($$props, "disabled", 3, false), ariaLabel = prop($$props, "aria-label", 3, "Select a year"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id",
    "years",
    "yearFormat",
    "disabled",
    "aria-label"
  ]);
  const yearSelectState = CalendarYearSelectState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    years: boxWith(() => $$props.years),
    yearFormat: boxWith(() => yearFormat()),
    disabled: boxWith(() => Boolean(disabled()))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, yearSelectState.props, { "aria-label": ariaLabel() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...yearSelectState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var select = root_228();
      attribute_effect(select, () => ({ ...get(mergedProps) }));
      var node_2 = child(select);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => yearSelectState.snippetProps);
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          each(node_4, 17, () => yearSelectState.yearItems, (year) => year.value, ($$anchor4, year) => {
            var option = root_52();
            var option_value = {};
            var text2 = child(option, true);
            reset(option);
            template_effect(() => {
              if (option_value !== (option_value = get(year).value)) {
                option.value = (option.__value = get(year).value) ?? "";
              }
              set_selected(option, get(year).value === yearSelectState.currentYear);
              set_text(text2, get(year).label);
            });
            append($$anchor4, option);
          });
          append($$anchor3, fragment_3);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(select);
      append($$anchor2, select);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/checkbox/exports.js
var exports_exports7 = {};
__export(exports_exports7, {
  Group: () => Checkbox_group,
  GroupLabel: () => Checkbox_group_label,
  Root: () => Checkbox
});

// node_modules/bits-ui/dist/bits/checkbox/checkbox.svelte.js
var checkboxAttrs = createBitsAttrs({
  component: "checkbox",
  parts: ["root", "group", "group-label", "input"]
});
var CheckboxGroupContext = new Context("Checkbox.Group");
var _labelId, _props46;
var _CheckboxGroupState = class _CheckboxGroupState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _labelId, state(void 0));
    __privateAdd(this, _props46, user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      "aria-labelledby": this.labelId,
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      [checkboxAttrs.group]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return CheckboxGroupContext.set(new _CheckboxGroupState(opts));
  }
  get labelId() {
    return get(__privateGet(this, _labelId));
  }
  set labelId(value) {
    set(__privateGet(this, _labelId), value, true);
  }
  addValue(checkboxValue) {
    if (!checkboxValue) return;
    if (!this.opts.value.current.includes(checkboxValue)) {
      const newValue = [
        ...snapshot(this.opts.value.current),
        checkboxValue
      ];
      this.opts.value.current = newValue;
      if (arraysAreEqual(this.opts.value.current, newValue)) return;
      this.opts.onValueChange.current(newValue);
    }
  }
  removeValue(checkboxValue) {
    if (!checkboxValue) return;
    const index = this.opts.value.current.indexOf(checkboxValue);
    if (index === -1) return;
    const newValue = this.opts.value.current.filter((v) => v !== checkboxValue);
    this.opts.value.current = newValue;
    if (arraysAreEqual(this.opts.value.current, newValue)) return;
    this.opts.onValueChange.current(newValue);
  }
  get props() {
    return get(__privateGet(this, _props46));
  }
  set props(value) {
    set(__privateGet(this, _props46), value);
  }
};
_labelId = new WeakMap();
_props46 = new WeakMap();
var CheckboxGroupState = _CheckboxGroupState;
var _props47;
var _CheckboxGroupLabelState = class _CheckboxGroupLabelState {
  constructor(opts, group) {
    __publicField(this, "opts");
    __publicField(this, "group");
    __publicField(this, "attachment");
    __privateAdd(this, _props47, user_derived(() => ({
      id: this.opts.id.current,
      "data-disabled": boolToEmptyStrOrUndef(this.group.opts.disabled.current),
      [checkboxAttrs["group-label"]]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.group = group;
    this.group.labelId = this.opts.id.current;
    this.attachment = attachRef(this.opts.ref);
    watch.pre(() => this.opts.id.current, (id) => {
      this.group.labelId = id;
    });
  }
  static create(opts) {
    return new _CheckboxGroupLabelState(opts, CheckboxGroupContext.get());
  }
  get props() {
    return get(__privateGet(this, _props47));
  }
  set props(value) {
    set(__privateGet(this, _props47), value);
  }
};
_props47 = new WeakMap();
var CheckboxGroupLabelState = _CheckboxGroupLabelState;
var CheckboxRootContext = new Context("Checkbox.Root");
var _trueName, _trueRequired, _trueDisabled, _trueReadonly, _CheckboxRootState_instances, toggle_fn, _snippetProps11, _props48;
var _CheckboxRootState = class _CheckboxRootState {
  constructor(opts, group) {
    __privateAdd(this, _CheckboxRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "group");
    __privateAdd(this, _trueName, user_derived(() => {
      if (this.group && this.group.opts.name.current) return this.group.opts.name.current;
      return this.opts.name.current;
    }));
    __privateAdd(this, _trueRequired, user_derived(() => {
      if (this.group && this.group.opts.required.current) return true;
      return this.opts.required.current;
    }));
    __privateAdd(this, _trueDisabled, user_derived(() => {
      if (this.group && this.group.opts.disabled.current) return true;
      return this.opts.disabled.current;
    }));
    __privateAdd(this, _trueReadonly, user_derived(() => {
      if (this.group && this.group.opts.readonly.current) return true;
      return this.opts.readonly.current;
    }));
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps11, user_derived(() => ({
      checked: this.opts.checked.current,
      indeterminate: this.opts.indeterminate.current
    })));
    __privateAdd(this, _props48, user_derived(() => ({
      id: this.opts.id.current,
      role: "checkbox",
      type: this.opts.type.current,
      disabled: this.trueDisabled,
      "aria-checked": getAriaChecked(this.opts.checked.current, this.opts.indeterminate.current),
      "aria-required": boolToStr(this.trueRequired),
      "aria-readonly": boolToStr(this.trueReadonly),
      "data-disabled": boolToEmptyStrOrUndef(this.trueDisabled),
      "data-readonly": boolToEmptyStrOrUndef(this.trueReadonly),
      "data-state": getCheckboxDataState(this.opts.checked.current, this.opts.indeterminate.current),
      [checkboxAttrs.root]: "",
      //
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onclick = this.onclick.bind(this);
    watch.pre(
      [
        () => {
          var _a;
          return snapshot((_a = this.group) == null ? void 0 : _a.opts.value.current);
        },
        () => this.opts.value.current
      ],
      ([groupValue, value]) => {
        if (!groupValue || !value) return;
        this.opts.checked.current = groupValue.includes(value);
      }
    );
    watch.pre(() => this.opts.checked.current, (checked) => {
      var _a, _b;
      if (!this.group) return;
      if (checked) {
        (_a = this.group) == null ? void 0 : _a.addValue(this.opts.value.current);
      } else {
        (_b = this.group) == null ? void 0 : _b.removeValue(this.opts.value.current);
      }
    });
  }
  static create(opts, group = null) {
    return CheckboxRootContext.set(new _CheckboxRootState(opts, group));
  }
  get trueName() {
    return get(__privateGet(this, _trueName));
  }
  set trueName(value) {
    set(__privateGet(this, _trueName), value);
  }
  get trueRequired() {
    return get(__privateGet(this, _trueRequired));
  }
  set trueRequired(value) {
    set(__privateGet(this, _trueRequired), value);
  }
  get trueDisabled() {
    return get(__privateGet(this, _trueDisabled));
  }
  set trueDisabled(value) {
    set(__privateGet(this, _trueDisabled), value);
  }
  get trueReadonly() {
    return get(__privateGet(this, _trueReadonly));
  }
  set trueReadonly(value) {
    set(__privateGet(this, _trueReadonly), value);
  }
  onkeydown(e) {
    if (this.trueDisabled || this.trueReadonly) return;
    if (e.key === kbd_constants_exports.ENTER) e.preventDefault();
    if (e.key === kbd_constants_exports.SPACE) {
      e.preventDefault();
      __privateMethod(this, _CheckboxRootState_instances, toggle_fn).call(this);
    }
  }
  onclick(e) {
    if (this.trueDisabled || this.trueReadonly) return;
    if (this.opts.type.current === "submit") {
      __privateMethod(this, _CheckboxRootState_instances, toggle_fn).call(this);
      return;
    }
    e.preventDefault();
    __privateMethod(this, _CheckboxRootState_instances, toggle_fn).call(this);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps11));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps11), value);
  }
  get props() {
    return get(__privateGet(this, _props48));
  }
  set props(value) {
    set(__privateGet(this, _props48), value);
  }
};
_trueName = new WeakMap();
_trueRequired = new WeakMap();
_trueDisabled = new WeakMap();
_trueReadonly = new WeakMap();
_CheckboxRootState_instances = new WeakSet();
toggle_fn = function() {
  if (this.opts.indeterminate.current) {
    this.opts.indeterminate.current = false;
    this.opts.checked.current = true;
  } else {
    this.opts.checked.current = !this.opts.checked.current;
  }
};
_snippetProps11 = new WeakMap();
_props48 = new WeakMap();
var CheckboxRootState = _CheckboxRootState;
var _trueChecked, _shouldRender2, _props49;
var _CheckboxInputState = class _CheckboxInputState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _trueChecked, user_derived(() => {
      if (!this.root.group) return this.root.opts.checked.current;
      if (this.root.opts.value.current !== void 0 && this.root.group.opts.value.current.includes(this.root.opts.value.current)) {
        return true;
      }
      return false;
    }));
    __privateAdd(this, _shouldRender2, user_derived(() => Boolean(this.root.trueName)));
    __privateAdd(this, _props49, user_derived(() => ({
      type: "checkbox",
      checked: this.root.opts.checked.current === true,
      disabled: this.root.trueDisabled,
      required: this.root.trueRequired,
      name: this.root.trueName,
      value: this.root.opts.value.current,
      readonly: this.root.trueReadonly,
      onfocus: this.onfocus
    })));
    this.root = root18;
    this.onfocus = this.onfocus.bind(this);
  }
  static create() {
    return new _CheckboxInputState(CheckboxRootContext.get());
  }
  get trueChecked() {
    return get(__privateGet(this, _trueChecked));
  }
  set trueChecked(value) {
    set(__privateGet(this, _trueChecked), value);
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender2));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender2), value);
  }
  onfocus(_) {
    if (!isHTMLElement2(this.root.opts.ref.current)) return;
    this.root.opts.ref.current.focus();
  }
  get props() {
    return get(__privateGet(this, _props49));
  }
  set props(value) {
    set(__privateGet(this, _props49), value);
  }
};
_trueChecked = new WeakMap();
_shouldRender2 = new WeakMap();
_props49 = new WeakMap();
var CheckboxInputState = _CheckboxInputState;
function getCheckboxDataState(checked, indeterminate) {
  if (indeterminate) return "indeterminate";
  return checked ? "checked" : "unchecked";
}

// node_modules/bits-ui/dist/bits/utilities/hidden-input.svelte
var root_1 = from_html(`<input/>`);
var root_229 = from_html(`<input/>`);
function Hidden_input($$anchor, $$props) {
  push($$props, true);
  let value = prop($$props, "value", 15), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "value"]);
  const mergedProps = user_derived(() => mergeProps(restProps, {
    "aria-hidden": "true",
    tabindex: -1,
    style: srOnlyStylesString
  }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var input = root_1();
      remove_input_defaults(input);
      attribute_effect(input, () => ({ ...get(mergedProps), value: value() }));
      append($$anchor2, input);
    };
    var alternate = ($$anchor2) => {
      var input_1 = root_229();
      remove_input_defaults(input_1);
      attribute_effect(input_1, () => ({ ...get(mergedProps) }));
      bind_value(input_1, value);
      append($$anchor2, input_1);
    };
    if_block(node, ($$render) => {
      if (get(mergedProps).type === "checkbox") $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox-input.svelte
function Checkbox_input($$anchor, $$props) {
  push($$props, false);
  const inputState = CheckboxInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Hidden_input($$anchor2, spread_props(() => inputState.props));
    };
    if_block(node, ($$render) => {
      if (inputState.shouldRender) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox.svelte
var root_230 = from_html(`<button><!></button>`);
var root2 = from_html(`<!> <!>`, 1);
function Checkbox($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let checked = prop($$props, "checked", 15, false), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), required = prop($$props, "required", 3, false), name = prop($$props, "name", 3, void 0), value = prop($$props, "value", 3, "on"), id = prop($$props, "id", 19, () => createId(uid)), indeterminate = prop($$props, "indeterminate", 15, false), type = prop($$props, "type", 3, "button"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "checked",
    "ref",
    "onCheckedChange",
    "children",
    "disabled",
    "required",
    "name",
    "value",
    "id",
    "indeterminate",
    "onIndeterminateChange",
    "child",
    "type",
    "readonly"
  ]);
  const group = CheckboxGroupContext.getOr(null);
  if (group && value()) {
    if (group.opts.value.current.includes(value())) {
      checked(true);
    } else {
      checked(false);
    }
  }
  watch.pre(() => value(), () => {
    if (group && value()) {
      if (group.opts.value.current.includes(value())) {
        checked(true);
      } else {
        checked(false);
      }
    }
  });
  const rootState = CheckboxRootState.create(
    {
      checked: boxWith(() => checked(), (v) => {
        var _a;
        checked(v);
        (_a = $$props.onCheckedChange) == null ? void 0 : _a.call($$props, v);
      }),
      disabled: boxWith(() => disabled() ?? false),
      required: boxWith(() => required()),
      name: boxWith(() => name()),
      value: boxWith(() => value()),
      id: boxWith(() => id()),
      ref: boxWith(() => ref(), (v) => ref(v)),
      indeterminate: boxWith(() => indeterminate(), (v) => {
        var _a;
        indeterminate(v);
        (_a = $$props.onIndeterminateChange) == null ? void 0 : _a.call($$props, v);
      }),
      type: boxWith(() => type()),
      readonly: boxWith(() => Boolean($$props.readonly))
    },
    group
  );
  const mergedProps = user_derived(() => mergeProps({ ...restProps }, rootState.props));
  var fragment = root2();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_230();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  Checkbox_input(node_3, {});
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox-group.svelte
var root_231 = from_html(`<div><!></div>`);
function Checkbox_group($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), value = prop($$props, "value", 31, () => proxy([])), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "value",
    "onValueChange",
    "name",
    "required",
    "disabled",
    "children",
    "child",
    "readonly"
  ]);
  const groupState = CheckboxGroupState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    disabled: boxWith(() => Boolean($$props.disabled)),
    required: boxWith(() => Boolean($$props.required)),
    readonly: boxWith(() => Boolean($$props.readonly)),
    name: boxWith(() => $$props.name),
    value: boxWith(() => snapshot(value()), (v) => {
      if (arraysAreEqual(value(), v)) return;
      value(snapshot(v));
      onValueChange()(v);
    }),
    onValueChange: boxWith(() => onValueChange())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, groupState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_231();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox-group-label.svelte
var root_232 = from_html(`<span><!></span>`);
function Checkbox_group_label($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "child",
    "children"
  ]);
  const labelState = CheckboxGroupLabelState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, labelState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_232();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/collapsible/exports.js
var exports_exports8 = {};
__export(exports_exports8, {
  Content: () => Collapsible_content,
  Root: () => Collapsible,
  Trigger: () => Collapsible_trigger
});

// node_modules/bits-ui/dist/bits/collapsible/collapsible.svelte.js
var collapsibleAttrs = createBitsAttrs({
  component: "collapsible",
  parts: ["root", "content", "trigger"]
});
var CollapsibleRootContext = new Context("Collapsible.Root");
var _contentNode4, _contentId2, _props50;
var _CollapsibleRootState = class _CollapsibleRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _contentNode4, state(null));
    __publicField(this, "contentPresence");
    __privateAdd(this, _contentId2, state(void 0));
    __privateAdd(this, _props50, user_derived(() => ({
      id: this.opts.id.current,
      "data-state": getDataOpenClosed(this.opts.open.current),
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      [collapsibleAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.toggleOpen = this.toggleOpen.bind(this);
    this.attachment = attachRef(this.opts.ref);
    this.contentPresence = new PresenceManager({
      ref: boxWith(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
  }
  static create(opts) {
    return CollapsibleRootContext.set(new _CollapsibleRootState(opts));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode4));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode4), value, true);
  }
  get contentId() {
    return get(__privateGet(this, _contentId2));
  }
  set contentId(value) {
    set(__privateGet(this, _contentId2), value, true);
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  get props() {
    return get(__privateGet(this, _props50));
  }
  set props(value) {
    set(__privateGet(this, _props50), value);
  }
};
_contentNode4 = new WeakMap();
_contentId2 = new WeakMap();
_props50 = new WeakMap();
var CollapsibleRootState = _CollapsibleRootState;
var _present, _originalStyles2, _isMountAnimationPrevented2, _width2, _height2, _snippetProps12, _props51;
var _CollapsibleContentState = class _CollapsibleContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _present, user_derived(() => {
      if (this.opts.hiddenUntilFound.current) return this.root.opts.open.current;
      return this.opts.forceMount.current || this.root.opts.open.current;
    }));
    __privateAdd(this, _originalStyles2);
    __privateAdd(this, _isMountAnimationPrevented2, state(false));
    __privateAdd(this, _width2, state(0));
    __privateAdd(this, _height2, state(0));
    __privateAdd(this, _snippetProps12, user_derived(() => ({ open: this.root.opts.open.current })));
    __privateAdd(this, _props51, user_derived(() => ({
      id: this.opts.id.current,
      style: {
        "--bits-collapsible-content-height": get(__privateGet(this, _height2)) ? `${get(__privateGet(this, _height2))}px` : void 0,
        "--bits-collapsible-content-width": get(__privateGet(this, _width2)) ? `${get(__privateGet(this, _width2))}px` : void 0
      },
      hidden: this.opts.hiddenUntilFound.current && !this.root.opts.open.current ? "until-found" : void 0,
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      [collapsibleAttrs.content]: "",
      ...this.opts.hiddenUntilFound.current && !this.shouldRender ? {} : {
        hidden: this.opts.hiddenUntilFound.current ? !this.shouldRender : this.opts.forceMount.current ? void 0 : !this.shouldRender
      },
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    set(__privateGet(this, _isMountAnimationPrevented2), root18.opts.open.current, true);
    this.root.contentId = this.opts.id.current;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.contentNode = v);
    watch.pre(() => this.opts.id.current, (id) => {
      this.root.contentId = id;
    });
    user_pre_effect(() => {
      const rAF = requestAnimationFrame(() => {
        set(__privateGet(this, _isMountAnimationPrevented2), false);
      });
      return () => {
        cancelAnimationFrame(rAF);
      };
    });
    watch.pre(
      [
        () => this.opts.ref.current,
        () => this.opts.hiddenUntilFound.current
      ],
      ([node, hiddenUntilFound]) => {
        if (!node || !hiddenUntilFound) return;
        const handleBeforeMatch = () => {
          if (this.root.opts.open.current) return;
          requestAnimationFrame(() => {
            this.root.opts.open.current = true;
          });
        };
        return on(node, "beforematch", handleBeforeMatch);
      }
    );
    watch(
      [
        () => this.opts.ref.current,
        () => this.present
      ],
      ([node]) => {
        if (!node) return;
        afterTick(() => {
          if (!this.opts.ref.current) return;
          __privateSet(this, _originalStyles2, __privateGet(this, _originalStyles2) || {
            transitionDuration: node.style.transitionDuration,
            animationName: node.style.animationName
          });
          node.style.transitionDuration = "0s";
          node.style.animationName = "none";
          const rect = node.getBoundingClientRect();
          set(__privateGet(this, _height2), rect.height, true);
          set(__privateGet(this, _width2), rect.width, true);
          if (!get(__privateGet(this, _isMountAnimationPrevented2))) {
            const { animationName, transitionDuration } = __privateGet(this, _originalStyles2);
            node.style.transitionDuration = transitionDuration;
            node.style.animationName = animationName;
          }
        });
      }
    );
  }
  static create(opts) {
    return new _CollapsibleContentState(opts, CollapsibleRootContext.get());
  }
  get present() {
    return get(__privateGet(this, _present));
  }
  set present(value) {
    set(__privateGet(this, _present), value);
  }
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps12));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps12), value);
  }
  get props() {
    return get(__privateGet(this, _props51));
  }
  set props(value) {
    set(__privateGet(this, _props51), value);
  }
};
_present = new WeakMap();
_originalStyles2 = new WeakMap();
_isMountAnimationPrevented2 = new WeakMap();
_width2 = new WeakMap();
_height2 = new WeakMap();
_snippetProps12 = new WeakMap();
_props51 = new WeakMap();
var CollapsibleContentState = _CollapsibleContentState;
var _isDisabled8, _props52;
var _CollapsibleTriggerState = class _CollapsibleTriggerState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled8, user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current));
    __privateAdd(this, _props52, user_derived(() => ({
      id: this.opts.id.current,
      type: "button",
      disabled: get(__privateGet(this, _isDisabled8)),
      "aria-controls": this.root.contentId,
      "aria-expanded": boolToStr(this.root.opts.open.current),
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "data-disabled": boolToEmptyStrOrUndef(get(__privateGet(this, _isDisabled8))),
      [collapsibleAttrs.trigger]: "",
      //
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _CollapsibleTriggerState(opts, CollapsibleRootContext.get());
  }
  onclick(e) {
    if (get(__privateGet(this, _isDisabled8))) return;
    if (e.button !== 0) return e.preventDefault();
    this.root.toggleOpen();
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled8))) return;
    if (e.key === kbd_constants_exports.SPACE || e.key === kbd_constants_exports.ENTER) {
      e.preventDefault();
      this.root.toggleOpen();
    }
  }
  get props() {
    return get(__privateGet(this, _props52));
  }
  set props(value) {
    set(__privateGet(this, _props52), value);
  }
};
_isDisabled8 = new WeakMap();
_props52 = new WeakMap();
var CollapsibleTriggerState = _CollapsibleTriggerState;

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible.svelte
var root_233 = from_html(`<div><!></div>`);
function Collapsible($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), open = prop($$props, "open", 15, false), disabled = prop($$props, "disabled", 3, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "open",
    "disabled",
    "onOpenChange",
    "onOpenChangeComplete"
  ]);
  const rootState = CollapsibleRootState.create({
    open: boxWith(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    disabled: boxWith(() => disabled()),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_233();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible-content.svelte
var root_234 = from_html(`<div><!></div>`);
function Collapsible_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), hiddenUntilFound = prop($$props, "hiddenUntilFound", 3, false), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "ref",
    "forceMount",
    "hiddenUntilFound",
    "children",
    "id"
  ]);
  const contentState = CollapsibleContentState.create({
    id: boxWith(() => id()),
    forceMount: boxWith(() => forceMount()),
    hiddenUntilFound: boxWith(() => hiddenUntilFound()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        ...contentState.snippetProps,
        props: get(mergedProps)
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_234();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible-trigger.svelte
var root_235 = from_html(`<button><!></button>`);
function Collapsible_trigger($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id",
    "disabled"
  ]);
  const triggerState = CollapsibleTriggerState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    disabled: boxWith(() => disabled())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_235();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/combobox/exports.js
var exports_exports9 = {};
__export(exports_exports9, {
  Arrow: () => Arrow,
  Content: () => Select_content,
  ContentStatic: () => Select_content_static,
  Group: () => Select_group,
  GroupHeading: () => Select_group_heading,
  Input: () => Combobox_input,
  Item: () => Select_item,
  Portal: () => Portal,
  Root: () => Combobox,
  ScrollDownButton: () => Select_scroll_down_button,
  ScrollUpButton: () => Select_scroll_up_button,
  Separator: () => Separator,
  Trigger: () => Combobox_trigger,
  Viewport: () => Select_viewport
});

// node_modules/bits-ui/dist/internal/floating-svelte/floating-utils.svelte.js
function get3(valueOrGetValue) {
  return typeof valueOrGetValue === "function" ? valueOrGetValue() : valueOrGetValue;
}
function getDPR(element2) {
  if (typeof window === "undefined") return 1;
  const win = element2.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element2, value) {
  const dpr = getDPR(element2);
  return Math.round(value * dpr) / dpr;
}
function getFloatingContentCSSVars(name) {
  return {
    [`--bits-${name}-content-transform-origin`]: `var(--bits-floating-transform-origin)`,
    [`--bits-${name}-content-available-width`]: `var(--bits-floating-available-width)`,
    [`--bits-${name}-content-available-height`]: `var(--bits-floating-available-height)`,
    [`--bits-${name}-anchor-width`]: `var(--bits-floating-anchor-width)`,
    [`--bits-${name}-anchor-height`]: `var(--bits-floating-anchor-height)`
  };
}

// node_modules/bits-ui/dist/internal/floating-svelte/use-floating.svelte.js
function useFloating(options) {
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = user_derived(() => get3(options.open) ?? true);
  const middlewareOption = user_derived(() => get3(options.middleware));
  const transformOption = user_derived(() => get3(options.transform) ?? true);
  const placementOption = user_derived(() => get3(options.placement) ?? "bottom");
  const strategyOption = user_derived(() => get3(options.strategy) ?? "absolute");
  const sideOffsetOption = user_derived(() => get3(options.sideOffset) ?? 0);
  const alignOffsetOption = user_derived(() => get3(options.alignOffset) ?? 0);
  const reference = options.reference;
  let x = state(0);
  let y = state(0);
  const floating = simpleBox(null);
  let strategy = state(proxy(get(strategyOption)));
  let placement = state(proxy(get(placementOption)));
  let middlewareData = state(proxy({}));
  let isPositioned = state(false);
  const floatingStyles = user_derived(() => {
    const xVal = floating.current ? roundByDPR(floating.current, get(x)) : get(x);
    const yVal = floating.current ? roundByDPR(floating.current, get(y)) : get(y);
    if (get(transformOption)) {
      return {
        position: get(strategy),
        left: "0",
        top: "0",
        transform: `translate(${xVal}px, ${yVal}px)`,
        ...floating.current && getDPR(floating.current) >= 1.5 && { willChange: "transform" }
      };
    }
    return {
      position: get(strategy),
      left: `${xVal}px`,
      top: `${yVal}px`
    };
  });
  let whileElementsMountedCleanup;
  function update2() {
    if (reference.current === null || floating.current === null) return;
    computePosition(reference.current, floating.current, {
      middleware: get(middlewareOption),
      placement: get(placementOption),
      strategy: get(strategyOption)
    }).then((position) => {
      if (!get(openOption) && get(x) !== 0 && get(y) !== 0) {
        const maxExpectedOffset = Math.max(Math.abs(get(sideOffsetOption)), Math.abs(get(alignOffsetOption)), 15);
        if (position.x <= maxExpectedOffset && position.y <= maxExpectedOffset) return;
      }
      set(x, position.x, true);
      set(y, position.y, true);
      set(strategy, position.strategy, true);
      set(placement, position.placement, true);
      set(middlewareData, position.middlewareData, true);
      set(isPositioned, true);
    });
  }
  function cleanup() {
    if (typeof whileElementsMountedCleanup === "function") {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (whileElementsMountedOption === void 0) {
      update2();
      return;
    }
    if (reference.current === null || floating.current === null) return;
    whileElementsMountedCleanup = whileElementsMountedOption(reference.current, floating.current, update2);
  }
  function reset2() {
    if (!get(openOption)) {
      set(isPositioned, false);
    }
  }
  user_effect(update2);
  user_effect(attach);
  user_effect(reset2);
  user_effect(() => cleanup);
  return {
    floating,
    reference,
    get strategy() {
      return get(strategy);
    },
    get placement() {
      return get(placement);
    },
    get middlewareData() {
      return get(middlewareData);
    },
    get isPositioned() {
      return get(isPositioned);
    },
    get floatingStyles() {
      return get(floatingStyles);
    },
    get update() {
      return update2;
    }
  };
}

// node_modules/bits-ui/dist/bits/utilities/floating-layer/use-floating-layer.svelte.js
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var FloatingRootContext = new Context("Floating.Root");
var FloatingContentContext = new Context("Floating.Content");
var FloatingTooltipRootContext = new Context("Floating.Root");
var FloatingRootState = class _FloatingRootState {
  constructor() {
    __publicField(this, "anchorNode", simpleBox(null));
    __publicField(this, "customAnchorNode", simpleBox(null));
    __publicField(this, "triggerNode", simpleBox(null));
    user_effect(() => {
      if (this.customAnchorNode.current) {
        if (typeof this.customAnchorNode.current === "string") {
          this.anchorNode.current = document.querySelector(this.customAnchorNode.current);
        } else {
          this.anchorNode.current = this.customAnchorNode.current;
        }
      } else {
        this.anchorNode.current = this.triggerNode.current;
      }
    });
  }
  static create(tooltip = false) {
    return tooltip ? FloatingTooltipRootContext.set(new _FloatingRootState()) : FloatingRootContext.set(new _FloatingRootState());
  }
};
var _transformedStyle, _updatePositionStrategy, _arrowSize, _arrowWidth, _arrowHeight, _desiredPlacement, _boundary, _hasExplicitBoundaries, _detectOverflowOptions, _availableWidth, _availableHeight, _anchorWidth, _anchorHeight, _middleware, _placedSide, _placedAlign, _arrowX, _arrowY, _cannotCenterArrow, _contentZIndex, _arrowBaseSide, _wrapperProps, _props53, _arrowStyle;
var _FloatingContentState = class _FloatingContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    // nodes
    __publicField(this, "contentRef", simpleBox(null));
    __publicField(this, "wrapperRef", simpleBox(null));
    __publicField(this, "arrowRef", simpleBox(null));
    __publicField(this, "contentAttachment", attachRef(this.contentRef));
    __publicField(this, "wrapperAttachment", attachRef(this.wrapperRef));
    __publicField(this, "arrowAttachment", attachRef(this.arrowRef));
    // ids
    __publicField(this, "arrowId", simpleBox(useId()));
    __privateAdd(this, _transformedStyle, user_derived(() => {
      if (typeof this.opts.style === "string") return cssToStyleObj(this.opts.style);
      if (!this.opts.style) return {};
    }));
    __privateAdd(this, _updatePositionStrategy);
    __privateAdd(this, _arrowSize, new ElementSize(() => this.arrowRef.current ?? void 0));
    __privateAdd(this, _arrowWidth, user_derived(() => {
      var _a;
      return ((_a = __privateGet(this, _arrowSize)) == null ? void 0 : _a.width) ?? 0;
    }));
    __privateAdd(this, _arrowHeight, user_derived(() => {
      var _a;
      return ((_a = __privateGet(this, _arrowSize)) == null ? void 0 : _a.height) ?? 0;
    }));
    __privateAdd(this, _desiredPlacement, user_derived(() => {
      var _a;
      return ((_a = this.opts.side) == null ? void 0 : _a.current) + (this.opts.align.current !== "center" ? `-${this.opts.align.current}` : "");
    }));
    __privateAdd(this, _boundary, user_derived(() => Array.isArray(this.opts.collisionBoundary.current) ? this.opts.collisionBoundary.current : [this.opts.collisionBoundary.current]));
    __privateAdd(this, _hasExplicitBoundaries, user_derived(() => get(__privateGet(this, _boundary)).length > 0));
    __privateAdd(this, _detectOverflowOptions, user_derived(() => ({
      padding: this.opts.collisionPadding.current,
      boundary: get(__privateGet(this, _boundary)).filter(isNotNull),
      altBoundary: this.hasExplicitBoundaries
    })));
    __privateAdd(this, _availableWidth, state(void 0));
    __privateAdd(this, _availableHeight, state(void 0));
    __privateAdd(this, _anchorWidth, state(void 0));
    __privateAdd(this, _anchorHeight, state(void 0));
    __privateAdd(this, _middleware, user_derived(() => [
      offset({
        mainAxis: this.opts.sideOffset.current + get(__privateGet(this, _arrowHeight)),
        alignmentAxis: this.opts.alignOffset.current
      }),
      this.opts.avoidCollisions.current && shift({
        mainAxis: true,
        crossAxis: false,
        limiter: this.opts.sticky.current === "partial" ? limitShift() : void 0,
        ...this.detectOverflowOptions
      }),
      this.opts.avoidCollisions.current && flip({ ...this.detectOverflowOptions }),
      size({
        ...this.detectOverflowOptions,
        apply: ({ rects, availableWidth, availableHeight }) => {
          const { width: anchorWidth, height: anchorHeight } = rects.reference;
          set(__privateGet(this, _availableWidth), availableWidth, true);
          set(__privateGet(this, _availableHeight), availableHeight, true);
          set(__privateGet(this, _anchorWidth), anchorWidth, true);
          set(__privateGet(this, _anchorHeight), anchorHeight, true);
        }
      }),
      this.arrowRef.current && arrow({
        element: this.arrowRef.current,
        padding: this.opts.arrowPadding.current
      }),
      transformOrigin({
        arrowWidth: get(__privateGet(this, _arrowWidth)),
        arrowHeight: get(__privateGet(this, _arrowHeight))
      }),
      this.opts.hideWhenDetached.current && hide({
        strategy: "referenceHidden",
        ...this.detectOverflowOptions
      })
    ].filter(Boolean)));
    __publicField(this, "floating");
    __privateAdd(this, _placedSide, user_derived(() => getSideFromPlacement(this.floating.placement)));
    __privateAdd(this, _placedAlign, user_derived(() => getAlignFromPlacement(this.floating.placement)));
    __privateAdd(this, _arrowX, user_derived(() => {
      var _a;
      return ((_a = this.floating.middlewareData.arrow) == null ? void 0 : _a.x) ?? 0;
    }));
    __privateAdd(this, _arrowY, user_derived(() => {
      var _a;
      return ((_a = this.floating.middlewareData.arrow) == null ? void 0 : _a.y) ?? 0;
    }));
    __privateAdd(this, _cannotCenterArrow, user_derived(() => {
      var _a;
      return ((_a = this.floating.middlewareData.arrow) == null ? void 0 : _a.centerOffset) !== 0;
    }));
    __privateAdd(this, _contentZIndex, state());
    __privateAdd(this, _arrowBaseSide, user_derived(() => OPPOSITE_SIDE[this.placedSide]));
    __privateAdd(this, _wrapperProps, user_derived(() => {
      var _a, _b, _c;
      return {
        id: this.opts.wrapperId.current,
        "data-bits-floating-content-wrapper": "",
        style: {
          ...this.floating.floatingStyles,
          // keep off page when measuring
          transform: this.floating.isPositioned ? this.floating.floatingStyles.transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: this.contentZIndex,
          "--bits-floating-transform-origin": `${(_a = this.floating.middlewareData.transformOrigin) == null ? void 0 : _a.x} ${(_b = this.floating.middlewareData.transformOrigin) == null ? void 0 : _b.y}`,
          "--bits-floating-available-width": `${get(__privateGet(this, _availableWidth))}px`,
          "--bits-floating-available-height": `${get(__privateGet(this, _availableHeight))}px`,
          "--bits-floating-anchor-width": `${get(__privateGet(this, _anchorWidth))}px`,
          "--bits-floating-anchor-height": `${get(__privateGet(this, _anchorHeight))}px`,
          // hide the content if using the hide middleware and should be hidden
          ...((_c = this.floating.middlewareData.hide) == null ? void 0 : _c.referenceHidden) && {
            visibility: "hidden",
            "pointer-events": "none"
          },
          ...get(__privateGet(this, _transformedStyle))
        },
        // Floating UI calculates logical alignment based the `dir` attribute
        dir: this.opts.dir.current,
        ...this.wrapperAttachment
      };
    }));
    __privateAdd(this, _props53, user_derived(() => ({
      "data-side": this.placedSide,
      "data-align": this.placedAlign,
      style: styleToString({ ...get(__privateGet(this, _transformedStyle)) }),
      ...this.contentAttachment
    })));
    __privateAdd(this, _arrowStyle, user_derived(() => ({
      position: "absolute",
      left: this.arrowX ? `${this.arrowX}px` : void 0,
      top: this.arrowY ? `${this.arrowY}px` : void 0,
      [this.arrowBaseSide]: 0,
      "transform-origin": {
        top: "",
        right: "0 0",
        bottom: "center 0",
        left: "100% 0"
      }[this.placedSide],
      transform: {
        top: "translateY(100%)",
        right: "translateY(50%) rotate(90deg) translateX(-50%)",
        bottom: "rotate(180deg)",
        left: "translateY(50%) rotate(-90deg) translateX(50%)"
      }[this.placedSide],
      visibility: this.cannotCenterArrow ? "hidden" : void 0
    })));
    this.opts = opts;
    this.root = root18;
    if (opts.customAnchor) {
      this.root.customAnchorNode.current = opts.customAnchor.current;
    }
    watch(() => opts.customAnchor.current, (customAnchor) => {
      this.root.customAnchorNode.current = customAnchor;
    });
    this.floating = useFloating({
      strategy: () => this.opts.strategy.current,
      placement: () => get(__privateGet(this, _desiredPlacement)),
      middleware: () => this.middleware,
      reference: this.root.anchorNode,
      whileElementsMounted: (...args) => {
        var _a;
        const cleanup = autoUpdate(...args, {
          animationFrame: ((_a = __privateGet(this, _updatePositionStrategy)) == null ? void 0 : _a.current) === "always"
        });
        return cleanup;
      },
      open: () => this.opts.enabled.current,
      sideOffset: () => this.opts.sideOffset.current,
      alignOffset: () => this.opts.alignOffset.current
    });
    user_effect(() => {
      var _a;
      if (!this.floating.isPositioned) return;
      (_a = this.opts.onPlaced) == null ? void 0 : _a.current();
    });
    watch(() => this.contentRef.current, (contentNode) => {
      if (!contentNode) return;
      const win = getWindow(contentNode);
      this.contentZIndex = win.getComputedStyle(contentNode).zIndex;
    });
    user_effect(() => {
      this.floating.floating.current = this.wrapperRef.current;
    });
  }
  static create(opts, tooltip = false) {
    return tooltip ? FloatingContentContext.set(new _FloatingContentState(opts, FloatingTooltipRootContext.get())) : FloatingContentContext.set(new _FloatingContentState(opts, FloatingRootContext.get()));
  }
  get hasExplicitBoundaries() {
    return get(__privateGet(this, _hasExplicitBoundaries));
  }
  set hasExplicitBoundaries(value) {
    set(__privateGet(this, _hasExplicitBoundaries), value);
  }
  get detectOverflowOptions() {
    return get(__privateGet(this, _detectOverflowOptions));
  }
  set detectOverflowOptions(value) {
    set(__privateGet(this, _detectOverflowOptions), value);
  }
  get middleware() {
    return get(__privateGet(this, _middleware));
  }
  set middleware(value) {
    set(__privateGet(this, _middleware), value);
  }
  get placedSide() {
    return get(__privateGet(this, _placedSide));
  }
  set placedSide(value) {
    set(__privateGet(this, _placedSide), value);
  }
  get placedAlign() {
    return get(__privateGet(this, _placedAlign));
  }
  set placedAlign(value) {
    set(__privateGet(this, _placedAlign), value);
  }
  get arrowX() {
    return get(__privateGet(this, _arrowX));
  }
  set arrowX(value) {
    set(__privateGet(this, _arrowX), value);
  }
  get arrowY() {
    return get(__privateGet(this, _arrowY));
  }
  set arrowY(value) {
    set(__privateGet(this, _arrowY), value);
  }
  get cannotCenterArrow() {
    return get(__privateGet(this, _cannotCenterArrow));
  }
  set cannotCenterArrow(value) {
    set(__privateGet(this, _cannotCenterArrow), value);
  }
  get contentZIndex() {
    return get(__privateGet(this, _contentZIndex));
  }
  set contentZIndex(value) {
    set(__privateGet(this, _contentZIndex), value, true);
  }
  get arrowBaseSide() {
    return get(__privateGet(this, _arrowBaseSide));
  }
  set arrowBaseSide(value) {
    set(__privateGet(this, _arrowBaseSide), value);
  }
  get wrapperProps() {
    return get(__privateGet(this, _wrapperProps));
  }
  set wrapperProps(value) {
    set(__privateGet(this, _wrapperProps), value);
  }
  get props() {
    return get(__privateGet(this, _props53));
  }
  set props(value) {
    set(__privateGet(this, _props53), value);
  }
  get arrowStyle() {
    return get(__privateGet(this, _arrowStyle));
  }
  set arrowStyle(value) {
    set(__privateGet(this, _arrowStyle), value);
  }
};
_transformedStyle = new WeakMap();
_updatePositionStrategy = new WeakMap();
_arrowSize = new WeakMap();
_arrowWidth = new WeakMap();
_arrowHeight = new WeakMap();
_desiredPlacement = new WeakMap();
_boundary = new WeakMap();
_hasExplicitBoundaries = new WeakMap();
_detectOverflowOptions = new WeakMap();
_availableWidth = new WeakMap();
_availableHeight = new WeakMap();
_anchorWidth = new WeakMap();
_anchorHeight = new WeakMap();
_middleware = new WeakMap();
_placedSide = new WeakMap();
_placedAlign = new WeakMap();
_arrowX = new WeakMap();
_arrowY = new WeakMap();
_cannotCenterArrow = new WeakMap();
_contentZIndex = new WeakMap();
_arrowBaseSide = new WeakMap();
_wrapperProps = new WeakMap();
_props53 = new WeakMap();
_arrowStyle = new WeakMap();
var FloatingContentState = _FloatingContentState;
var _props54;
var _FloatingArrowState = class _FloatingArrowState {
  constructor(opts, content) {
    __publicField(this, "opts");
    __publicField(this, "content");
    __privateAdd(this, _props54, user_derived(() => ({
      id: this.opts.id.current,
      style: this.content.arrowStyle,
      "data-side": this.content.placedSide,
      ...this.content.arrowAttachment
    })));
    this.opts = opts;
    this.content = content;
  }
  static create(opts) {
    return new _FloatingArrowState(opts, FloatingContentContext.get());
  }
  get props() {
    return get(__privateGet(this, _props54));
  }
  set props(value) {
    set(__privateGet(this, _props54), value);
  }
};
_props54 = new WeakMap();
var FloatingArrowState = _FloatingArrowState;
var FloatingAnchorState = class _FloatingAnchorState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    this.opts = opts;
    this.root = root18;
    if (opts.virtualEl && opts.virtualEl.current) {
      root18.triggerNode = boxFrom(opts.virtualEl.current);
    } else {
      root18.triggerNode = opts.ref;
    }
  }
  static create(opts, tooltip = false) {
    return tooltip ? new _FloatingAnchorState(opts, FloatingTooltipRootContext.get()) : new _FloatingAnchorState(opts, FloatingRootContext.get());
  }
};
function transformOrigin(options) {
  return {
    name: "transformOrigin",
    options,
    fn(data) {
      var _a, _b, _c;
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = ((_a = middlewareData.arrow) == null ? void 0 : _a.centerOffset) !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
      const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
      const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
      let x = "";
      let y = "";
      if (placedSide === "bottom") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x = `${-arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x = `${rects.floating.width + arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: { x, y } };
    }
  };
}
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
function getSideFromPlacement(placement) {
  return getSideAndAlignFromPlacement(placement)[0];
}
function getAlignFromPlacement(placement) {
  return getSideAndAlignFromPlacement(placement)[1];
}

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer.svelte
function Floating_layer($$anchor, $$props) {
  push($$props, true);
  let tooltip = prop($$props, "tooltip", 3, false);
  FloatingRootState.create(tooltip());
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/internal/data-typeahead.svelte.js
var _opts7, _candidateValues, _search3;
var DataTypeahead = class {
  constructor(opts) {
    __privateAdd(this, _opts7);
    __privateAdd(this, _candidateValues, user_derived(() => __privateGet(this, _opts7).candidateValues()));
    __privateAdd(this, _search3);
    __privateSet(this, _opts7, opts);
    __privateSet(this, _search3, boxAutoReset("", {
      afterMs: 1e3,
      getWindow: __privateGet(this, _opts7).getWindow
    }));
    this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this);
    this.resetTypeahead = this.resetTypeahead.bind(this);
  }
  handleTypeaheadSearch(key) {
    if (!__privateGet(this, _opts7).enabled() || !get(__privateGet(this, _candidateValues)).length) return;
    __privateGet(this, _search3).current = __privateGet(this, _search3).current + key;
    const currentItem = __privateGet(this, _opts7).getCurrentItem();
    const currentMatch = get(__privateGet(this, _candidateValues)).find((item) => item === currentItem) ?? "";
    const values = get(__privateGet(this, _candidateValues)).map((item) => item ?? "");
    const nextMatch = getNextMatch(values, __privateGet(this, _search3).current, currentMatch);
    const newItem = get(__privateGet(this, _candidateValues)).find((item) => item === nextMatch);
    if (newItem) {
      __privateGet(this, _opts7).onMatch(newItem);
    }
    return newItem;
  }
  resetTypeahead() {
    __privateGet(this, _search3).current = "";
  }
};
_opts7 = new WeakMap();
_candidateValues = new WeakMap();
_search3 = new WeakMap();

// node_modules/bits-ui/dist/bits/select/select.svelte.js
var INTERACTION_KEYS = [
  kbd_constants_exports.ARROW_LEFT,
  kbd_constants_exports.ESCAPE,
  kbd_constants_exports.ARROW_RIGHT,
  kbd_constants_exports.SHIFT,
  kbd_constants_exports.CAPS_LOCK,
  kbd_constants_exports.CONTROL,
  kbd_constants_exports.ALT,
  kbd_constants_exports.META,
  kbd_constants_exports.ENTER,
  kbd_constants_exports.F1,
  kbd_constants_exports.F2,
  kbd_constants_exports.F3,
  kbd_constants_exports.F4,
  kbd_constants_exports.F5,
  kbd_constants_exports.F6,
  kbd_constants_exports.F7,
  kbd_constants_exports.F8,
  kbd_constants_exports.F9,
  kbd_constants_exports.F10,
  kbd_constants_exports.F11,
  kbd_constants_exports.F12
];
var FIRST_KEYS3 = [kbd_constants_exports.ARROW_DOWN, kbd_constants_exports.PAGE_UP, kbd_constants_exports.HOME];
var LAST_KEYS3 = [kbd_constants_exports.ARROW_UP, kbd_constants_exports.PAGE_DOWN, kbd_constants_exports.END];
var FIRST_LAST_KEYS3 = [...FIRST_KEYS3, ...LAST_KEYS3];
var SELECTION_KEYS3 = [kbd_constants_exports.ENTER, kbd_constants_exports.SPACE];
var selectAttrs = createBitsAttrs({
  component: "select",
  parts: [
    "trigger",
    "content",
    "item",
    "viewport",
    "scroll-up-button",
    "scroll-down-button",
    "group",
    "group-label",
    "separator",
    "arrow",
    "input",
    "content-wrapper",
    "item-text",
    "value"
  ]
});
var SelectRootContext = new Context("Select.Root | Combobox.Root");
var SelectGroupContext = new Context("Select.Group | Combobox.Group");
var SelectContentContext = new Context("Select.Content | Combobox.Content");
var _touchedInput, _inputNode, _contentNode5, _viewportNode, _triggerNode3, _valueId, _highlightedNode, _highlightedValue, _highlightedId, _highlightedLabel;
var SelectBaseRootState = class {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _touchedInput, state(false));
    __privateAdd(this, _inputNode, state(null));
    __privateAdd(this, _contentNode5, state(null));
    __publicField(this, "contentPresence");
    __privateAdd(this, _viewportNode, state(null));
    __privateAdd(this, _triggerNode3, state(null));
    __privateAdd(this, _valueId, state(""));
    __privateAdd(this, _highlightedNode, state(null));
    __privateAdd(this, _highlightedValue, user_derived(() => {
      if (!this.highlightedNode) return null;
      return this.highlightedNode.getAttribute("data-value");
    }));
    __privateAdd(this, _highlightedId, user_derived(() => {
      if (!this.highlightedNode) return void 0;
      return this.highlightedNode.id;
    }));
    __privateAdd(this, _highlightedLabel, user_derived(() => {
      if (!this.highlightedNode) return null;
      return this.highlightedNode.getAttribute("data-label");
    }));
    __publicField(this, "isUsingKeyboard", false);
    __publicField(this, "isCombobox", false);
    __publicField(this, "domContext", new DOMContext(() => null));
    __publicField(this, "getBitsAttr", (part) => {
      return selectAttrs.getAttr(part, this.isCombobox ? "combobox" : void 0);
    });
    this.opts = opts;
    this.isCombobox = opts.isCombobox;
    this.contentPresence = new PresenceManager({
      ref: boxWith(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    user_pre_effect(() => {
      if (!this.opts.open.current) {
        this.setHighlightedNode(null);
      }
    });
  }
  get touchedInput() {
    return get(__privateGet(this, _touchedInput));
  }
  set touchedInput(value) {
    set(__privateGet(this, _touchedInput), value, true);
  }
  get inputNode() {
    return get(__privateGet(this, _inputNode));
  }
  set inputNode(value) {
    set(__privateGet(this, _inputNode), value, true);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode5));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode5), value, true);
  }
  get viewportNode() {
    return get(__privateGet(this, _viewportNode));
  }
  set viewportNode(value) {
    set(__privateGet(this, _viewportNode), value, true);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode3));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode3), value, true);
  }
  get valueId() {
    return get(__privateGet(this, _valueId));
  }
  set valueId(value) {
    set(__privateGet(this, _valueId), value, true);
  }
  get highlightedNode() {
    return get(__privateGet(this, _highlightedNode));
  }
  set highlightedNode(value) {
    set(__privateGet(this, _highlightedNode), value, true);
  }
  get highlightedValue() {
    return get(__privateGet(this, _highlightedValue));
  }
  set highlightedValue(value) {
    set(__privateGet(this, _highlightedValue), value);
  }
  get highlightedId() {
    return get(__privateGet(this, _highlightedId));
  }
  set highlightedId(value) {
    set(__privateGet(this, _highlightedId), value);
  }
  get highlightedLabel() {
    return get(__privateGet(this, _highlightedLabel));
  }
  set highlightedLabel(value) {
    set(__privateGet(this, _highlightedLabel), value);
  }
  setHighlightedNode(node, initial = false) {
    this.highlightedNode = node;
    if (node && (this.isUsingKeyboard || initial)) {
      node.scrollIntoView({ block: this.opts.scrollAlignment.current });
    }
  }
  getCandidateNodes() {
    const node = this.contentNode;
    if (!node) return [];
    return Array.from(node.querySelectorAll(`[${this.getBitsAttr("item")}]:not([data-disabled])`));
  }
  setHighlightedToFirstCandidate(initial = false) {
    this.setHighlightedNode(null);
    let nodes = this.getCandidateNodes();
    if (!nodes.length) return;
    if (this.viewportNode) {
      const viewportRect = this.viewportNode.getBoundingClientRect();
      nodes = nodes.filter((node) => {
        if (!this.viewportNode) return false;
        const nodeRect = node.getBoundingClientRect();
        const isNodeFullyVisible = nodeRect.right < viewportRect.right && nodeRect.left > viewportRect.left && nodeRect.bottom < viewportRect.bottom && nodeRect.top > viewportRect.top;
        return isNodeFullyVisible;
      });
    }
    this.setHighlightedNode(nodes[0], initial);
  }
  getNodeByValue(value) {
    const candidateNodes = this.getCandidateNodes();
    return candidateNodes.find((node) => node.dataset.value === value) ?? null;
  }
  setOpen(open) {
    this.opts.open.current = open;
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  handleOpen() {
    this.setOpen(true);
  }
  handleClose() {
    this.setHighlightedNode(null);
    this.setOpen(false);
  }
  toggleMenu() {
    this.toggleOpen();
  }
};
_touchedInput = new WeakMap();
_inputNode = new WeakMap();
_contentNode5 = new WeakMap();
_viewportNode = new WeakMap();
_triggerNode3 = new WeakMap();
_valueId = new WeakMap();
_highlightedNode = new WeakMap();
_highlightedValue = new WeakMap();
_highlightedId = new WeakMap();
_highlightedLabel = new WeakMap();
var _hasValue, _currentLabel, _candidateLabels, _dataTypeaheadEnabled;
var SelectSingleRootState = class extends SelectBaseRootState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", false);
    __privateAdd(this, _hasValue, user_derived(() => this.opts.value.current !== ""));
    __privateAdd(this, _currentLabel, user_derived(() => {
      var _a;
      if (!this.opts.items.current.length) return "";
      return ((_a = this.opts.items.current.find((item) => item.value === this.opts.value.current)) == null ? void 0 : _a.label) ?? "";
    }));
    __privateAdd(this, _candidateLabels, user_derived(() => {
      if (!this.opts.items.current.length) return [];
      const filteredItems = this.opts.items.current.filter((item) => !item.disabled);
      return filteredItems.map((item) => item.label);
    }));
    __privateAdd(this, _dataTypeaheadEnabled, user_derived(() => {
      if (this.isMulti) return false;
      if (this.opts.items.current.length === 0) return false;
      return true;
    }));
    this.opts = opts;
    user_effect(() => {
      if (!this.opts.open.current && this.highlightedNode) {
        this.setHighlightedNode(null);
      }
    });
    watch(() => this.opts.open.current, () => {
      if (!this.opts.open.current) return;
      this.setInitialHighlightedNode();
    });
  }
  get hasValue() {
    return get(__privateGet(this, _hasValue));
  }
  set hasValue(value) {
    set(__privateGet(this, _hasValue), value);
  }
  get currentLabel() {
    return get(__privateGet(this, _currentLabel));
  }
  set currentLabel(value) {
    set(__privateGet(this, _currentLabel), value);
  }
  get candidateLabels() {
    return get(__privateGet(this, _candidateLabels));
  }
  set candidateLabels(value) {
    set(__privateGet(this, _candidateLabels), value);
  }
  get dataTypeaheadEnabled() {
    return get(__privateGet(this, _dataTypeaheadEnabled));
  }
  set dataTypeaheadEnabled(value) {
    set(__privateGet(this, _dataTypeaheadEnabled), value);
  }
  includesItem(itemValue) {
    return this.opts.value.current === itemValue;
  }
  toggleItem(itemValue, itemLabel = itemValue) {
    const newValue = this.includesItem(itemValue) ? "" : itemValue;
    this.opts.value.current = newValue;
    if (newValue !== "") {
      this.opts.inputValue.current = itemLabel;
    }
  }
  setInitialHighlightedNode() {
    afterTick(() => {
      if (this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode)) return;
      if (this.opts.value.current !== "") {
        const node = this.getNodeByValue(this.opts.value.current);
        if (node) {
          this.setHighlightedNode(node, true);
          return;
        }
      }
      this.setHighlightedToFirstCandidate(true);
    });
  }
};
_hasValue = new WeakMap();
_currentLabel = new WeakMap();
_candidateLabels = new WeakMap();
_dataTypeaheadEnabled = new WeakMap();
var _hasValue2;
var SelectMultipleRootState = class extends SelectBaseRootState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", true);
    __privateAdd(this, _hasValue2, user_derived(() => this.opts.value.current.length > 0));
    this.opts = opts;
    user_effect(() => {
      if (!this.opts.open.current && this.highlightedNode) {
        this.setHighlightedNode(null);
      }
    });
    watch(() => this.opts.open.current, () => {
      if (!this.opts.open.current) return;
      this.setInitialHighlightedNode();
    });
  }
  get hasValue() {
    return get(__privateGet(this, _hasValue2));
  }
  set hasValue(value) {
    set(__privateGet(this, _hasValue2), value);
  }
  includesItem(itemValue) {
    return this.opts.value.current.includes(itemValue);
  }
  toggleItem(itemValue, itemLabel = itemValue) {
    if (this.includesItem(itemValue)) {
      this.opts.value.current = this.opts.value.current.filter((v) => v !== itemValue);
    } else {
      this.opts.value.current = [...this.opts.value.current, itemValue];
    }
    this.opts.inputValue.current = itemLabel;
  }
  setInitialHighlightedNode() {
    afterTick(() => {
      if (!this.domContext) return;
      if (this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode)) return;
      if (this.opts.value.current.length && this.opts.value.current[0] !== "") {
        const node = this.getNodeByValue(this.opts.value.current[0]);
        if (node) {
          this.setHighlightedNode(node, true);
          return;
        }
      }
      this.setHighlightedToFirstCandidate(true);
    });
  }
};
_hasValue2 = new WeakMap();
var SelectRootState = class {
  static create(props) {
    const { type, ...rest } = props;
    const rootState = type === "single" ? new SelectSingleRootState(rest) : new SelectMultipleRootState(rest);
    return SelectRootContext.set(rootState);
  }
};
var _props55;
var _SelectInputState = class _SelectInputState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props55, user_derived(() => ({
      id: this.opts.id.current,
      role: "combobox",
      disabled: this.root.opts.disabled.current ? true : void 0,
      "aria-activedescendant": this.root.highlightedId,
      "aria-autocomplete": "list",
      "aria-expanded": boolToStr(this.root.opts.open.current),
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      onkeydown: this.onkeydown,
      oninput: this.oninput,
      [this.root.getBitsAttr("input")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.inputNode = v);
    this.root.domContext = new DOMContext(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.oninput = this.oninput.bind(this);
    watch(
      [
        () => this.root.opts.value.current,
        () => this.opts.clearOnDeselect.current
      ],
      ([value, clearOnDeselect], [prevValue]) => {
        if (!clearOnDeselect) return;
        if (Array.isArray(value) && Array.isArray(prevValue)) {
          if (value.length === 0 && prevValue.length !== 0) {
            this.root.opts.inputValue.current = "";
          }
        } else if (value === "" && prevValue !== "") {
          this.root.opts.inputValue.current = "";
        }
      }
    );
  }
  static create(opts) {
    return new _SelectInputState(opts, SelectRootContext.get());
  }
  onkeydown(e) {
    this.root.isUsingKeyboard = true;
    if (e.key === kbd_constants_exports.ESCAPE) return;
    if (e.key === kbd_constants_exports.ARROW_UP || e.key === kbd_constants_exports.ARROW_DOWN) e.preventDefault();
    if (!this.root.opts.open.current) {
      if (INTERACTION_KEYS.includes(e.key)) return;
      if (e.key === kbd_constants_exports.TAB) return;
      if (e.key === kbd_constants_exports.BACKSPACE && this.root.opts.inputValue.current === "") return;
      this.root.handleOpen();
      if (this.root.hasValue) return;
      const candidateNodes = this.root.getCandidateNodes();
      if (!candidateNodes.length) return;
      if (e.key === kbd_constants_exports.ARROW_DOWN) {
        const firstCandidate = candidateNodes[0];
        this.root.setHighlightedNode(firstCandidate);
      } else if (e.key === kbd_constants_exports.ARROW_UP) {
        const lastCandidate = candidateNodes[candidateNodes.length - 1];
        this.root.setHighlightedNode(lastCandidate);
      }
      return;
    }
    if (e.key === kbd_constants_exports.TAB) {
      this.root.handleClose();
      return;
    }
    if (e.key === kbd_constants_exports.ENTER && !e.isComposing) {
      e.preventDefault();
      const isCurrentSelectedValue = this.root.highlightedValue === this.root.opts.value.current;
      if (!this.root.opts.allowDeselect.current && isCurrentSelectedValue && !this.root.isMulti) {
        this.root.handleClose();
        return;
      }
      if (this.root.highlightedValue && this.root.highlightedNode && this.root.highlightedNode.isConnected) {
        this.root.toggleItem(this.root.highlightedValue, this.root.highlightedLabel ?? void 0);
      }
      if (!this.root.isMulti && !isCurrentSelectedValue) {
        this.root.handleClose();
      }
    }
    if (e.key === kbd_constants_exports.ARROW_UP && e.altKey) {
      this.root.handleClose();
    }
    if (FIRST_LAST_KEYS3.includes(e.key)) {
      e.preventDefault();
      const candidateNodes = this.root.getCandidateNodes();
      const currHighlightedNode = this.root.highlightedNode;
      const currIndex = currHighlightedNode ? candidateNodes.indexOf(currHighlightedNode) : -1;
      const loop = this.root.opts.loop.current;
      let nextItem;
      if (e.key === kbd_constants_exports.ARROW_DOWN) {
        nextItem = next2(candidateNodes, currIndex, loop);
      } else if (e.key === kbd_constants_exports.ARROW_UP) {
        nextItem = prev(candidateNodes, currIndex, loop);
      } else if (e.key === kbd_constants_exports.PAGE_DOWN) {
        nextItem = forward(candidateNodes, currIndex, 10, loop);
      } else if (e.key === kbd_constants_exports.PAGE_UP) {
        nextItem = backward(candidateNodes, currIndex, 10, loop);
      } else if (e.key === kbd_constants_exports.HOME) {
        nextItem = candidateNodes[0];
      } else if (e.key === kbd_constants_exports.END) {
        nextItem = candidateNodes[candidateNodes.length - 1];
      }
      if (!nextItem) return;
      this.root.setHighlightedNode(nextItem);
      return;
    }
    if (INTERACTION_KEYS.includes(e.key)) return;
    if (!this.root.highlightedNode) {
      this.root.setHighlightedToFirstCandidate();
    }
  }
  oninput(e) {
    this.root.opts.inputValue.current = e.currentTarget.value;
    this.root.setHighlightedToFirstCandidate();
  }
  get props() {
    return get(__privateGet(this, _props55));
  }
  set props(value) {
    set(__privateGet(this, _props55), value);
  }
};
_props55 = new WeakMap();
var SelectInputState = _SelectInputState;
var _props56;
var _SelectComboTriggerState = class _SelectComboTriggerState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props56, user_derived(() => ({
      id: this.opts.id.current,
      disabled: this.root.opts.disabled.current ? true : void 0,
      "aria-haspopup": "listbox",
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      [this.root.getBitsAttr("trigger")]: "",
      onpointerdown: this.onpointerdown,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onpointerdown = this.onpointerdown.bind(this);
  }
  static create(opts) {
    return new _SelectComboTriggerState(opts, SelectRootContext.get());
  }
  onkeydown(e) {
    var _a;
    if (!this.root.domContext) return;
    if (e.key === kbd_constants_exports.ENTER || e.key === kbd_constants_exports.SPACE) {
      e.preventDefault();
      if (this.root.domContext.getActiveElement() !== this.root.inputNode) {
        (_a = this.root.inputNode) == null ? void 0 : _a.focus();
      }
      this.root.toggleMenu();
    }
  }
  /**
   * `pointerdown` fires before the `focus` event, so we can prevent the default
   * behavior of focusing the button and keep focus on the input.
   */
  onpointerdown(e) {
    var _a;
    if (this.root.opts.disabled.current || !this.root.domContext) return;
    e.preventDefault();
    if (this.root.domContext.getActiveElement() !== this.root.inputNode) {
      (_a = this.root.inputNode) == null ? void 0 : _a.focus();
    }
    this.root.toggleMenu();
  }
  get props() {
    return get(__privateGet(this, _props56));
  }
  set props(value) {
    set(__privateGet(this, _props56), value);
  }
};
_props56 = new WeakMap();
var SelectComboTriggerState = _SelectComboTriggerState;
var _domTypeahead, _dataTypeahead, _SelectTriggerState_instances, handleOpen_fn2, handlePointerOpen_fn, handleKeyboardSelection_fn, _props57;
var _SelectTriggerState = class _SelectTriggerState {
  constructor(opts, root18) {
    __privateAdd(this, _SelectTriggerState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _domTypeahead);
    __privateAdd(this, _dataTypeahead);
    __privateAdd(this, _props57, user_derived(() => ({
      id: this.opts.id.current,
      disabled: this.root.opts.disabled.current ? true : void 0,
      "aria-haspopup": "listbox",
      "aria-expanded": boolToStr(this.root.opts.open.current),
      "aria-activedescendant": this.root.highlightedId,
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      "data-placeholder": this.root.hasValue ? void 0 : "",
      [this.root.getBitsAttr("trigger")]: "",
      onpointerdown: this.onpointerdown,
      onkeydown: this.onkeydown,
      onclick: this.onclick,
      onpointerup: this.onpointerup,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.triggerNode = v);
    this.root.domContext = new DOMContext(opts.ref);
    __privateSet(this, _domTypeahead, new DOMTypeahead({
      getCurrentItem: () => this.root.highlightedNode,
      onMatch: (node) => {
        this.root.setHighlightedNode(node);
      },
      getActiveElement: () => this.root.domContext.getActiveElement(),
      getWindow: () => this.root.domContext.getWindow()
    }));
    __privateSet(this, _dataTypeahead, new DataTypeahead({
      getCurrentItem: () => {
        if (this.root.isMulti) return "";
        return this.root.currentLabel;
      },
      onMatch: (label) => {
        if (this.root.isMulti) return;
        if (!this.root.opts.items.current) return;
        const matchedItem = this.root.opts.items.current.find((item) => item.label === label);
        if (!matchedItem) return;
        this.root.opts.value.current = matchedItem.value;
      },
      enabled: () => !this.root.isMulti && this.root.dataTypeaheadEnabled,
      candidateValues: () => this.root.isMulti ? [] : this.root.candidateLabels,
      getWindow: () => this.root.domContext.getWindow()
    }));
    this.onkeydown = this.onkeydown.bind(this);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
    this.onclick = this.onclick.bind(this);
  }
  static create(opts) {
    return new _SelectTriggerState(opts, SelectRootContext.get());
  }
  onkeydown(e) {
    this.root.isUsingKeyboard = true;
    if (e.key === kbd_constants_exports.ARROW_UP || e.key === kbd_constants_exports.ARROW_DOWN) e.preventDefault();
    if (!this.root.opts.open.current) {
      if (e.key === kbd_constants_exports.ENTER || e.key === kbd_constants_exports.SPACE || e.key === kbd_constants_exports.ARROW_DOWN || e.key === kbd_constants_exports.ARROW_UP) {
        e.preventDefault();
        this.root.handleOpen();
      } else if (!this.root.isMulti && this.root.dataTypeaheadEnabled) {
        __privateGet(this, _dataTypeahead).handleTypeaheadSearch(e.key);
        return;
      }
      if (this.root.hasValue) return;
      const candidateNodes2 = this.root.getCandidateNodes();
      if (!candidateNodes2.length) return;
      if (e.key === kbd_constants_exports.ARROW_DOWN) {
        const firstCandidate = candidateNodes2[0];
        this.root.setHighlightedNode(firstCandidate);
      } else if (e.key === kbd_constants_exports.ARROW_UP) {
        const lastCandidate = candidateNodes2[candidateNodes2.length - 1];
        this.root.setHighlightedNode(lastCandidate);
      }
      return;
    }
    if (e.key === kbd_constants_exports.TAB) {
      this.root.handleClose();
      return;
    }
    if ((e.key === kbd_constants_exports.ENTER || // if we're currently "typing ahead", we don't want to select the item
    // just yet as the item the user is trying to get to may have a space in it,
    // so we defer handling the close for this case until further down
    e.key === kbd_constants_exports.SPACE && __privateGet(this, _domTypeahead).search === "") && !e.isComposing) {
      e.preventDefault();
      const shouldReturn = __privateMethod(this, _SelectTriggerState_instances, handleKeyboardSelection_fn).call(this);
      if (shouldReturn) return;
    }
    if (e.key === kbd_constants_exports.ARROW_UP && e.altKey) {
      this.root.handleClose();
    }
    if (FIRST_LAST_KEYS3.includes(e.key)) {
      e.preventDefault();
      const candidateNodes2 = this.root.getCandidateNodes();
      const currHighlightedNode = this.root.highlightedNode;
      const currIndex = currHighlightedNode ? candidateNodes2.indexOf(currHighlightedNode) : -1;
      const loop = this.root.opts.loop.current;
      let nextItem;
      if (e.key === kbd_constants_exports.ARROW_DOWN) {
        nextItem = next2(candidateNodes2, currIndex, loop);
      } else if (e.key === kbd_constants_exports.ARROW_UP) {
        nextItem = prev(candidateNodes2, currIndex, loop);
      } else if (e.key === kbd_constants_exports.PAGE_DOWN) {
        nextItem = forward(candidateNodes2, currIndex, 10, loop);
      } else if (e.key === kbd_constants_exports.PAGE_UP) {
        nextItem = backward(candidateNodes2, currIndex, 10, loop);
      } else if (e.key === kbd_constants_exports.HOME) {
        nextItem = candidateNodes2[0];
      } else if (e.key === kbd_constants_exports.END) {
        nextItem = candidateNodes2[candidateNodes2.length - 1];
      }
      if (!nextItem) return;
      this.root.setHighlightedNode(nextItem);
      return;
    }
    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
    const isCharacterKey = e.key.length === 1;
    const isSpaceKey = e.key === kbd_constants_exports.SPACE;
    const candidateNodes = this.root.getCandidateNodes();
    if (e.key === kbd_constants_exports.TAB) return;
    if (!isModifierKey && (isCharacterKey || isSpaceKey)) {
      const matchedNode = __privateGet(this, _domTypeahead).handleTypeaheadSearch(e.key, candidateNodes);
      if (!matchedNode && isSpaceKey) {
        e.preventDefault();
        __privateMethod(this, _SelectTriggerState_instances, handleKeyboardSelection_fn).call(this);
      }
      return;
    }
    if (!this.root.highlightedNode) {
      this.root.setHighlightedToFirstCandidate();
    }
  }
  onclick(e) {
    const currTarget = e.currentTarget;
    currTarget.focus();
  }
  onpointerdown(e) {
    if (this.root.opts.disabled.current) return;
    if (e.pointerType === "touch") return e.preventDefault();
    const target = e.target;
    if (target == null ? void 0 : target.hasPointerCapture(e.pointerId)) {
      target == null ? void 0 : target.releasePointerCapture(e.pointerId);
    }
    if (e.button === 0 && e.ctrlKey === false) {
      if (this.root.opts.open.current === false) {
        __privateMethod(this, _SelectTriggerState_instances, handlePointerOpen_fn).call(this, e);
      } else {
        this.root.handleClose();
      }
    }
  }
  onpointerup(e) {
    if (this.root.opts.disabled.current) return;
    e.preventDefault();
    if (e.pointerType === "touch") {
      if (this.root.opts.open.current === false) {
        __privateMethod(this, _SelectTriggerState_instances, handlePointerOpen_fn).call(this, e);
      } else {
        this.root.handleClose();
      }
    }
  }
  get props() {
    return get(__privateGet(this, _props57));
  }
  set props(value) {
    set(__privateGet(this, _props57), value);
  }
};
_domTypeahead = new WeakMap();
_dataTypeahead = new WeakMap();
_SelectTriggerState_instances = new WeakSet();
handleOpen_fn2 = function() {
  this.root.opts.open.current = true;
  __privateGet(this, _dataTypeahead).resetTypeahead();
  __privateGet(this, _domTypeahead).resetTypeahead();
};
handlePointerOpen_fn = function(_) {
  __privateMethod(this, _SelectTriggerState_instances, handleOpen_fn2).call(this);
};
/**
 * Logic used to handle keyboard selection/deselection.
 *
 * If it returns true, it means the item was selected and whatever is calling
 * this function should return early
 *
 */
handleKeyboardSelection_fn = function() {
  const isCurrentSelectedValue = this.root.highlightedValue === this.root.opts.value.current;
  if (!this.root.opts.allowDeselect.current && isCurrentSelectedValue && !this.root.isMulti) {
    this.root.handleClose();
    return true;
  }
  if (this.root.highlightedValue !== null) {
    this.root.toggleItem(this.root.highlightedValue, this.root.highlightedLabel ?? void 0);
  }
  if (!this.root.isMulti && !isCurrentSelectedValue) {
    this.root.handleClose();
    return true;
  }
  return false;
};
_props57 = new WeakMap();
var SelectTriggerState = _SelectTriggerState;
var _isPositioned, _styles, _snippetProps13, _props58;
var _SelectContentState = class _SelectContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isPositioned, state(false));
    __publicField(this, "domContext");
    __privateAdd(this, _styles, user_derived(() => {
      return getFloatingContentCSSVars(this.root.isCombobox ? "combobox" : "select");
    }));
    __publicField(this, "onInteractOutside", (e) => {
      if (e.target === this.root.triggerNode || e.target === this.root.inputNode) {
        e.preventDefault();
        return;
      }
      this.opts.onInteractOutside.current(e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onEscapeKeydown", (e) => {
      this.opts.onEscapeKeydown.current(e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onOpenAutoFocus", (e) => {
      e.preventDefault();
    });
    __publicField(this, "onCloseAutoFocus", (e) => {
      e.preventDefault();
    });
    __privateAdd(this, _snippetProps13, user_derived(() => ({ open: this.root.opts.open.current })));
    __privateAdd(this, _props58, user_derived(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-multiselectable": this.root.isMulti ? "true" : void 0,
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      [this.root.getBitsAttr("content")]: "",
      style: {
        display: "flex",
        flexDirection: "column",
        outline: "none",
        boxSizing: "border-box",
        pointerEvents: "auto",
        ...get(__privateGet(this, _styles))
      },
      onpointermove: this.onpointermove,
      ...this.attachment
    })));
    __publicField(this, "popperProps", {
      onInteractOutside: this.onInteractOutside,
      onEscapeKeydown: this.onEscapeKeydown,
      onOpenAutoFocus: this.onOpenAutoFocus,
      onCloseAutoFocus: this.onCloseAutoFocus,
      trapFocus: false,
      loop: false,
      onPlaced: () => {
        if (this.root.opts.open.current) {
          this.isPositioned = true;
        }
      }
    });
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.contentNode = v);
    this.domContext = new DOMContext(this.opts.ref);
    if (this.root.domContext === null) {
      this.root.domContext = this.domContext;
    }
    onDestroyEffect(() => {
      this.root.contentNode = null;
      this.isPositioned = false;
    });
    watch(() => this.root.opts.open.current, () => {
      if (this.root.opts.open.current) return;
      this.isPositioned = false;
    });
    this.onpointermove = this.onpointermove.bind(this);
  }
  static create(opts) {
    return SelectContentContext.set(new _SelectContentState(opts, SelectRootContext.get()));
  }
  get isPositioned() {
    return get(__privateGet(this, _isPositioned));
  }
  set isPositioned(value) {
    set(__privateGet(this, _isPositioned), value, true);
  }
  onpointermove(_) {
    this.root.isUsingKeyboard = false;
  }
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps13));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps13), value);
  }
  get props() {
    return get(__privateGet(this, _props58));
  }
  set props(value) {
    set(__privateGet(this, _props58), value);
  }
};
_isPositioned = new WeakMap();
_styles = new WeakMap();
_snippetProps13 = new WeakMap();
_props58 = new WeakMap();
var SelectContentState = _SelectContentState;
var _isSelected, _isHighlighted, _mounted2, _snippetProps14, _props59;
var _SelectItemState = class _SelectItemState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isSelected, user_derived(() => this.root.includesItem(this.opts.value.current)));
    __privateAdd(this, _isHighlighted, user_derived(() => this.root.highlightedValue === this.opts.value.current));
    __publicField(this, "prevHighlighted", new Previous(() => this.isHighlighted));
    __privateAdd(this, _mounted2, state(false));
    __privateAdd(this, _snippetProps14, user_derived(() => ({
      selected: this.isSelected,
      highlighted: this.isHighlighted
    })));
    __privateAdd(this, _props59, user_derived(() => ({
      id: this.opts.id.current,
      role: "option",
      "aria-selected": this.root.includesItem(this.opts.value.current) ? "true" : void 0,
      "data-value": this.opts.value.current,
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      "data-highlighted": this.root.highlightedValue === this.opts.value.current && !this.opts.disabled.current ? "" : void 0,
      "data-selected": this.root.includesItem(this.opts.value.current) ? "" : void 0,
      "data-label": this.opts.label.current,
      [this.root.getBitsAttr("item")]: "",
      onpointermove: this.onpointermove,
      onpointerdown: this.onpointerdown,
      onpointerup: this.onpointerup,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    watch(
      [
        () => this.isHighlighted,
        () => this.prevHighlighted.current
      ],
      () => {
        if (this.isHighlighted) {
          this.opts.onHighlight.current();
        } else if (this.prevHighlighted.current) {
          this.opts.onUnhighlight.current();
        }
      }
    );
    watch(() => this.mounted, () => {
      if (!this.mounted) return;
      this.root.setInitialHighlightedNode();
    });
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
  }
  static create(opts) {
    return new _SelectItemState(opts, SelectRootContext.get());
  }
  get isSelected() {
    return get(__privateGet(this, _isSelected));
  }
  set isSelected(value) {
    set(__privateGet(this, _isSelected), value);
  }
  get isHighlighted() {
    return get(__privateGet(this, _isHighlighted));
  }
  set isHighlighted(value) {
    set(__privateGet(this, _isHighlighted), value);
  }
  get mounted() {
    return get(__privateGet(this, _mounted2));
  }
  set mounted(value) {
    set(__privateGet(this, _mounted2), value, true);
  }
  handleSelect() {
    if (this.opts.disabled.current) return;
    const isCurrentSelectedValue = this.opts.value.current === this.root.opts.value.current;
    if (!this.root.opts.allowDeselect.current && isCurrentSelectedValue && !this.root.isMulti) {
      this.root.handleClose();
      return;
    }
    this.root.toggleItem(this.opts.value.current, this.opts.label.current);
    if (!this.root.isMulti && !isCurrentSelectedValue) {
      this.root.handleClose();
    }
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps14));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps14), value);
  }
  onpointerdown(e) {
    e.preventDefault();
  }
  /**
   * Using `pointerup` instead of `click` allows power users to pointerdown
   * the trigger, then release pointerup on an item to select it vs having to do
   * multiple clicks.
   */
  onpointerup(e) {
    if (e.defaultPrevented || !this.opts.ref.current) return;
    if (e.pointerType === "touch" && !isIOS) {
      on(
        this.opts.ref.current,
        "click",
        () => {
          this.handleSelect();
          this.root.setHighlightedNode(this.opts.ref.current);
        },
        { once: true }
      );
      return;
    }
    e.preventDefault();
    this.handleSelect();
    if (e.pointerType === "touch") {
      this.root.setHighlightedNode(this.opts.ref.current);
    }
  }
  onpointermove(e) {
    if (e.pointerType === "touch") return;
    if (this.root.highlightedNode !== this.opts.ref.current) {
      this.root.setHighlightedNode(this.opts.ref.current);
    }
  }
  get props() {
    return get(__privateGet(this, _props59));
  }
  set props(value) {
    set(__privateGet(this, _props59), value);
  }
};
_isSelected = new WeakMap();
_isHighlighted = new WeakMap();
_mounted2 = new WeakMap();
_snippetProps14 = new WeakMap();
_props59 = new WeakMap();
var SelectItemState = _SelectItemState;
var _labelNode, _props60;
var _SelectGroupState = class _SelectGroupState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _labelNode, state(null));
    __publicField(this, "attachment");
    __privateAdd(this, _props60, user_derived(() => {
      var _a;
      return {
        id: this.opts.id.current,
        role: "group",
        [this.root.getBitsAttr("group")]: "",
        "aria-labelledby": ((_a = this.labelNode) == null ? void 0 : _a.id) ?? void 0,
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return SelectGroupContext.set(new _SelectGroupState(opts, SelectRootContext.get()));
  }
  get labelNode() {
    return get(__privateGet(this, _labelNode));
  }
  set labelNode(value) {
    set(__privateGet(this, _labelNode), value, true);
  }
  get props() {
    return get(__privateGet(this, _props60));
  }
  set props(value) {
    set(__privateGet(this, _props60), value);
  }
};
_labelNode = new WeakMap();
_props60 = new WeakMap();
var SelectGroupState = _SelectGroupState;
var _props61;
var _SelectGroupHeadingState = class _SelectGroupHeadingState {
  constructor(opts, group) {
    __publicField(this, "opts");
    __publicField(this, "group");
    __publicField(this, "attachment");
    __privateAdd(this, _props61, user_derived(() => ({
      id: this.opts.id.current,
      [this.group.root.getBitsAttr("group-label")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(opts.ref, (v) => this.group.labelNode = v);
  }
  static create(opts) {
    return new _SelectGroupHeadingState(opts, SelectGroupContext.get());
  }
  get props() {
    return get(__privateGet(this, _props61));
  }
  set props(value) {
    set(__privateGet(this, _props61), value);
  }
};
_props61 = new WeakMap();
var SelectGroupHeadingState = _SelectGroupHeadingState;
var _shouldRender3, _props62;
var _SelectHiddenInputState = class _SelectHiddenInputState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _shouldRender3, user_derived(() => this.root.opts.name.current !== ""));
    __privateAdd(this, _props62, user_derived(() => ({
      disabled: boolToTrueOrUndef(this.root.opts.disabled.current),
      required: boolToTrueOrUndef(this.root.opts.required.current),
      name: this.root.opts.name.current,
      value: this.opts.value.current,
      onfocus: this.onfocus
    })));
    this.opts = opts;
    this.root = root18;
    this.onfocus = this.onfocus.bind(this);
  }
  static create(opts) {
    return new _SelectHiddenInputState(opts, SelectRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender3));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender3), value);
  }
  onfocus(e) {
    var _a, _b;
    e.preventDefault();
    if (!this.root.isCombobox) {
      (_a = this.root.triggerNode) == null ? void 0 : _a.focus();
    } else {
      (_b = this.root.inputNode) == null ? void 0 : _b.focus();
    }
  }
  get props() {
    return get(__privateGet(this, _props62));
  }
  set props(value) {
    set(__privateGet(this, _props62), value);
  }
};
_shouldRender3 = new WeakMap();
_props62 = new WeakMap();
var SelectHiddenInputState = _SelectHiddenInputState;
var _prevScrollTop, _props63;
var _SelectViewportState = class _SelectViewportState {
  constructor(opts, content) {
    __publicField(this, "opts");
    __publicField(this, "content");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _prevScrollTop, state(0));
    __privateAdd(this, _props63, user_derived(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [this.root.getBitsAttr("viewport")]: "",
      style: {
        // we use position: 'relative' here on the `viewport` so that when we call
        // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
        // (independent of the scrollUpButton).
        position: "relative",
        flex: 1,
        overflow: "auto"
      },
      ...this.attachment
    })));
    this.opts = opts;
    this.content = content;
    this.root = content.root;
    this.attachment = attachRef(opts.ref, (v) => {
      this.root.viewportNode = v;
    });
  }
  static create(opts) {
    return new _SelectViewportState(opts, SelectContentContext.get());
  }
  get prevScrollTop() {
    return get(__privateGet(this, _prevScrollTop));
  }
  set prevScrollTop(value) {
    set(__privateGet(this, _prevScrollTop), value, true);
  }
  get props() {
    return get(__privateGet(this, _props63));
  }
  set props(value) {
    set(__privateGet(this, _props63), value);
  }
};
_prevScrollTop = new WeakMap();
_props63 = new WeakMap();
var SelectViewportState = _SelectViewportState;
var _mounted3, _props64;
var SelectScrollButtonImplState = class {
  constructor(opts, content) {
    __publicField(this, "opts");
    __publicField(this, "content");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __publicField(this, "autoScrollTimer", null);
    __publicField(this, "userScrollTimer", -1);
    __publicField(this, "isUserScrolling", false);
    __publicField(this, "onAutoScroll", noop3);
    __privateAdd(this, _mounted3, state(false));
    __privateAdd(this, _props64, user_derived(() => ({
      id: this.opts.id.current,
      "aria-hidden": boolToStrTrueOrUndef(true),
      style: { flexShrink: 0 },
      onpointerdown: this.onpointerdown,
      onpointermove: this.onpointermove,
      onpointerleave: this.onpointerleave,
      ...this.attachment
    })));
    this.opts = opts;
    this.content = content;
    this.root = content.root;
    this.attachment = attachRef(opts.ref);
    watch([() => this.mounted], () => {
      if (!this.mounted) {
        this.isUserScrolling = false;
        return;
      }
      if (this.isUserScrolling) return;
    });
    user_effect(() => {
      if (this.mounted) return;
      this.clearAutoScrollInterval();
    });
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
  }
  get mounted() {
    return get(__privateGet(this, _mounted3));
  }
  set mounted(value) {
    set(__privateGet(this, _mounted3), value, true);
  }
  handleUserScroll() {
    this.content.domContext.clearTimeout(this.userScrollTimer);
    this.isUserScrolling = true;
    this.userScrollTimer = this.content.domContext.setTimeout(
      () => {
        this.isUserScrolling = false;
      },
      200
    );
  }
  clearAutoScrollInterval() {
    if (this.autoScrollTimer === null) return;
    this.content.domContext.clearTimeout(this.autoScrollTimer);
    this.autoScrollTimer = null;
  }
  onpointerdown(_) {
    if (this.autoScrollTimer !== null) return;
    const autoScroll = (tick2) => {
      this.onAutoScroll();
      this.autoScrollTimer = this.content.domContext.setTimeout(() => autoScroll(tick2 + 1), this.opts.delay.current(tick2));
    };
    this.autoScrollTimer = this.content.domContext.setTimeout(() => autoScroll(1), this.opts.delay.current(0));
  }
  onpointermove(e) {
    this.onpointerdown(e);
  }
  onpointerleave(_) {
    this.clearAutoScrollInterval();
  }
  get props() {
    return get(__privateGet(this, _props64));
  }
  set props(value) {
    set(__privateGet(this, _props64), value);
  }
};
_mounted3 = new WeakMap();
_props64 = new WeakMap();
var _canScrollDown, _props65;
var _SelectScrollDownButtonState = class _SelectScrollDownButtonState {
  constructor(scrollButtonState) {
    __publicField(this, "scrollButtonState");
    __publicField(this, "content");
    __publicField(this, "root");
    __privateAdd(this, _canScrollDown, state(false));
    __publicField(this, "scrollIntoViewTimer", null);
    /**
     * @param manual - if true, it means the function was invoked manually outside of an event
     * listener, so we don't call `handleUserScroll` to prevent the auto scroll from kicking in.
     */
    __publicField(this, "handleScroll", (manual = false) => {
      if (!manual) {
        this.scrollButtonState.handleUserScroll();
      }
      if (!this.root.viewportNode) return;
      const maxScroll = this.root.viewportNode.scrollHeight - this.root.viewportNode.clientHeight;
      const paddingTop = Number.parseInt(getComputedStyle(this.root.viewportNode).paddingTop, 10);
      this.canScrollDown = Math.ceil(this.root.viewportNode.scrollTop) < maxScroll - paddingTop;
    });
    __publicField(this, "handleAutoScroll", () => {
      const viewport = this.root.viewportNode;
      const selectedItem = this.root.highlightedNode;
      if (!viewport || !selectedItem) return;
      viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
    });
    __privateAdd(this, _props65, user_derived(() => ({
      ...this.scrollButtonState.props,
      [this.root.getBitsAttr("scroll-down-button")]: ""
    })));
    this.scrollButtonState = scrollButtonState;
    this.content = scrollButtonState.content;
    this.root = scrollButtonState.root;
    this.scrollButtonState.onAutoScroll = this.handleAutoScroll;
    watch(
      [
        () => this.root.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!this.root.viewportNode || !this.content.isPositioned) return;
        this.handleScroll(true);
        return on(this.root.viewportNode, "scroll", () => this.handleScroll());
      }
    );
    watch(
      [
        () => this.root.opts.inputValue.current,
        () => this.root.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!this.root.viewportNode || !this.content.isPositioned) return;
        this.handleScroll(true);
      }
    );
    watch(() => this.scrollButtonState.mounted, () => {
      if (!this.scrollButtonState.mounted) return;
      if (this.scrollIntoViewTimer) {
        clearTimeout(this.scrollIntoViewTimer);
      }
      this.scrollIntoViewTimer = afterSleep(5, () => {
        const activeItem = this.root.highlightedNode;
        activeItem == null ? void 0 : activeItem.scrollIntoView({ block: this.root.opts.scrollAlignment.current });
      });
    });
  }
  static create(opts) {
    return new _SelectScrollDownButtonState(new SelectScrollButtonImplState(opts, SelectContentContext.get()));
  }
  get canScrollDown() {
    return get(__privateGet(this, _canScrollDown));
  }
  set canScrollDown(value) {
    set(__privateGet(this, _canScrollDown), value, true);
  }
  get props() {
    return get(__privateGet(this, _props65));
  }
  set props(value) {
    set(__privateGet(this, _props65), value);
  }
};
_canScrollDown = new WeakMap();
_props65 = new WeakMap();
var SelectScrollDownButtonState = _SelectScrollDownButtonState;
var _canScrollUp, _props66;
var _SelectScrollUpButtonState = class _SelectScrollUpButtonState {
  constructor(scrollButtonState) {
    __publicField(this, "scrollButtonState");
    __publicField(this, "content");
    __publicField(this, "root");
    __privateAdd(this, _canScrollUp, state(false));
    /**
     * @param manual - if true, it means the function was invoked manually outside of an event
     * listener, so we don't call `handleUserScroll` to prevent the auto scroll from kicking in.
     */
    __publicField(this, "handleScroll", (manual = false) => {
      if (!manual) {
        this.scrollButtonState.handleUserScroll();
      }
      if (!this.root.viewportNode) return;
      const paddingTop = Number.parseInt(getComputedStyle(this.root.viewportNode).paddingTop, 10);
      this.canScrollUp = this.root.viewportNode.scrollTop - paddingTop > 0.1;
    });
    __publicField(this, "handleAutoScroll", () => {
      if (!this.root.viewportNode || !this.root.highlightedNode) return;
      this.root.viewportNode.scrollTop = this.root.viewportNode.scrollTop - this.root.highlightedNode.offsetHeight;
    });
    __privateAdd(this, _props66, user_derived(() => ({
      ...this.scrollButtonState.props,
      [this.root.getBitsAttr("scroll-up-button")]: ""
    })));
    this.scrollButtonState = scrollButtonState;
    this.content = scrollButtonState.content;
    this.root = scrollButtonState.root;
    this.scrollButtonState.onAutoScroll = this.handleAutoScroll;
    watch(
      [
        () => this.root.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!this.root.viewportNode || !this.content.isPositioned) return;
        this.handleScroll(true);
        return on(this.root.viewportNode, "scroll", () => this.handleScroll());
      }
    );
  }
  static create(opts) {
    return new _SelectScrollUpButtonState(new SelectScrollButtonImplState(opts, SelectContentContext.get()));
  }
  get canScrollUp() {
    return get(__privateGet(this, _canScrollUp));
  }
  set canScrollUp(value) {
    set(__privateGet(this, _canScrollUp), value, true);
  }
  get props() {
    return get(__privateGet(this, _props66));
  }
  set props(value) {
    set(__privateGet(this, _props66), value);
  }
};
_canScrollUp = new WeakMap();
_props66 = new WeakMap();
var SelectScrollUpButtonState = _SelectScrollUpButtonState;

// node_modules/bits-ui/dist/bits/select/components/select-hidden-input.svelte
function Select_hidden_input($$anchor, $$props) {
  push($$props, true);
  let value = prop($$props, "value", 15);
  const hiddenInputState = SelectHiddenInputState.create({ value: boxWith(() => value()) });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Hidden_input($$anchor2, spread_props(() => hiddenInputState.props, {
        get autocomplete() {
          return $$props.autocomplete;
        },
        get value() {
          return value();
        },
        set value($$value) {
          value($$value);
        }
      }));
    };
    if_block(node, ($$render) => {
      if (hiddenInputState.shouldRender) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/combobox/components/combobox.svelte
var root3 = from_html(`<!> <!>`, 1);
function Combobox($$anchor, $$props) {
  push($$props, true);
  let value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), name = prop($$props, "name", 3, ""), disabled = prop($$props, "disabled", 3, false), open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), loop = prop($$props, "loop", 3, false), scrollAlignment = prop($$props, "scrollAlignment", 3, "nearest"), required = prop($$props, "required", 3, false), items = prop($$props, "items", 19, () => []), allowDeselect = prop($$props, "allowDeselect", 3, true), inputValue = prop($$props, "inputValue", 7, "");
  if (value() === void 0) {
    const defaultValue = $$props.type === "single" ? "" : [];
    value(defaultValue);
  }
  watch.pre(() => value(), () => {
    if (value() !== void 0) return;
    value($$props.type === "single" ? "" : []);
  });
  const rootState = SelectRootState.create({
    type: $$props.type,
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    disabled: boxWith(() => disabled()),
    required: boxWith(() => required()),
    open: boxWith(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    loop: boxWith(() => loop()),
    scrollAlignment: boxWith(() => scrollAlignment()),
    name: boxWith(() => name()),
    isCombobox: true,
    items: boxWith(() => items()),
    allowDeselect: boxWith(() => allowDeselect()),
    inputValue: boxWith(() => inputValue(), (v) => inputValue(v)),
    onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
  });
  var fragment = root3();
  var node = first_child(fragment);
  Floating_layer(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      {
        var consequent = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          each(node_4, 16, () => rootState.opts.value.current, (item) => item, ($$anchor4, item) => {
            Select_hidden_input($$anchor4, {
              get value() {
                return item;
              }
            });
          });
          append($$anchor3, fragment_3);
        };
        if_block(node_3, ($$render) => {
          if (rootState.opts.value.current.length) $$render(consequent);
        });
      }
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      Select_hidden_input($$anchor2, {
        get value() {
          return rootState.opts.value.current;
        },
        set value($$value) {
          rootState.opts.value.current = $$value;
        }
      });
    };
    if_block(node_2, ($$render) => {
      if (Array.isArray(rootState.opts.value.current)) $$render(consequent_1);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/index.js
var components_exports = {};
__export(components_exports, {
  Anchor: () => Floating_layer_anchor,
  Arrow: () => Floating_layer_arrow,
  Content: () => Floating_layer_content,
  ContentStatic: () => Floating_layer_content_static,
  Root: () => Floating_layer
});

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-anchor.svelte
function Floating_layer_anchor($$anchor, $$props) {
  push($$props, true);
  let tooltip = prop($$props, "tooltip", 3, false);
  FloatingAnchorState.create(
    {
      id: boxWith(() => $$props.id),
      virtualEl: boxWith(() => $$props.virtualEl),
      ref: $$props.ref
    },
    tooltip()
  );
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/arrow/arrow.svelte
var root_4 = from_svg(`<svg viewBox="0 0 30 10" preserveAspectRatio="none" data-arrow=""><polygon points="0,0 30,0 15,10" fill="currentColor"></polygon></svg>`);
var root_236 = from_html(`<span><!></span>`);
function Arrow($$anchor, $$props) {
  push($$props, true);
  let id = prop($$props, "id", 19, useId), width = prop($$props, "width", 3, 10), height = prop($$props, "height", 3, 5), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "children",
    "child",
    "width",
    "height"
  ]);
  const mergedProps = user_derived(() => mergeProps(restProps, { id: id() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_236();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop);
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var svg = root_4();
          template_effect(() => {
            set_attribute(svg, "width", width());
            set_attribute(svg, "height", height());
          });
          append($$anchor3, svg);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-arrow.svelte
function Floating_layer_arrow($$anchor, $$props) {
  push($$props, true);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref"
  ]);
  const arrowState = FloatingArrowState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, arrowState.props));
  Arrow($$anchor, spread_props(() => get(mergedProps)));
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content.svelte
function Floating_layer_content($$anchor, $$props) {
  push($$props, true);
  let side = prop($$props, "side", 3, "bottom"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), alignOffset = prop($$props, "alignOffset", 3, 0), arrowPadding = prop($$props, "arrowPadding", 3, 0), avoidCollisions = prop($$props, "avoidCollisions", 3, true), collisionBoundary = prop($$props, "collisionBoundary", 19, () => []), collisionPadding = prop($$props, "collisionPadding", 3, 0), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), onPlaced = prop($$props, "onPlaced", 3, () => {
  }), sticky = prop($$props, "sticky", 3, "partial"), updatePositionStrategy = prop($$props, "updatePositionStrategy", 3, "optimized"), strategy = prop($$props, "strategy", 3, "fixed"), dir = prop($$props, "dir", 3, "ltr"), style = prop($$props, "style", 19, () => ({})), wrapperId = prop($$props, "wrapperId", 19, useId), customAnchor = prop($$props, "customAnchor", 3, null), tooltip = prop($$props, "tooltip", 3, false);
  const contentState = FloatingContentState.create(
    {
      side: boxWith(() => side()),
      sideOffset: boxWith(() => sideOffset()),
      align: boxWith(() => align()),
      alignOffset: boxWith(() => alignOffset()),
      id: boxWith(() => $$props.id),
      arrowPadding: boxWith(() => arrowPadding()),
      avoidCollisions: boxWith(() => avoidCollisions()),
      collisionBoundary: boxWith(() => collisionBoundary()),
      collisionPadding: boxWith(() => collisionPadding()),
      hideWhenDetached: boxWith(() => hideWhenDetached()),
      onPlaced: boxWith(() => onPlaced()),
      sticky: boxWith(() => sticky()),
      updatePositionStrategy: boxWith(() => updatePositionStrategy()),
      strategy: boxWith(() => strategy()),
      dir: boxWith(() => dir()),
      style: boxWith(() => style()),
      enabled: boxWith(() => $$props.enabled),
      wrapperId: boxWith(() => wrapperId()),
      customAnchor: boxWith(() => customAnchor())
    },
    tooltip()
  );
  const mergedProps = user_derived(() => mergeProps(contentState.wrapperProps, { style: { pointerEvents: "auto" } }));
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.content ?? noop, () => ({
    props: contentState.props,
    wrapperProps: get(mergedProps)
  }));
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content-static.svelte
function Floating_layer_content_static($$anchor, $$props) {
  push($$props, true);
  onMount(() => {
    var _a;
    (_a = $$props.onPlaced) == null ? void 0 : _a.call($$props);
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.content ?? noop, () => ({ props: {}, wrapperProps: {} }));
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/combobox/components/combobox-input.svelte
var root_32 = from_html(`<input/>`);
function Combobox_input($$anchor, $$props) {
  push($$props, true);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), clearOnDeselect = prop($$props, "clearOnDeselect", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "child",
    "defaultValue",
    "clearOnDeselect"
  ]);
  const inputState = SelectInputState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    clearOnDeselect: boxWith(() => clearOnDeselect())
  });
  if ($$props.defaultValue) {
    inputState.root.opts.inputValue.current = $$props.defaultValue;
  }
  const mergedProps = user_derived(() => mergeProps(restProps, inputState.props, { value: inputState.root.opts.inputValue.current }));
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Anchor, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      get id() {
        return id();
      },
      get ref() {
        return inputState.opts.ref;
      },
      children: ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          };
          var alternate = ($$anchor4) => {
            var input = root_32();
            remove_input_defaults(input);
            attribute_effect(input, () => ({ ...get(mergedProps) }));
            append($$anchor4, input);
          };
          if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_1);
      },
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/separator/separator.svelte.js
var separatorAttrs = createBitsAttrs({ component: "separator", parts: ["root"] });
var _props67;
var _SeparatorRootState = class _SeparatorRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props67, user_derived(() => ({
      id: this.opts.id.current,
      role: this.opts.decorative.current ? "none" : "separator",
      "aria-orientation": this.opts.orientation.current,
      "aria-hidden": boolToStrTrueOrUndef(this.opts.decorative.current),
      "data-orientation": this.opts.orientation.current,
      [separatorAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _SeparatorRootState(opts);
  }
  get props() {
    return get(__privateGet(this, _props67));
  }
  set props(value) {
    set(__privateGet(this, _props67), value);
  }
};
_props67 = new WeakMap();
var SeparatorRootState = _SeparatorRootState;

// node_modules/bits-ui/dist/bits/separator/components/separator.svelte
var root_237 = from_html(`<div><!></div>`);
function Separator($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), decorative = prop($$props, "decorative", 3, false), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "child",
    "children",
    "decorative",
    "orientation"
  ]);
  const rootState = SeparatorRootState.create({
    ref: boxWith(() => ref(), (v) => ref(v)),
    id: boxWith(() => id()),
    decorative: boxWith(() => decorative()),
    orientation: boxWith(() => orientation())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_237();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/combobox/components/combobox-trigger.svelte
var root_238 = from_html(`<button><!></button>`);
function Combobox_trigger($$anchor, $$props) {
  push($$props, true);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "child",
    "children",
    "type"
  ]);
  const triggerState = SelectComboTriggerState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_238();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-content.svelte
function Popper_content($$anchor, $$props) {
  let isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "content",
    "isStatic",
    "onPlaced"
  ]);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Floating_layer_content_static($$anchor2, {
        get content() {
          return $$props.content;
        },
        get onPlaced() {
          return $$props.onPlaced;
        }
      });
    };
    var alternate = ($$anchor2) => {
      Floating_layer_content($$anchor2, spread_props(
        {
          get content() {
            return $$props.content;
          },
          get onPlaced() {
            return $$props.onPlaced;
          }
        },
        () => restProps
      ));
    };
    if_block(node, ($$render) => {
      if (isStatic()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
}

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-inner.svelte
var root_12 = from_html(`<!> <!>`, 1);
function Popper_layer_inner($$anchor, $$props) {
  push($$props, true);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), tooltip = prop($$props, "tooltip", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "popper",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "preventOverflowTextSelection",
    "id",
    "onPointerDown",
    "onPointerUp",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "avoidCollisions",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "updatePositionStrategy",
    "strategy",
    "dir",
    "preventScroll",
    "wrapperId",
    "style",
    "onPlaced",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onFocusOutside",
    "interactOutsideBehavior",
    "loop",
    "trapFocus",
    "isValidEvent",
    "customAnchor",
    "isStatic",
    "enabled",
    "ref",
    "tooltip"
  ]);
  {
    const content = ($$anchor2, $$arg0) => {
      let floatingProps = () => $$arg0 == null ? void 0 : $$arg0().props;
      let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
      var fragment_1 = root_12();
      var node = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          Scroll_lock($$anchor3, {
            get preventScroll() {
              return $$props.preventScroll;
            }
          });
        };
        var alternate = ($$anchor3, $$elseif) => {
          {
            var consequent_1 = ($$anchor4) => {
              Scroll_lock($$anchor4, {
                get preventScroll() {
                  return $$props.preventScroll;
                }
              });
            };
            if_block(
              $$anchor3,
              ($$render) => {
                if (!$$props.forceMount) $$render(consequent_1);
              },
              $$elseif
            );
          }
        };
        if_block(node, ($$render) => {
          if ($$props.forceMount && $$props.enabled) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      var node_1 = sibling(node, 2);
      {
        const focusScope = ($$anchor3, $$arg02) => {
          let focusScopeProps = () => $$arg02 == null ? void 0 : $$arg02().props;
          Escape_layer($$anchor3, {
            get onEscapeKeydown() {
              return $$props.onEscapeKeydown;
            },
            get escapeKeydownBehavior() {
              return $$props.escapeKeydownBehavior;
            },
            get enabled() {
              return $$props.enabled;
            },
            get ref() {
              return $$props.ref;
            },
            children: ($$anchor4, $$slotProps) => {
              {
                const children = ($$anchor5, $$arg03) => {
                  let dismissibleProps = () => $$arg03 == null ? void 0 : $$arg03().props;
                  Text_selection_layer($$anchor5, {
                    get id() {
                      return $$props.id;
                    },
                    get preventOverflowTextSelection() {
                      return $$props.preventOverflowTextSelection;
                    },
                    get onPointerDown() {
                      return $$props.onPointerDown;
                    },
                    get onPointerUp() {
                      return $$props.onPointerUp;
                    },
                    get enabled() {
                      return $$props.enabled;
                    },
                    get ref() {
                      return $$props.ref;
                    },
                    children: ($$anchor6, $$slotProps2) => {
                      var fragment_7 = comment();
                      var node_2 = first_child(fragment_7);
                      var render_arg = derived_safe_equal(() => ({
                        props: mergeProps(restProps, floatingProps(), dismissibleProps(), focusScopeProps(), { style: { pointerEvents: "auto" } }),
                        wrapperProps: wrapperProps()
                      }));
                      snippet(node_2, () => $$props.popper ?? noop, () => get(render_arg));
                      append($$anchor6, fragment_7);
                    },
                    $$slots: { default: true }
                  });
                };
                Dismissible_layer($$anchor4, {
                  get id() {
                    return $$props.id;
                  },
                  get onInteractOutside() {
                    return $$props.onInteractOutside;
                  },
                  get onFocusOutside() {
                    return $$props.onFocusOutside;
                  },
                  get interactOutsideBehavior() {
                    return interactOutsideBehavior();
                  },
                  isValidEvent: isValidEvent2(),
                  get enabled() {
                    return $$props.enabled;
                  },
                  get ref() {
                    return $$props.ref;
                  },
                  children,
                  $$slots: { default: true }
                });
              }
            },
            $$slots: { default: true }
          });
        };
        Focus_scope(node_1, {
          get onOpenAutoFocus() {
            return $$props.onOpenAutoFocus;
          },
          get onCloseAutoFocus() {
            return $$props.onCloseAutoFocus;
          },
          get loop() {
            return $$props.loop;
          },
          get enabled() {
            return $$props.enabled;
          },
          get trapFocus() {
            return trapFocus();
          },
          get forceMount() {
            return $$props.forceMount;
          },
          get ref() {
            return $$props.ref;
          },
          focusScope,
          $$slots: { focusScope: true }
        });
      }
      append($$anchor2, fragment_1);
    };
    Popper_content($$anchor, {
      get isStatic() {
        return isStatic();
      },
      get id() {
        return $$props.id;
      },
      get side() {
        return $$props.side;
      },
      get sideOffset() {
        return $$props.sideOffset;
      },
      get align() {
        return $$props.align;
      },
      get alignOffset() {
        return $$props.alignOffset;
      },
      get arrowPadding() {
        return $$props.arrowPadding;
      },
      get avoidCollisions() {
        return $$props.avoidCollisions;
      },
      get collisionBoundary() {
        return $$props.collisionBoundary;
      },
      get collisionPadding() {
        return $$props.collisionPadding;
      },
      get sticky() {
        return $$props.sticky;
      },
      get hideWhenDetached() {
        return $$props.hideWhenDetached;
      },
      get updatePositionStrategy() {
        return $$props.updatePositionStrategy;
      },
      get strategy() {
        return $$props.strategy;
      },
      get dir() {
        return $$props.dir;
      },
      get wrapperId() {
        return $$props.wrapperId;
      },
      get style() {
        return $$props.style;
      },
      get onPlaced() {
        return $$props.onPlaced;
      },
      get customAnchor() {
        return customAnchor();
      },
      get enabled() {
        return $$props.enabled;
      },
      get tooltip() {
        return tooltip();
      },
      content,
      $$slots: { content: true }
    });
  }
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer.svelte
function Popper_layer($$anchor, $$props) {
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "popper",
    "open",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "preventOverflowTextSelection",
    "id",
    "onPointerDown",
    "onPointerUp",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "avoidCollisions",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "updatePositionStrategy",
    "strategy",
    "dir",
    "preventScroll",
    "wrapperId",
    "style",
    "onPlaced",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onFocusOutside",
    "interactOutsideBehavior",
    "loop",
    "trapFocus",
    "isValidEvent",
    "customAnchor",
    "isStatic",
    "ref",
    "shouldRender"
  ]);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Popper_layer_inner($$anchor2, spread_props(
        {
          get popper() {
            return $$props.popper;
          },
          get onEscapeKeydown() {
            return $$props.onEscapeKeydown;
          },
          get escapeKeydownBehavior() {
            return $$props.escapeKeydownBehavior;
          },
          get preventOverflowTextSelection() {
            return $$props.preventOverflowTextSelection;
          },
          get id() {
            return $$props.id;
          },
          get onPointerDown() {
            return $$props.onPointerDown;
          },
          get onPointerUp() {
            return $$props.onPointerUp;
          },
          get side() {
            return $$props.side;
          },
          get sideOffset() {
            return $$props.sideOffset;
          },
          get align() {
            return $$props.align;
          },
          get alignOffset() {
            return $$props.alignOffset;
          },
          get arrowPadding() {
            return $$props.arrowPadding;
          },
          get avoidCollisions() {
            return $$props.avoidCollisions;
          },
          get collisionBoundary() {
            return $$props.collisionBoundary;
          },
          get collisionPadding() {
            return $$props.collisionPadding;
          },
          get sticky() {
            return $$props.sticky;
          },
          get hideWhenDetached() {
            return $$props.hideWhenDetached;
          },
          get updatePositionStrategy() {
            return $$props.updatePositionStrategy;
          },
          get strategy() {
            return $$props.strategy;
          },
          get dir() {
            return $$props.dir;
          },
          get preventScroll() {
            return $$props.preventScroll;
          },
          get wrapperId() {
            return $$props.wrapperId;
          },
          get style() {
            return $$props.style;
          },
          get onPlaced() {
            return $$props.onPlaced;
          },
          get customAnchor() {
            return customAnchor();
          },
          get isStatic() {
            return isStatic();
          },
          get enabled() {
            return $$props.open;
          },
          get onInteractOutside() {
            return $$props.onInteractOutside;
          },
          get onCloseAutoFocus() {
            return $$props.onCloseAutoFocus;
          },
          get onOpenAutoFocus() {
            return $$props.onOpenAutoFocus;
          },
          get interactOutsideBehavior() {
            return interactOutsideBehavior();
          },
          get loop() {
            return $$props.loop;
          },
          get trapFocus() {
            return trapFocus();
          },
          isValidEvent: isValidEvent2(),
          get onFocusOutside() {
            return $$props.onFocusOutside;
          },
          forceMount: false,
          get ref() {
            return $$props.ref;
          }
        },
        () => restProps
      ));
    };
    if_block(node, ($$render) => {
      if ($$props.shouldRender) $$render(consequent);
    });
  }
  append($$anchor, fragment);
}

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-force-mount.svelte
function Popper_layer_force_mount($$anchor, $$props) {
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "popper",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "preventOverflowTextSelection",
    "id",
    "onPointerDown",
    "onPointerUp",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "avoidCollisions",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "updatePositionStrategy",
    "strategy",
    "dir",
    "preventScroll",
    "wrapperId",
    "style",
    "onPlaced",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onFocusOutside",
    "interactOutsideBehavior",
    "loop",
    "trapFocus",
    "isValidEvent",
    "customAnchor",
    "isStatic",
    "enabled"
  ]);
  Popper_layer_inner($$anchor, spread_props(
    {
      get popper() {
        return $$props.popper;
      },
      get onEscapeKeydown() {
        return $$props.onEscapeKeydown;
      },
      get escapeKeydownBehavior() {
        return $$props.escapeKeydownBehavior;
      },
      get preventOverflowTextSelection() {
        return $$props.preventOverflowTextSelection;
      },
      get id() {
        return $$props.id;
      },
      get onPointerDown() {
        return $$props.onPointerDown;
      },
      get onPointerUp() {
        return $$props.onPointerUp;
      },
      get side() {
        return $$props.side;
      },
      get sideOffset() {
        return $$props.sideOffset;
      },
      get align() {
        return $$props.align;
      },
      get alignOffset() {
        return $$props.alignOffset;
      },
      get arrowPadding() {
        return $$props.arrowPadding;
      },
      get avoidCollisions() {
        return $$props.avoidCollisions;
      },
      get collisionBoundary() {
        return $$props.collisionBoundary;
      },
      get collisionPadding() {
        return $$props.collisionPadding;
      },
      get sticky() {
        return $$props.sticky;
      },
      get hideWhenDetached() {
        return $$props.hideWhenDetached;
      },
      get updatePositionStrategy() {
        return $$props.updatePositionStrategy;
      },
      get strategy() {
        return $$props.strategy;
      },
      get dir() {
        return $$props.dir;
      },
      get preventScroll() {
        return $$props.preventScroll;
      },
      get wrapperId() {
        return $$props.wrapperId;
      },
      get style() {
        return $$props.style;
      },
      get onPlaced() {
        return $$props.onPlaced;
      },
      get customAnchor() {
        return customAnchor();
      },
      get isStatic() {
        return isStatic();
      },
      get enabled() {
        return $$props.enabled;
      },
      get onInteractOutside() {
        return $$props.onInteractOutside;
      },
      get onCloseAutoFocus() {
        return $$props.onCloseAutoFocus;
      },
      get onOpenAutoFocus() {
        return $$props.onOpenAutoFocus;
      },
      get interactOutsideBehavior() {
        return interactOutsideBehavior();
      },
      get loop() {
        return $$props.loop;
      },
      get trapFocus() {
        return trapFocus();
      },
      isValidEvent: isValidEvent2(),
      get onFocusOutside() {
        return $$props.onFocusOutside;
      }
    },
    () => restProps,
    { forceMount: true }
  ));
}

// node_modules/bits-ui/dist/bits/select/components/select-content.svelte
var root_42 = from_html(`<div><div><!></div></div>`);
var root_9 = from_html(`<div><div><!></div></div>`);
function Select_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), side = prop($$props, "side", 3, "bottom"), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "forceMount",
    "side",
    "onInteractOutside",
    "onEscapeKeydown",
    "children",
    "child",
    "preventScroll"
  ]);
  const contentState = SelectContentState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onInteractOutside: boxWith(() => onInteractOutside()),
    onEscapeKeydown: boxWith(() => onEscapeKeydown())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), { style: contentState.props.style }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_42();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_3 = child(div_1);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get side() {
            return side();
          },
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          get preventScroll() {
            return preventScroll();
          },
          forceMount: true,
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), { style: contentState.props.style }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_9();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_6 = child(div_3);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get side() {
                return side();
              },
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              get preventScroll() {
                return preventScroll();
              },
              forceMount: false,
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/select/components/select-content-static.svelte
var root_43 = from_html(`<div><!></div>`);
var root_92 = from_html(`<div><!></div>`);
function Select_content_static($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "forceMount",
    "onInteractOutside",
    "onEscapeKeydown",
    "children",
    "child",
    "preventScroll"
  ]);
  const contentState = SelectContentState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onInteractOutside: boxWith(() => onInteractOutside()),
    onEscapeKeydown: boxWith(() => onEscapeKeydown())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), { style: contentState.props.style }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_43();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_3 = child(div);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          isStatic: true,
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          get preventScroll() {
            return preventScroll();
          },
          forceMount: true,
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), { style: contentState.props.style }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_92();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_6 = child(div_1);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              isStatic: true,
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              get preventScroll() {
                return preventScroll();
              },
              forceMount: false,
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/mounted.svelte
function Mounted($$anchor, $$props) {
  push($$props, true);
  let mounted = prop($$props, "mounted", 15, false), onMountedChange = prop($$props, "onMountedChange", 3, noop3);
  onMountEffect(() => {
    mounted(true);
    onMountedChange()(true);
    return () => {
      mounted(false);
      onMountedChange()(false);
    };
  });
  pop();
}

// node_modules/bits-ui/dist/bits/select/components/select-item.svelte
var root_239 = from_html(`<div><!></div>`);
var root4 = from_html(`<!> <!>`, 1);
function Select_item($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), label = prop($$props, "label", 19, () => $$props.value), disabled = prop($$props, "disabled", 3, false), onHighlight = prop($$props, "onHighlight", 3, noop3), onUnhighlight = prop($$props, "onUnhighlight", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "value",
    "label",
    "disabled",
    "children",
    "child",
    "onHighlight",
    "onUnhighlight"
  ]);
  const itemState = SelectItemState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    value: boxWith(() => $$props.value),
    disabled: boxWith(() => disabled()),
    label: boxWith(() => label()),
    onHighlight: boxWith(() => onHighlight()),
    onUnhighlight: boxWith(() => onUnhighlight())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, itemState.props));
  var fragment = root4();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...itemState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_239();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  Mounted(node_3, {
    get mounted() {
      return itemState.mounted;
    },
    set mounted($$value) {
      itemState.mounted = $$value;
    }
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/select/components/select-group.svelte
var root_240 = from_html(`<div><!></div>`);
function Select_group($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const groupState = SelectGroupState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, groupState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_240();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/select/components/select-group-heading.svelte
var root_241 = from_html(`<div><!></div>`);
function Select_group_heading($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "child",
    "children"
  ]);
  const groupHeadingState = SelectGroupHeadingState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, groupHeadingState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_241();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/select/components/select-viewport.svelte
var root_242 = from_html(`<div><!></div>`);
var $$css = {
  hash: "svelte-uf90i5",
  code: "\n	/* Hide scrollbars cross browser and enable momentum scroll for touch devices */[data-select-viewport] {scrollbar-width:none !important;-ms-overflow-style:none !important;-webkit-overflow-scrolling:touch !important;}[data-combobox-viewport] {scrollbar-width:none !important;-ms-overflow-style:none !important;-webkit-overflow-scrolling:touch !important;}[data-combobox-viewport]::-webkit-scrollbar {display:none !important;}[data-select-viewport]::-webkit-scrollbar {display:none !important;}"
};
function Select_viewport($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  append_styles($$anchor, $$css);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const viewportState = SelectViewportState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, viewportState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_242();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/select/components/select-scroll-down-button.svelte
var root_33 = from_html(`<div><!></div>`);
var root_13 = from_html(`<!> <!>`, 1);
function Select_scroll_down_button($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), delay = prop($$props, "delay", 3, () => 50), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "delay",
    "child",
    "children"
  ]);
  const scrollButtonState = SelectScrollDownButtonState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    delay: boxWith(() => delay())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, scrollButtonState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = root_13();
      var node_1 = first_child(fragment_1);
      Mounted(node_1, {
        get mounted() {
          return scrollButtonState.scrollButtonState.mounted;
        },
        set mounted($$value) {
          scrollButtonState.scrollButtonState.mounted = $$value;
        }
      });
      var node_2 = sibling(node_1, 2);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.child, () => ({ props: restProps }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_33();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_4 = child(div);
          snippet(node_4, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_2, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (scrollButtonState.canScrollDown) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/select/components/select-scroll-up-button.svelte
var root_34 = from_html(`<div><!></div>`);
var root_14 = from_html(`<!> <!>`, 1);
function Select_scroll_up_button($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), delay = prop($$props, "delay", 3, () => 50), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "delay",
    "child",
    "children"
  ]);
  const scrollButtonState = SelectScrollUpButtonState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    delay: boxWith(() => delay())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, scrollButtonState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = root_14();
      var node_1 = first_child(fragment_1);
      Mounted(node_1, {
        get mounted() {
          return scrollButtonState.scrollButtonState.mounted;
        },
        set mounted($$value) {
          scrollButtonState.scrollButtonState.mounted = $$value;
        }
      });
      var node_2 = sibling(node_1, 2);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.child, () => ({ props: restProps }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_34();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_4 = child(div);
          snippet(node_4, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_2, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (scrollButtonState.canScrollUp) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/command/exports.js
var exports_exports10 = {};
__export(exports_exports10, {
  Empty: () => Command_empty,
  Group: () => Command_group,
  GroupHeading: () => Command_group_heading,
  GroupItems: () => Command_group_items,
  Input: () => Command_input,
  Item: () => Command_item,
  LinkItem: () => Command_link_item,
  List: () => Command_list,
  Loading: () => Command_loading,
  Root: () => Command,
  Separator: () => Command_separator,
  Viewport: () => Command_viewport
});

// node_modules/bits-ui/dist/bits/command/utils.js
function findNextSibling(el, selector) {
  let sibling2 = el.nextElementSibling;
  while (sibling2) {
    if (sibling2.matches(selector))
      return sibling2;
    sibling2 = sibling2.nextElementSibling;
  }
}
function findPreviousSibling(el, selector) {
  let sibling2 = el.previousElementSibling;
  while (sibling2) {
    if (sibling2.matches(selector))
      return sibling2;
    sibling2 = sibling2.previousElementSibling;
  }
}

// node_modules/bits-ui/dist/internal/css-escape.js
function cssEscape(value) {
  if (typeof CSS !== "undefined" && typeof CSS.escape === "function") {
    return CSS.escape(value);
  }
  const length = value.length;
  let index = -1;
  let codeUnit;
  let result = "";
  const firstCodeUnit = value.charCodeAt(0);
  if (length === 1 && firstCodeUnit === 45)
    return "\\" + value;
  while (++index < length) {
    codeUnit = value.charCodeAt(index);
    if (codeUnit === 0) {
      result += "";
      continue;
    }
    if (
      // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is U+007F
      codeUnit >= 1 && codeUnit <= 31 || codeUnit === 127 || // If the character is the first character and is in the range [0-9] (U+0030 to U+0039)
      index === 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D)
      index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45
    ) {
      result += "\\" + codeUnit.toString(16) + " ";
      continue;
    }
    if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
      result += value.charAt(index);
      continue;
    }
    result += "\\" + value.charAt(index);
  }
  return result;
}

// node_modules/bits-ui/dist/bits/command/command.svelte.js
var COMMAND_VALUE_ATTR = "data-value";
var commandAttrs = createBitsAttrs({
  component: "command",
  parts: [
    "root",
    "list",
    "input",
    "separator",
    "loading",
    "empty",
    "group",
    "group-items",
    "group-heading",
    "item",
    "viewport",
    "input-label"
  ]
});
var COMMAND_GROUP_SELECTOR = commandAttrs.selector("group");
var COMMAND_GROUP_ITEMS_SELECTOR = commandAttrs.selector("group-items");
var COMMAND_GROUP_HEADING_SELECTOR = commandAttrs.selector("group-heading");
var COMMAND_ITEM_SELECTOR = commandAttrs.selector("item");
var COMMAND_VALID_ITEM_SELECTOR = `${commandAttrs.selector("item")}:not([aria-disabled="true"])`;
var CommandRootContext = new Context("Command.Root");
var CommandListContext = new Context("Command.List");
var CommandGroupContainerContext = new Context("Command.Group");
var defaultState = {
  /** Value of the search query */
  search: "",
  /** Currently selected item value */
  value: "",
  filtered: {
    /** The count of all visible items. */
    count: 0,
    /** Map from visible item id to its search store. */
    items: /* @__PURE__ */ new Map(),
    /** Set of groups with at least one visible item. */
    groups: /* @__PURE__ */ new Set()
  }
};
var _updateScheduled, _isInitialMount, _key2, _viewportNode2, _inputNode2, _labelNode2, _commandState, __commandState, _CommandRootState_instances, snapshot_fn, scheduleUpdate_fn, score_fn, sort_fn, selectFirstItem_fn, filterItems_fn, getSelectedItem_fn, scrollSelectedIntoView_fn, itemIsFirstRowOfGroup_fn, last_fn, next_fn, down_fn, getColumn_fn, nextRowColumnOffset_fn, findNextNonDisabledItem_fn, calculateOffset_fn, up_fn, previousRowColumnOffset_fn, findNextNonDisabledItemDesc_fn, prev_fn, _props68;
var _CommandRootState = class _CommandRootState {
  constructor(opts) {
    __privateAdd(this, _CommandRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _updateScheduled, false);
    __privateAdd(this, _isInitialMount, true);
    __publicField(this, "sortAfterTick", false);
    __publicField(this, "sortAndFilterAfterTick", false);
    __publicField(this, "allItems", /* @__PURE__ */ new Set());
    __publicField(this, "allGroups", /* @__PURE__ */ new Map());
    __publicField(this, "allIds", /* @__PURE__ */ new Map());
    __privateAdd(this, _key2, state(0));
    __privateAdd(this, _viewportNode2, state(null));
    __privateAdd(this, _inputNode2, state(null));
    __privateAdd(this, _labelNode2, state(null));
    __privateAdd(this, _commandState, state(defaultState));
    __privateAdd(this, __commandState, state(proxy(defaultState)));
    __privateAdd(this, _props68, user_derived(() => ({
      id: this.opts.id.current,
      role: "application",
      [commandAttrs.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    const defaults = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = defaults;
    this.commandState = defaults;
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return CommandRootContext.set(new _CommandRootState(opts));
  }
  get key() {
    return get(__privateGet(this, _key2));
  }
  set key(value) {
    set(__privateGet(this, _key2), value, true);
  }
  get viewportNode() {
    return get(__privateGet(this, _viewportNode2));
  }
  set viewportNode(value) {
    set(__privateGet(this, _viewportNode2), value, true);
  }
  get inputNode() {
    return get(__privateGet(this, _inputNode2));
  }
  set inputNode(value) {
    set(__privateGet(this, _inputNode2), value, true);
  }
  get labelNode() {
    return get(__privateGet(this, _labelNode2));
  }
  set labelNode(value) {
    set(__privateGet(this, _labelNode2), value, true);
  }
  get commandState() {
    return get(__privateGet(this, _commandState));
  }
  set commandState(value) {
    set(__privateGet(this, _commandState), value);
  }
  get _commandState() {
    return get(__privateGet(this, __commandState));
  }
  set _commandState(value) {
    set(__privateGet(this, __commandState), value, true);
  }
  setState(key, value, preventScroll) {
    if (Object.is(this._commandState[key], value)) return;
    this._commandState[key] = value;
    if (key === "search") {
      __privateMethod(this, _CommandRootState_instances, filterItems_fn).call(this);
      __privateMethod(this, _CommandRootState_instances, sort_fn).call(this);
    } else if (key === "value") {
      if (!preventScroll) __privateMethod(this, _CommandRootState_instances, scrollSelectedIntoView_fn).call(this);
    }
    __privateMethod(this, _CommandRootState_instances, scheduleUpdate_fn).call(this);
  }
  /**
   * Sets current value and triggers re-render if cleared.
   *
   * @param value - New value to set
   */
  setValue(value, opts) {
    if (value !== this.opts.value.current && value === "") {
      afterTick(() => {
        this.key++;
      });
    }
    this.setState("value", value, opts);
    this.opts.value.current = value;
  }
  /**
   * Gets all non-disabled, visible command items.
   *
   * @returns Array of valid item elements
   * @remarks Exposed for direct item access and bound checking
   */
  getValidItems() {
    const node = this.opts.ref.current;
    if (!node) return [];
    const validItems = Array.from(node.querySelectorAll(COMMAND_VALID_ITEM_SELECTOR)).filter((el) => !!el);
    return validItems;
  }
  /**
   * Gets all visible command items.
   *
   * @returns Array of valid item elements
   * @remarks Exposed for direct item access and bound checking
   */
  getVisibleItems() {
    const node = this.opts.ref.current;
    if (!node) return [];
    const visibleItems = Array.from(node.querySelectorAll(COMMAND_ITEM_SELECTOR)).filter((el) => !!el);
    return visibleItems;
  }
  /** Returns all visible items in a matrix structure
   *
   * @remarks Returns empty if the command isn't configured as a grid
   *
   * @returns
   */
  get itemsGrid() {
    var _a, _b, _c, _d;
    if (!this.isGrid) return [];
    const columns = this.opts.columns.current ?? 1;
    const items = this.getVisibleItems();
    const grid = [[]];
    let currentGroup = (_a = items[0]) == null ? void 0 : _a.getAttribute("data-group");
    let column = 0;
    let row = 0;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const itemGroup = item == null ? void 0 : item.getAttribute("data-group");
      if (currentGroup !== itemGroup) {
        currentGroup = itemGroup;
        column = 1;
        row++;
        grid.push([{ index: i, firstRowOfGroup: true, ref: item }]);
      } else {
        column++;
        if (column > columns) {
          row++;
          column = 1;
          grid.push([]);
        }
        (_d = grid[row]) == null ? void 0 : _d.push({
          index: i,
          firstRowOfGroup: ((_c = (_b = grid[row]) == null ? void 0 : _b[0]) == null ? void 0 : _c.firstRowOfGroup) ?? i === 0,
          ref: item
        });
      }
    }
    return grid;
  }
  /**
   * Sets selection to item at specified index in valid items array.
   * If index is out of bounds, does nothing.
   *
   * @param index - Zero-based index of item to select
   * @remarks
   * Uses `getValidItems()` to get selectable items, filtering out disabled/hidden ones.
   * Access valid items directly via `getValidItems()` to check bounds before calling.
   *
   * @example
   * // get valid items length for bounds check
   * const items = getValidItems()
   * if (index < items.length) {
   *   updateSelectedToIndex(index)
   * }
   */
  updateSelectedToIndex(index) {
    const item = this.getValidItems()[index];
    if (!item) return;
    this.setValue(item.getAttribute(COMMAND_VALUE_ATTR) ?? "");
  }
  /**
   * Updates selected item by moving up/down relative to current selection.
   * Handles wrapping when loop option is enabled.
   *
   * @param change - Direction to move: 1 for next item, -1 for previous item
   * @remarks
   * The loop behavior wraps:
   * - From last item to first when moving next
   * - From first item to last when moving previous
   *
   * Uses `getValidItems()` to get all selectable items, which filters out disabled/hidden items.
   * You can call `getValidItems()` directly to get the current valid items array.
   *
   * @example
   * // select next item
   * updateSelectedByItem(1)
   *
   * // get all valid items
   * const items = getValidItems()
   */
  updateSelectedByItem(change) {
    const selected = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
    const items = this.getValidItems();
    const index = items.findIndex((item) => item === selected);
    let newSelected = items[index + change];
    if (this.opts.loop.current) {
      newSelected = index + change < 0 ? items[items.length - 1] : index + change === items.length ? items[0] : items[index + change];
    }
    if (newSelected) {
      this.setValue(newSelected.getAttribute(COMMAND_VALUE_ATTR) ?? "");
    }
  }
  /**
   * Moves selection to the first valid item in the next/previous group.
   * If no group is found, falls back to selecting the next/previous item globally.
   *
   * @param change - Direction to move: 1 for next group, -1 for previous group
   * @example
   * // move to first item in next group
   * updateSelectedByGroup(1)
   *
   * // move to first item in previous group
   * updateSelectedByGroup(-1)
   */
  updateSelectedByGroup(change) {
    const selected = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
    let group = selected == null ? void 0 : selected.closest(COMMAND_GROUP_SELECTOR);
    let item;
    while (group && !item) {
      group = change > 0 ? findNextSibling(group, COMMAND_GROUP_SELECTOR) : findPreviousSibling(group, COMMAND_GROUP_SELECTOR);
      item = group == null ? void 0 : group.querySelector(COMMAND_VALID_ITEM_SELECTOR);
    }
    if (item) {
      this.setValue(item.getAttribute(COMMAND_VALUE_ATTR) ?? "");
    } else {
      this.updateSelectedByItem(change);
    }
  }
  /**
   * Maps item id to display value and search keywords.
   * Returns cleanup function to remove mapping.
   *
   * @param id - Unique item identifier
   * @param value - Display text
   * @param keywords - Optional search boost terms
   * @returns Cleanup function
   */
  registerValue(value, keywords) {
    var _a;
    if (!(value && value === ((_a = this.allIds.get(value)) == null ? void 0 : _a.value))) {
      this.allIds.set(value, { value, keywords });
    }
    this._commandState.filtered.items.set(value, __privateMethod(this, _CommandRootState_instances, score_fn).call(this, value, keywords));
    if (!this.sortAfterTick) {
      this.sortAfterTick = true;
      afterTick(() => {
        __privateMethod(this, _CommandRootState_instances, sort_fn).call(this);
        this.sortAfterTick = false;
      });
    }
    return () => {
      this.allIds.delete(value);
    };
  }
  /**
   * Registers item in command list and its group.
   * Handles filtering, sorting and selection updates.
   *
   * @param id - Item identifier
   * @param groupId - Optional group to add item to
   * @returns Cleanup function that handles selection
   */
  registerItem(id, groupId) {
    this.allItems.add(id);
    if (groupId) {
      if (!this.allGroups.has(groupId)) {
        this.allGroups.set(groupId, /* @__PURE__ */ new Set([id]));
      } else {
        this.allGroups.get(groupId).add(id);
      }
    }
    if (!this.sortAndFilterAfterTick) {
      this.sortAndFilterAfterTick = true;
      afterTick(() => {
        __privateMethod(this, _CommandRootState_instances, filterItems_fn).call(this);
        __privateMethod(this, _CommandRootState_instances, sort_fn).call(this);
        this.sortAndFilterAfterTick = false;
      });
    }
    __privateMethod(this, _CommandRootState_instances, scheduleUpdate_fn).call(this);
    return () => {
      const selectedItem = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
      this.allItems.delete(id);
      this.commandState.filtered.items.delete(id);
      __privateMethod(this, _CommandRootState_instances, filterItems_fn).call(this);
      if ((selectedItem == null ? void 0 : selectedItem.getAttribute("id")) === id) {
        __privateMethod(this, _CommandRootState_instances, selectFirstItem_fn).call(this);
      }
      __privateMethod(this, _CommandRootState_instances, scheduleUpdate_fn).call(this);
    };
  }
  /**
   * Creates empty group if not exists.
   *
   * @param id - Group identifier
   * @returns Cleanup function
   */
  registerGroup(id) {
    if (!this.allGroups.has(id)) {
      this.allGroups.set(id, /* @__PURE__ */ new Set());
    }
    return () => {
      this.allIds.delete(id);
      this.allGroups.delete(id);
    };
  }
  get isGrid() {
    return this.opts.columns.current !== null;
  }
  onkeydown(e) {
    const isVim = this.opts.vimBindings.current && e.ctrlKey;
    switch (e.key) {
      case kbd_constants_exports.n:
      case kbd_constants_exports.j: {
        if (isVim) {
          if (this.isGrid) {
            __privateMethod(this, _CommandRootState_instances, down_fn).call(this, e);
          } else {
            __privateMethod(this, _CommandRootState_instances, next_fn).call(this, e);
          }
        }
        break;
      }
      case kbd_constants_exports.l: {
        if (isVim) {
          if (this.isGrid) {
            __privateMethod(this, _CommandRootState_instances, next_fn).call(this, e);
          }
        }
        break;
      }
      case kbd_constants_exports.ARROW_DOWN:
        if (this.isGrid) {
          __privateMethod(this, _CommandRootState_instances, down_fn).call(this, e);
        } else {
          __privateMethod(this, _CommandRootState_instances, next_fn).call(this, e);
        }
        break;
      case kbd_constants_exports.ARROW_RIGHT:
        if (!this.isGrid) break;
        __privateMethod(this, _CommandRootState_instances, next_fn).call(this, e);
        break;
      case kbd_constants_exports.p:
      case kbd_constants_exports.k: {
        if (isVim) {
          if (this.isGrid) {
            __privateMethod(this, _CommandRootState_instances, up_fn).call(this, e);
          } else {
            __privateMethod(this, _CommandRootState_instances, prev_fn).call(this, e);
          }
        }
        break;
      }
      case kbd_constants_exports.h: {
        if (isVim && this.isGrid) {
          __privateMethod(this, _CommandRootState_instances, prev_fn).call(this, e);
        }
        break;
      }
      case kbd_constants_exports.ARROW_UP:
        if (this.isGrid) {
          __privateMethod(this, _CommandRootState_instances, up_fn).call(this, e);
        } else {
          __privateMethod(this, _CommandRootState_instances, prev_fn).call(this, e);
        }
        break;
      case kbd_constants_exports.ARROW_LEFT:
        if (!this.isGrid) break;
        __privateMethod(this, _CommandRootState_instances, prev_fn).call(this, e);
        break;
      case kbd_constants_exports.HOME:
        e.preventDefault();
        this.updateSelectedToIndex(0);
        break;
      case kbd_constants_exports.END:
        e.preventDefault();
        __privateMethod(this, _CommandRootState_instances, last_fn).call(this);
        break;
      case kbd_constants_exports.ENTER: {
        if (!e.isComposing && e.keyCode !== 229) {
          e.preventDefault();
          const item = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
          if (item) {
            item == null ? void 0 : item.click();
          }
        }
      }
    }
  }
  get props() {
    return get(__privateGet(this, _props68));
  }
  set props(value) {
    set(__privateGet(this, _props68), value);
  }
};
_updateScheduled = new WeakMap();
_isInitialMount = new WeakMap();
_key2 = new WeakMap();
_viewportNode2 = new WeakMap();
_inputNode2 = new WeakMap();
_labelNode2 = new WeakMap();
_commandState = new WeakMap();
__commandState = new WeakMap();
_CommandRootState_instances = new WeakSet();
snapshot_fn = function() {
  return snapshot(this._commandState);
};
scheduleUpdate_fn = function() {
  if (__privateGet(this, _updateScheduled)) return;
  __privateSet(this, _updateScheduled, true);
  afterTick(() => {
    var _a, _b;
    __privateSet(this, _updateScheduled, false);
    const currentState = __privateMethod(this, _CommandRootState_instances, snapshot_fn).call(this);
    const hasStateChanged = !Object.is(this.commandState, currentState);
    if (hasStateChanged) {
      this.commandState = currentState;
      (_b = (_a = this.opts.onStateChange) == null ? void 0 : _a.current) == null ? void 0 : _b.call(_a, currentState);
    }
  });
};
/**
 * Calculates score for an item based on search text and keywords.
 * Higher score = better match.
 *
 * @param value - Item's display text
 * @param keywords - Optional keywords to boost scoring
 * @returns Score from 0-1, where 0 = no match
 */
score_fn = function(value, keywords) {
  const filter = this.opts.filter.current ?? computeCommandScore;
  const score = value ? filter(value, this._commandState.search, keywords) : 0;
  return score;
};
/**
 * Sorts items and groups based on search scores.
 * Groups are sorted by their highest scoring item.
 * When no search active, selects first item.
 */
sort_fn = function() {
  var _a;
  if (!this._commandState.search || this.opts.shouldFilter.current === false) {
    if (!this._commandState.value || !__privateGet(this, _isInitialMount)) {
      __privateMethod(this, _CommandRootState_instances, selectFirstItem_fn).call(this);
    }
    return;
  }
  const scores = this._commandState.filtered.items;
  const groups = [];
  for (const value of this._commandState.filtered.groups) {
    const items = this.allGroups.get(value);
    let max = 0;
    if (!items) {
      groups.push([value, max]);
      continue;
    }
    for (const item of items) {
      const score = scores.get(item);
      max = Math.max(score ?? 0, max);
    }
    groups.push([value, max]);
  }
  const listInsertionElement = this.viewportNode;
  const sorted = this.getValidItems().sort((a2, b) => {
    const valueA = a2.getAttribute("data-value");
    const valueB = b.getAttribute("data-value");
    const scoresA = scores.get(valueA) ?? 0;
    const scoresB = scores.get(valueB) ?? 0;
    return scoresB - scoresA;
  });
  for (const item of sorted) {
    const group = item.closest(COMMAND_GROUP_ITEMS_SELECTOR);
    if (group) {
      const itemToAppend = item.parentElement === group ? item : item.closest(`${COMMAND_GROUP_ITEMS_SELECTOR} > *`);
      if (itemToAppend) {
        group.appendChild(itemToAppend);
      }
    } else {
      const itemToAppend = item.parentElement === listInsertionElement ? item : item.closest(`${COMMAND_GROUP_ITEMS_SELECTOR} > *`);
      if (itemToAppend) {
        listInsertionElement == null ? void 0 : listInsertionElement.appendChild(itemToAppend);
      }
    }
  }
  const sortedGroups = groups.sort((a2, b) => b[1] - a2[1]);
  for (const group of sortedGroups) {
    const element2 = listInsertionElement == null ? void 0 : listInsertionElement.querySelector(`${COMMAND_GROUP_SELECTOR}[${COMMAND_VALUE_ATTR}="${cssEscape(group[0])}"]`);
    (_a = element2 == null ? void 0 : element2.parentElement) == null ? void 0 : _a.appendChild(element2);
  }
  __privateMethod(this, _CommandRootState_instances, selectFirstItem_fn).call(this);
};
/**
 * Selects first non-disabled item on next tick.
 */
selectFirstItem_fn = function() {
  afterTick(() => {
    const item = this.getValidItems().find((item2) => item2.getAttribute("aria-disabled") !== "true");
    const value = item == null ? void 0 : item.getAttribute(COMMAND_VALUE_ATTR);
    const shouldPreventScroll = __privateGet(this, _isInitialMount) && this.opts.disableInitialScroll.current;
    this.setValue(value ?? "", shouldPreventScroll);
    __privateSet(this, _isInitialMount, false);
  });
};
/**
 * Updates filtered items/groups based on search.
 * Recalculates scores and filtered count.
 */
filterItems_fn = function() {
  var _a, _b;
  if (!this._commandState.search || this.opts.shouldFilter.current === false) {
    this._commandState.filtered.count = this.allItems.size;
    return;
  }
  this._commandState.filtered.groups = /* @__PURE__ */ new Set();
  let itemCount = 0;
  for (const id of this.allItems) {
    const value = ((_a = this.allIds.get(id)) == null ? void 0 : _a.value) ?? "";
    const keywords = ((_b = this.allIds.get(id)) == null ? void 0 : _b.keywords) ?? [];
    const rank = __privateMethod(this, _CommandRootState_instances, score_fn).call(this, value, keywords);
    this._commandState.filtered.items.set(id, rank);
    if (rank > 0) itemCount++;
  }
  for (const [groupId, group] of this.allGroups) {
    for (const itemId of group) {
      const currItem = this._commandState.filtered.items.get(itemId);
      if (currItem && currItem > 0) {
        this._commandState.filtered.groups.add(groupId);
        break;
      }
    }
  }
  this._commandState.filtered.count = itemCount;
};
/**
 * Gets currently selected command item.
 *
 * @returns Selected element or undefined
 */
getSelectedItem_fn = function() {
  const node = this.opts.ref.current;
  if (!node) return;
  const selectedNode = node.querySelector(`${COMMAND_VALID_ITEM_SELECTOR}[data-selected]`);
  if (!selectedNode) return;
  return selectedNode;
};
/**
 * Scrolls selected item into view.
 * Special handling for first items in groups.
 */
scrollSelectedIntoView_fn = function() {
  afterTick(() => {
    var _a, _b, _c, _d, _e;
    const item = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
    if (!item) return;
    const grandparent = (_a = item.parentElement) == null ? void 0 : _a.parentElement;
    if (!grandparent) return;
    if (this.isGrid) {
      const isFirstRowOfGroup = __privateMethod(this, _CommandRootState_instances, itemIsFirstRowOfGroup_fn).call(this, item);
      item.scrollIntoView({ block: "nearest" });
      if (isFirstRowOfGroup) {
        const closestGroupHeader = (_b = item == null ? void 0 : item.closest(COMMAND_GROUP_SELECTOR)) == null ? void 0 : _b.querySelector(COMMAND_GROUP_HEADING_SELECTOR);
        closestGroupHeader == null ? void 0 : closestGroupHeader.scrollIntoView({ block: "nearest" });
        return;
      }
    } else {
      const firstChildOfParent = getFirstNonCommentChild(grandparent);
      if (firstChildOfParent && ((_c = firstChildOfParent.dataset) == null ? void 0 : _c.value) === ((_d = item.dataset) == null ? void 0 : _d.value)) {
        const closestGroupHeader = (_e = item == null ? void 0 : item.closest(COMMAND_GROUP_SELECTOR)) == null ? void 0 : _e.querySelector(COMMAND_GROUP_HEADING_SELECTOR);
        closestGroupHeader == null ? void 0 : closestGroupHeader.scrollIntoView({ block: "nearest" });
        return;
      }
    }
    item.scrollIntoView({ block: "nearest" });
  });
};
itemIsFirstRowOfGroup_fn = function(item) {
  const grid = this.itemsGrid;
  if (grid.length === 0) return false;
  for (let r = 0; r < grid.length; r++) {
    const row = grid[r];
    if (row === void 0) continue;
    for (let c = 0; c < row.length; c++) {
      const column = row[c];
      if (column === void 0 || column.ref !== item) continue;
      return column.firstRowOfGroup;
    }
  }
  return false;
};
/**
 * Selects last valid item.
 */
last_fn = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1);
};
/**
 * Handles next item selection:
 * - Meta: Jump to last
 * - Alt: Next group
 * - Default: Next item
 *
 * @param e - Keyboard event
 */
next_fn = function(e) {
  e.preventDefault();
  if (e.metaKey) {
    __privateMethod(this, _CommandRootState_instances, last_fn).call(this);
  } else if (e.altKey) {
    this.updateSelectedByGroup(1);
  } else {
    this.updateSelectedByItem(1);
  }
};
down_fn = function(e) {
  if (this.opts.columns.current === null) return;
  e.preventDefault();
  if (e.metaKey) {
    this.updateSelectedByGroup(1);
  } else {
    this.updateSelectedByItem(__privateMethod(this, _CommandRootState_instances, nextRowColumnOffset_fn).call(this, e));
  }
};
getColumn_fn = function(item, grid) {
  if (grid.length === 0) return null;
  for (let r = 0; r < grid.length; r++) {
    const row = grid[r];
    if (row === void 0) continue;
    for (let c = 0; c < row.length; c++) {
      const column = row[c];
      if (column === void 0 || column.ref !== item) continue;
      return { columnIndex: c, rowIndex: r };
    }
  }
  return null;
};
nextRowColumnOffset_fn = function(e) {
  const grid = this.itemsGrid;
  const selected = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
  if (!selected) return 0;
  const column = __privateMethod(this, _CommandRootState_instances, getColumn_fn).call(this, selected, grid);
  if (!column) return 0;
  let newItem = null;
  const skipRows = e.altKey ? 1 : 0;
  if (e.altKey && column.rowIndex === grid.length - 2 && !this.opts.loop.current) {
    newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItem_fn).call(this, {
      start: grid.length - 1,
      end: grid.length,
      expectedColumnIndex: column.columnIndex,
      grid
    });
  } else if (column.rowIndex === grid.length - 1) {
    if (!this.opts.loop.current) return 0;
    newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItem_fn).call(this, {
      start: 0 + skipRows,
      end: column.rowIndex,
      expectedColumnIndex: column.columnIndex,
      grid
    });
  } else {
    newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItem_fn).call(this, {
      start: column.rowIndex + 1 + skipRows,
      end: grid.length,
      expectedColumnIndex: column.columnIndex,
      grid
    });
    if (newItem === null && this.opts.loop.current) {
      newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItem_fn).call(this, {
        start: 0,
        end: column.rowIndex,
        expectedColumnIndex: column.columnIndex,
        grid
      });
    }
  }
  return __privateMethod(this, _CommandRootState_instances, calculateOffset_fn).call(this, selected, newItem);
};
/** Attempts to find the next non-disabled column that matches the expected column.
 *
 * @remarks
 * - Skips over disabled columns
 * - When a row is shorter than the expected column it defaults to the last item in the row
 *
 * @param param0
 * @returns
 */
findNextNonDisabledItem_fn = function({ start, end, grid, expectedColumnIndex }) {
  var _a;
  let newItem = null;
  for (let r = start; r < end; r++) {
    const row = grid[r];
    newItem = ((_a = row[expectedColumnIndex]) == null ? void 0 : _a.ref) ?? null;
    if (newItem !== null && itemIsDisabled(newItem)) {
      newItem = null;
      continue;
    }
    if (newItem === null) {
      for (let i = row.length - 1; i >= 0; i--) {
        const item = row[row.length - 1];
        if (item === void 0 || itemIsDisabled(item.ref)) continue;
        newItem = item.ref;
        break;
      }
    }
    break;
  }
  return newItem;
};
calculateOffset_fn = function(selected, newSelected) {
  if (newSelected === null) return 0;
  const items = this.getValidItems();
  const ogIndex = items.findIndex((item) => item === selected);
  const newIndex = items.findIndex((item) => item === newSelected);
  return newIndex - ogIndex;
};
up_fn = function(e) {
  if (this.opts.columns.current === null) return;
  e.preventDefault();
  if (e.metaKey) {
    this.updateSelectedByGroup(-1);
  } else {
    this.updateSelectedByItem(__privateMethod(this, _CommandRootState_instances, previousRowColumnOffset_fn).call(this, e));
  }
};
previousRowColumnOffset_fn = function(e) {
  const grid = this.itemsGrid;
  const selected = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
  if (selected === void 0) return 0;
  const column = __privateMethod(this, _CommandRootState_instances, getColumn_fn).call(this, selected, grid);
  if (column === null) return 0;
  let newItem = null;
  const skipRows = e.altKey ? 1 : 0;
  if (e.altKey && column.rowIndex === 1 && this.opts.loop.current === false) {
    newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItemDesc_fn).call(this, {
      start: 0,
      end: 0,
      expectedColumnIndex: column.columnIndex,
      grid
    });
  } else if (column.rowIndex === 0) {
    if (this.opts.loop.current === false) return 0;
    newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItemDesc_fn).call(this, {
      start: grid.length - 1 - skipRows,
      end: column.rowIndex + 1,
      expectedColumnIndex: column.columnIndex,
      grid
    });
  } else {
    newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItemDesc_fn).call(this, {
      start: column.rowIndex - 1 - skipRows,
      end: 0,
      expectedColumnIndex: column.columnIndex,
      grid
    });
    if (newItem === null && this.opts.loop.current) {
      newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItemDesc_fn).call(this, {
        start: grid.length - 1,
        end: column.rowIndex + 1,
        expectedColumnIndex: column.columnIndex,
        grid
      });
    }
  }
  return __privateMethod(this, _CommandRootState_instances, calculateOffset_fn).call(this, selected, newItem);
};
/**
 * Attempts to find the next non-disabled column that matches the expected column.
 *
 * @remarks
 * - Skips over disabled columns
 * - When a row is shorter than the expected column it defaults to the last item in the row
 */
findNextNonDisabledItemDesc_fn = function({ start, end, grid, expectedColumnIndex }) {
  var _a;
  let newItem = null;
  for (let r = start; r >= end; r--) {
    const row = grid[r];
    if (row === void 0) continue;
    newItem = ((_a = row[expectedColumnIndex]) == null ? void 0 : _a.ref) ?? null;
    if (newItem !== null && itemIsDisabled(newItem)) {
      newItem = null;
      continue;
    }
    if (newItem === null) {
      for (let i = row.length - 1; i >= 0; i--) {
        const item = row[row.length - 1];
        if (item === void 0 || itemIsDisabled(item.ref)) continue;
        newItem = item.ref;
        break;
      }
    }
    break;
  }
  return newItem;
};
/**
 * Handles previous item selection:
 * - Meta: Jump to first
 * - Alt: Previous group
 * - Default: Previous item
 *
 * @param e - Keyboard event
 */
prev_fn = function(e) {
  e.preventDefault();
  if (e.metaKey) {
    this.updateSelectedToIndex(0);
  } else if (e.altKey) {
    this.updateSelectedByGroup(-1);
  } else {
    this.updateSelectedByItem(-1);
  }
};
_props68 = new WeakMap();
var CommandRootState = _CommandRootState;
function itemIsDisabled(item) {
  return item.getAttribute("aria-disabled") === "true";
}
var _shouldRender4, _isInitialRender, _props69;
var _CommandEmptyState = class _CommandEmptyState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _shouldRender4, user_derived(() => {
      return this.root._commandState.filtered.count === 0 && __privateGet(this, _isInitialRender) === false || this.opts.forceMount.current;
    }));
    __privateAdd(this, _isInitialRender, true);
    __privateAdd(this, _props69, user_derived(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [commandAttrs.empty]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_pre_effect(() => {
      __privateSet(this, _isInitialRender, false);
    });
  }
  static create(opts) {
    return new _CommandEmptyState(opts, CommandRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender4));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender4), value);
  }
  get props() {
    return get(__privateGet(this, _props69));
  }
  set props(value) {
    set(__privateGet(this, _props69), value);
  }
};
_shouldRender4 = new WeakMap();
_isInitialRender = new WeakMap();
_props69 = new WeakMap();
var CommandEmptyState = _CommandEmptyState;
var _shouldRender5, _headingNode, _trueValue, _props70;
var _CommandGroupContainerState = class _CommandGroupContainerState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _shouldRender5, user_derived(() => {
      if (this.opts.forceMount.current) return true;
      if (this.root.opts.shouldFilter.current === false) return true;
      if (!this.root.commandState.search) return true;
      return this.root._commandState.filtered.groups.has(this.trueValue);
    }));
    __privateAdd(this, _headingNode, state(null));
    __privateAdd(this, _trueValue, state(""));
    __privateAdd(this, _props70, user_derived(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : true,
      "data-value": this.trueValue,
      [commandAttrs.group]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.trueValue = opts.value.current ?? opts.id.current;
    watch(() => this.trueValue, () => {
      return this.root.registerGroup(this.trueValue);
    });
    user_effect(() => {
      if (this.opts.value.current) {
        this.trueValue = this.opts.value.current;
        return this.root.registerValue(this.opts.value.current);
      } else if (this.headingNode && this.headingNode.textContent) {
        this.trueValue = this.headingNode.textContent.trim().toLowerCase();
        return this.root.registerValue(this.trueValue);
      } else {
        this.trueValue = `-----${this.opts.id.current}`;
        return this.root.registerValue(this.trueValue);
      }
    });
  }
  static create(opts) {
    return CommandGroupContainerContext.set(new _CommandGroupContainerState(opts, CommandRootContext.get()));
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender5));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender5), value);
  }
  get headingNode() {
    return get(__privateGet(this, _headingNode));
  }
  set headingNode(value) {
    set(__privateGet(this, _headingNode), value, true);
  }
  get trueValue() {
    return get(__privateGet(this, _trueValue));
  }
  set trueValue(value) {
    set(__privateGet(this, _trueValue), value, true);
  }
  get props() {
    return get(__privateGet(this, _props70));
  }
  set props(value) {
    set(__privateGet(this, _props70), value);
  }
};
_shouldRender5 = new WeakMap();
_headingNode = new WeakMap();
_trueValue = new WeakMap();
_props70 = new WeakMap();
var CommandGroupContainerState = _CommandGroupContainerState;
var _props71;
var _CommandGroupHeadingState = class _CommandGroupHeadingState {
  constructor(opts, group) {
    __publicField(this, "opts");
    __publicField(this, "group");
    __publicField(this, "attachment");
    __privateAdd(this, _props71, user_derived(() => ({
      id: this.opts.id.current,
      [commandAttrs["group-heading"]]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref, (v) => this.group.headingNode = v);
  }
  static create(opts) {
    return new _CommandGroupHeadingState(opts, CommandGroupContainerContext.get());
  }
  get props() {
    return get(__privateGet(this, _props71));
  }
  set props(value) {
    set(__privateGet(this, _props71), value);
  }
};
_props71 = new WeakMap();
var CommandGroupHeadingState = _CommandGroupHeadingState;
var _props72;
var _CommandGroupItemsState = class _CommandGroupItemsState {
  constructor(opts, group) {
    __publicField(this, "opts");
    __publicField(this, "group");
    __publicField(this, "attachment");
    __privateAdd(this, _props72, user_derived(() => {
      var _a;
      return {
        id: this.opts.id.current,
        role: "group",
        [commandAttrs["group-items"]]: "",
        "aria-labelledby": ((_a = this.group.headingNode) == null ? void 0 : _a.id) ?? void 0,
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CommandGroupItemsState(opts, CommandGroupContainerContext.get());
  }
  get props() {
    return get(__privateGet(this, _props72));
  }
  set props(value) {
    set(__privateGet(this, _props72), value);
  }
};
_props72 = new WeakMap();
var CommandGroupItemsState = _CommandGroupItemsState;
var _selectedItemId, _props73;
var _CommandInputState = class _CommandInputState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _selectedItemId, user_derived(() => {
      var _a;
      const item = (_a = this.root.viewportNode) == null ? void 0 : _a.querySelector(`${COMMAND_ITEM_SELECTOR}[${COMMAND_VALUE_ATTR}="${cssEscape(this.root.opts.value.current)}"]`);
      if (item === void 0 || item === null) return;
      return item.getAttribute("id") ?? void 0;
    }));
    __privateAdd(this, _props73, user_derived(() => {
      var _a, _b;
      return {
        id: this.opts.id.current,
        type: "text",
        [commandAttrs.input]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: false,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": boolToStr(true),
        "aria-controls": ((_a = this.root.viewportNode) == null ? void 0 : _a.id) ?? void 0,
        "aria-labelledby": ((_b = this.root.labelNode) == null ? void 0 : _b.id) ?? void 0,
        "aria-activedescendant": get(__privateGet(this, _selectedItemId)),
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.inputNode = v);
    watch(() => this.opts.ref.current, () => {
      const node = this.opts.ref.current;
      if (node && this.opts.autofocus.current) {
        afterSleep(10, () => node.focus());
      }
    });
    watch(() => this.opts.value.current, () => {
      if (this.root.commandState.search !== this.opts.value.current) {
        this.root.setState("search", this.opts.value.current);
      }
    });
  }
  static create(opts) {
    return new _CommandInputState(opts, CommandRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props73));
  }
  set props(value) {
    set(__privateGet(this, _props73), value);
  }
};
_selectedItemId = new WeakMap();
_props73 = new WeakMap();
var CommandInputState = _CommandInputState;
var _group, _trueForceMount, _shouldRender6, _isSelected2, _trueValue2, _CommandItemState_instances, onSelect_fn, select_fn, _props74;
var _CommandItemState = class _CommandItemState {
  constructor(opts, root18) {
    __privateAdd(this, _CommandItemState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _group, null);
    __privateAdd(this, _trueForceMount, user_derived(() => {
      var _a;
      return this.opts.forceMount.current || ((_a = __privateGet(this, _group)) == null ? void 0 : _a.opts.forceMount.current) === true;
    }));
    __privateAdd(this, _shouldRender6, user_derived(() => {
      this.opts.ref.current;
      if (get(__privateGet(this, _trueForceMount)) || this.root.opts.shouldFilter.current === false || !this.root.commandState.search) {
        return true;
      }
      const currentScore = this.root.commandState.filtered.items.get(this.trueValue);
      if (currentScore === void 0) return false;
      return currentScore > 0;
    }));
    __privateAdd(this, _isSelected2, user_derived(() => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
    __privateAdd(this, _trueValue2, state(""));
    __privateAdd(this, _props74, user_derived(() => {
      var _a;
      return {
        id: this.opts.id.current,
        "aria-disabled": boolToStr(this.opts.disabled.current),
        "aria-selected": boolToStr(this.isSelected),
        "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
        "data-selected": boolToEmptyStrOrUndef(this.isSelected),
        "data-value": this.trueValue,
        "data-group": (_a = __privateGet(this, _group)) == null ? void 0 : _a.trueValue,
        [commandAttrs.item]: "",
        role: "option",
        onpointermove: this.onpointermove,
        onclick: this.onclick,
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    __privateSet(this, _group, CommandGroupContainerContext.getOr(null));
    this.trueValue = opts.value.current;
    this.attachment = attachRef(this.opts.ref);
    watch(
      [
        () => this.trueValue,
        () => {
          var _a;
          return (_a = __privateGet(this, _group)) == null ? void 0 : _a.trueValue;
        },
        () => this.opts.forceMount.current
      ],
      () => {
        var _a;
        if (this.opts.forceMount.current || !this.trueValue) return;
        return this.root.registerItem(this.trueValue, (_a = __privateGet(this, _group)) == null ? void 0 : _a.trueValue);
      }
    );
    watch(
      [
        () => this.opts.value.current,
        () => this.opts.ref.current
      ],
      () => {
        var _a, _b;
        if (this.opts.value.current) {
          this.trueValue = this.opts.value.current;
        } else if ((_a = this.opts.ref.current) == null ? void 0 : _a.textContent) {
          this.trueValue = this.opts.ref.current.textContent.trim();
        }
        if (this.trueValue) {
          this.root.registerValue(this.trueValue, opts.keywords.current.map((kw) => kw.trim()));
          (_b = this.opts.ref.current) == null ? void 0 : _b.setAttribute(COMMAND_VALUE_ATTR, this.trueValue);
        }
      }
    );
    this.onclick = this.onclick.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
  }
  static create(opts) {
    const group = CommandGroupContainerContext.getOr(null);
    return new _CommandItemState({ ...opts, group }, CommandRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender6));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender6), value);
  }
  get isSelected() {
    return get(__privateGet(this, _isSelected2));
  }
  set isSelected(value) {
    set(__privateGet(this, _isSelected2), value);
  }
  get trueValue() {
    return get(__privateGet(this, _trueValue2));
  }
  set trueValue(value) {
    set(__privateGet(this, _trueValue2), value, true);
  }
  onpointermove(_) {
    if (this.opts.disabled.current || this.root.opts.disablePointerSelection.current) return;
    __privateMethod(this, _CommandItemState_instances, select_fn).call(this);
  }
  onclick(_) {
    if (this.opts.disabled.current) return;
    __privateMethod(this, _CommandItemState_instances, onSelect_fn).call(this);
  }
  get props() {
    return get(__privateGet(this, _props74));
  }
  set props(value) {
    set(__privateGet(this, _props74), value);
  }
};
_group = new WeakMap();
_trueForceMount = new WeakMap();
_shouldRender6 = new WeakMap();
_isSelected2 = new WeakMap();
_trueValue2 = new WeakMap();
_CommandItemState_instances = new WeakSet();
onSelect_fn = function() {
  var _a;
  if (this.opts.disabled.current) return;
  __privateMethod(this, _CommandItemState_instances, select_fn).call(this);
  (_a = this.opts.onSelect) == null ? void 0 : _a.current();
};
select_fn = function() {
  if (this.opts.disabled.current) return;
  this.root.setValue(this.trueValue, true);
};
_props74 = new WeakMap();
var CommandItemState = _CommandItemState;
var _props75;
var _CommandLoadingState = class _CommandLoadingState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props75, user_derived(() => ({
      id: this.opts.id.current,
      role: "progressbar",
      "aria-valuenow": this.opts.progress.current,
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-label": "Loading...",
      [commandAttrs.loading]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CommandLoadingState(opts);
  }
  get props() {
    return get(__privateGet(this, _props75));
  }
  set props(value) {
    set(__privateGet(this, _props75), value);
  }
};
_props75 = new WeakMap();
var CommandLoadingState = _CommandLoadingState;
var _shouldRender7, _props76;
var _CommandSeparatorState = class _CommandSeparatorState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _shouldRender7, user_derived(() => !this.root._commandState.search || this.opts.forceMount.current));
    __privateAdd(this, _props76, user_derived(() => ({
      id: this.opts.id.current,
      // role="separator" cannot belong to a role="listbox"
      "aria-hidden": "true",
      [commandAttrs.separator]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CommandSeparatorState(opts, CommandRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender7));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender7), value);
  }
  get props() {
    return get(__privateGet(this, _props76));
  }
  set props(value) {
    set(__privateGet(this, _props76), value);
  }
};
_shouldRender7 = new WeakMap();
_props76 = new WeakMap();
var CommandSeparatorState = _CommandSeparatorState;
var _props77;
var _CommandListState = class _CommandListState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props77, user_derived(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [commandAttrs.list]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return CommandListContext.set(new _CommandListState(opts, CommandRootContext.get()));
  }
  get props() {
    return get(__privateGet(this, _props77));
  }
  set props(value) {
    set(__privateGet(this, _props77), value);
  }
};
_props77 = new WeakMap();
var CommandListState = _CommandListState;
var _props78;
var _CommandLabelState = class _CommandLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props78, user_derived(() => {
      var _a;
      return {
        id: this.opts.id.current,
        [commandAttrs["input-label"]]: "",
        for: (_a = this.opts.for) == null ? void 0 : _a.current,
        style: srOnlyStyles,
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.labelNode = v);
  }
  static create(opts) {
    return new _CommandLabelState(opts, CommandRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props78));
  }
  set props(value) {
    set(__privateGet(this, _props78), value);
  }
};
_props78 = new WeakMap();
var CommandLabelState = _CommandLabelState;
var _props79;
var _CommandViewportState = class _CommandViewportState {
  constructor(opts, list) {
    __publicField(this, "opts");
    __publicField(this, "list");
    __publicField(this, "attachment");
    __privateAdd(this, _props79, user_derived(() => ({
      id: this.opts.id.current,
      [commandAttrs.viewport]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.list = list;
    this.attachment = attachRef(this.opts.ref, (v) => this.list.root.viewportNode = v);
    watch(
      [
        () => this.opts.ref.current,
        () => this.list.opts.ref.current
      ],
      ([node, listNode]) => {
        if (node === null || listNode === null) return;
        let aF;
        const observer = new ResizeObserver(() => {
          aF = requestAnimationFrame(() => {
            const height = node.offsetHeight;
            listNode.style.setProperty("--bits-command-list-height", `${height.toFixed(1)}px`);
          });
        });
        observer.observe(node);
        return () => {
          cancelAnimationFrame(aF);
          observer.unobserve(node);
        };
      }
    );
  }
  static create(opts) {
    return new _CommandViewportState(opts, CommandListContext.get());
  }
  get props() {
    return get(__privateGet(this, _props79));
  }
  set props(value) {
    set(__privateGet(this, _props79), value);
  }
};
_props79 = new WeakMap();
var CommandViewportState = _CommandViewportState;

// node_modules/bits-ui/dist/bits/command/components/_command-label.svelte
var root5 = from_html(`<label><!></label>`);
function _command_label($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children"
  ]);
  const labelState = CommandLabelState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, labelState.props));
  var label = root5();
  attribute_effect(label, () => ({ ...get(mergedProps) }));
  var node = child(label);
  snippet(node, () => $$props.children ?? noop);
  reset(label);
  append($$anchor, label);
  pop();
}

// node_modules/bits-ui/dist/bits/command/components/command.svelte
var root_35 = from_html(`<!> <!>`, 1);
var root_44 = from_html(`<div><!> <!></div>`);
function Command($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  const Label2 = ($$anchor2) => {
    _command_label($$anchor2, {
      children: ($$anchor3, $$slotProps) => {
        next();
        var text2 = text();
        template_effect(() => set_text(text2, label()));
        append($$anchor3, text2);
      },
      $$slots: { default: true }
    });
  };
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), onStateChange = prop($$props, "onStateChange", 3, noop3), loop = prop($$props, "loop", 3, false), shouldFilter = prop($$props, "shouldFilter", 3, true), filter = prop($$props, "filter", 3, computeCommandScore), label = prop($$props, "label", 3, ""), vimBindings = prop($$props, "vimBindings", 3, true), disablePointerSelection = prop($$props, "disablePointerSelection", 3, false), disableInitialScroll = prop($$props, "disableInitialScroll", 3, false), columns = prop($$props, "columns", 3, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "value",
    "onValueChange",
    "onStateChange",
    "loop",
    "shouldFilter",
    "filter",
    "label",
    "vimBindings",
    "disablePointerSelection",
    "disableInitialScroll",
    "columns",
    "children",
    "child"
  ]);
  const rootState = CommandRootState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    filter: boxWith(() => filter()),
    shouldFilter: boxWith(() => shouldFilter()),
    loop: boxWith(() => loop()),
    value: boxWith(() => value(), (v) => {
      if (value() !== v) {
        value(v);
        onValueChange()(v);
      }
    }),
    vimBindings: boxWith(() => vimBindings()),
    disablePointerSelection: boxWith(() => disablePointerSelection()),
    disableInitialScroll: boxWith(() => disableInitialScroll()),
    onStateChange: boxWith(() => onStateChange()),
    columns: boxWith(() => columns())
  });
  const updateSelectedToIndex = (i) => rootState.updateSelectedToIndex(i);
  const updateSelectedByGroup = (c) => rootState.updateSelectedByGroup(c);
  const updateSelectedByItem = (c) => rootState.updateSelectedByItem(c);
  const getValidItems = () => rootState.getValidItems();
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment_2 = comment();
  var node = first_child(fragment_2);
  {
    var consequent = ($$anchor2) => {
      var fragment_3 = root_35();
      var node_1 = first_child(fragment_3);
      Label2(node_1);
      var node_2 = sibling(node_1, 2);
      snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_3);
    };
    var alternate = ($$anchor2) => {
      var div = root_44();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_3 = child(div);
      Label2(node_3);
      var node_4 = sibling(node_3, 2);
      snippet(node_4, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment_2);
  return pop({
    updateSelectedToIndex,
    updateSelectedByGroup,
    updateSelectedByItem,
    getValidItems
  });
}

// node_modules/bits-ui/dist/bits/command/components/command-empty.svelte
var root_36 = from_html(`<div><!></div>`);
function Command_empty($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child",
    "forceMount"
  ]);
  const emptyState = CommandEmptyState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    forceMount: boxWith(() => forceMount())
  });
  const mergedProps = user_derived(() => mergeProps(emptyState.props, restProps));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_36();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (emptyState.shouldRender) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/command/components/command-group.svelte
var root_243 = from_html(`<div><!></div>`);
function Command_group($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 3, ""), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "value",
    "forceMount",
    "children",
    "child"
  ]);
  const groupState = CommandGroupContainerState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    forceMount: boxWith(() => forceMount()),
    value: boxWith(() => value())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, groupState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_243();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/command/components/command-group-heading.svelte
var root_244 = from_html(`<div><!></div>`);
function Command_group_heading($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const headingState = CommandGroupHeadingState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, headingState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_244();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/command/components/command-group-items.svelte
var root_245 = from_html(`<div><!></div>`);
var root6 = from_html(`<div style="display: contents;"><!></div>`);
function Command_group_items($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const groupItemsState = CommandGroupItemsState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, groupItemsState.props));
  var div = root6();
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var div_1 = root_245();
      attribute_effect(div_1, () => ({ ...get(mergedProps) }));
      var node_2 = child(div_1);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div_1);
      append($$anchor2, div_1);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  reset(div);
  append($$anchor, div);
  pop();
}

// node_modules/bits-ui/dist/bits/command/components/command-input.svelte
var root_246 = from_html(`<input/>`);
function Command_input($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let value = prop($$props, "value", 15, ""), autofocus = prop($$props, "autofocus", 3, false), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "value",
    "autofocus",
    "id",
    "ref",
    "child"
  ]);
  const inputState = CommandInputState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    value: boxWith(() => value(), (v) => {
      value(v);
    }),
    autofocus: boxWith(() => autofocus() ?? false)
  });
  const mergedProps = user_derived(() => mergeProps(restProps, inputState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_246();
      remove_input_defaults(input);
      attribute_effect(input, () => ({ ...get(mergedProps) }));
      bind_value(input, value);
      append($$anchor2, input);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/command/components/command-item.svelte
var root_45 = from_html(`<div><!></div>`);
var root_15 = from_html(`<div style="display: contents;" data-item-wrapper=""><!></div>`);
function Command_item($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 3, ""), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), keywords = prop($$props, "keywords", 19, () => []), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "value",
    "disabled",
    "children",
    "child",
    "onSelect",
    "forceMount",
    "keywords"
  ]);
  const itemState = CommandItemState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    value: boxWith(() => value()),
    disabled: boxWith(() => disabled()),
    onSelect: boxWith(() => onSelect()),
    forceMount: boxWith(() => forceMount()),
    keywords: boxWith(() => keywords())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  key_block(node, () => itemState.root.key, ($$anchor2) => {
    var div = root_15();
    var node_1 = child(div);
    {
      var consequent_1 = ($$anchor3) => {
        var fragment_1 = comment();
        var node_2 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            snippet(node_3, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          };
          var alternate = ($$anchor4) => {
            var div_1 = root_45();
            attribute_effect(div_1, () => ({ ...get(mergedProps) }));
            var node_4 = child(div_1);
            snippet(node_4, () => $$props.children ?? noop);
            reset(div_1);
            append($$anchor4, div_1);
          };
          if_block(node_2, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_1);
      };
      if_block(node_1, ($$render) => {
        if (itemState.shouldRender) $$render(consequent_1);
      });
    }
    reset(div);
    template_effect(() => set_attribute(div, "data-value", itemState.trueValue));
    append($$anchor2, div);
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/command/components/command-link-item.svelte
var root_46 = from_html(`<a><!></a>`);
var root_16 = from_html(`<div style="display: contents;"><!></div>`);
function Command_link_item($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 3, ""), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), keywords = prop($$props, "keywords", 19, () => []), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "value",
    "disabled",
    "children",
    "child",
    "onSelect",
    "forceMount",
    "keywords"
  ]);
  const itemState = CommandItemState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    value: boxWith(() => value()),
    disabled: boxWith(() => disabled()),
    onSelect: boxWith(() => onSelect()),
    forceMount: boxWith(() => forceMount()),
    keywords: boxWith(() => keywords())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  key_block(node, () => itemState.root.key, ($$anchor2) => {
    var div = root_16();
    var node_1 = child(div);
    {
      var consequent_1 = ($$anchor3) => {
        var fragment_1 = comment();
        var node_2 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            snippet(node_3, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          };
          var alternate = ($$anchor4) => {
            var a2 = root_46();
            attribute_effect(a2, () => ({ ...get(mergedProps) }));
            var node_4 = child(a2);
            snippet(node_4, () => $$props.children ?? noop);
            reset(a2);
            append($$anchor4, a2);
          };
          if_block(node_2, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_1);
      };
      if_block(node_1, ($$render) => {
        if (itemState.shouldRender) $$render(consequent_1);
      });
    }
    reset(div);
    append($$anchor2, div);
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/command/components/command-list.svelte
var root_37 = from_html(`<div><!></div>`);
function Command_list($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "child",
    "children",
    "aria-label"
  ]);
  const listState = CommandListState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    ariaLabel: boxWith(() => $$props["aria-label"] ?? "Suggestions...")
  });
  const mergedProps = user_derived(() => mergeProps(restProps, listState.props));
  var fragment = comment();
  var node = first_child(fragment);
  key_block(node, () => listState.root._commandState.search === "", ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    {
      var consequent = ($$anchor3) => {
        var fragment_2 = comment();
        var node_2 = first_child(fragment_2);
        snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
        append($$anchor3, fragment_2);
      };
      var alternate = ($$anchor3) => {
        var div = root_37();
        attribute_effect(div, () => ({ ...get(mergedProps) }));
        var node_3 = child(div);
        snippet(node_3, () => $$props.children ?? noop);
        reset(div);
        append($$anchor3, div);
      };
      if_block(node_1, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/command/components/command-viewport.svelte
var root_247 = from_html(`<div><!></div>`);
function Command_viewport($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const listViewportState = CommandViewportState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, listViewportState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_247();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/command/components/command-loading.svelte
var root_248 = from_html(`<div><!></div>`);
function Command_loading($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let progress = prop($$props, "progress", 3, 0), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "progress",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const loadingState = CommandLoadingState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    progress: boxWith(() => progress())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, loadingState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_248();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/command/components/command-separator.svelte
var root_38 = from_html(`<div><!></div>`);
function Command_separator($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "forceMount",
    "children",
    "child"
  ]);
  const separatorState = CommandSeparatorState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    forceMount: boxWith(() => forceMount())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, separatorState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_38();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (separatorState.shouldRender) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/command/compute-command-score.js
var SCORE_CONTINUE_MATCH = 1;
var SCORE_SPACE_WORD_JUMP = 0.9;
var SCORE_NON_SPACE_WORD_JUMP = 0.8;
var SCORE_CHARACTER_JUMP = 0.17;
var SCORE_TRANSPOSITION = 0.1;
var PENALTY_SKIPPED = 0.999;
var PENALTY_CASE_MISMATCH = 0.9999;
var PENALTY_NOT_COMPLETE = 0.99;
var IS_GAP_REGEXP = /[\\/_+.#"@[({&]/;
var COUNT_GAPS_REGEXP = /[\\/_+.#"@[({&]/g;
var IS_SPACE_REGEXP = /[\s-]/;
var COUNT_SPACE_REGEXP = /[\s-]/g;
function computeCommandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, stringIndex, abbreviationIndex, memoizedResults) {
  if (abbreviationIndex === abbreviation.length) {
    if (stringIndex === string.length)
      return SCORE_CONTINUE_MATCH;
    return PENALTY_NOT_COMPLETE;
  }
  const memoizeKey = `${stringIndex},${abbreviationIndex}`;
  if (memoizedResults[memoizeKey] !== void 0)
    return memoizedResults[memoizeKey];
  const abbreviationChar = lowerAbbreviation.charAt(abbreviationIndex);
  let index = lowerString.indexOf(abbreviationChar, stringIndex);
  let highScore = 0;
  let score, transposedScore, wordBreaks, spaceBreaks;
  while (index >= 0) {
    score = computeCommandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 1, memoizedResults);
    if (score > highScore) {
      if (index === stringIndex) {
        score *= SCORE_CONTINUE_MATCH;
      } else if (IS_GAP_REGEXP.test(string.charAt(index - 1))) {
        score *= SCORE_NON_SPACE_WORD_JUMP;
        wordBreaks = string.slice(stringIndex, index - 1).match(COUNT_GAPS_REGEXP);
        if (wordBreaks && stringIndex > 0) {
          score *= PENALTY_SKIPPED ** wordBreaks.length;
        }
      } else if (IS_SPACE_REGEXP.test(string.charAt(index - 1))) {
        score *= SCORE_SPACE_WORD_JUMP;
        spaceBreaks = string.slice(stringIndex, index - 1).match(COUNT_SPACE_REGEXP);
        if (spaceBreaks && stringIndex > 0) {
          score *= PENALTY_SKIPPED ** spaceBreaks.length;
        }
      } else {
        score *= SCORE_CHARACTER_JUMP;
        if (stringIndex > 0) {
          score *= PENALTY_SKIPPED ** (index - stringIndex);
        }
      }
      if (string.charAt(index) !== abbreviation.charAt(abbreviationIndex)) {
        score *= PENALTY_CASE_MISMATCH;
      }
    }
    if (score < SCORE_TRANSPOSITION && lowerString.charAt(index - 1) === lowerAbbreviation.charAt(abbreviationIndex + 1) || lowerAbbreviation.charAt(abbreviationIndex + 1) === lowerAbbreviation.charAt(abbreviationIndex) && lowerString.charAt(index - 1) !== lowerAbbreviation.charAt(abbreviationIndex)) {
      transposedScore = computeCommandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 2, memoizedResults);
      if (transposedScore * SCORE_TRANSPOSITION > score) {
        score = transposedScore * SCORE_TRANSPOSITION;
      }
    }
    if (score > highScore) {
      highScore = score;
    }
    index = lowerString.indexOf(abbreviationChar, index + 1);
  }
  memoizedResults[memoizeKey] = highScore;
  return highScore;
}
function formatInput(string) {
  return string.toLowerCase().replace(COUNT_SPACE_REGEXP, " ");
}
function computeCommandScore(command, search, commandKeywords) {
  command = commandKeywords && commandKeywords.length > 0 ? `${`${command} ${commandKeywords == null ? void 0 : commandKeywords.join(" ")}`}` : command;
  return computeCommandScoreInner(command, search, formatInput(command), formatInput(search), 0, 0, {});
}

// node_modules/bits-ui/dist/bits/context-menu/exports.js
var exports_exports11 = {};
__export(exports_exports11, {
  Arrow: () => Menu_arrow,
  CheckboxGroup: () => Menu_checkbox_group,
  CheckboxItem: () => Menu_checkbox_item,
  Content: () => Context_menu_content,
  ContentStatic: () => Context_menu_content_static,
  Group: () => Menu_group,
  GroupHeading: () => Menu_group_heading,
  Item: () => Menu_item,
  Portal: () => Portal,
  RadioGroup: () => Menu_radio_group,
  RadioItem: () => Menu_radio_item,
  Root: () => Context_menu,
  Separator: () => Menu_separator,
  Sub: () => Menu_sub,
  SubContent: () => Menu_sub_content,
  SubContentStatic: () => Menu_sub_content_static,
  SubTrigger: () => Menu_sub_trigger,
  Trigger: () => Context_menu_trigger
});

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu.svelte
function Context_menu($$anchor, $$props) {
  push($$props, true);
  let open = prop($$props, "open", 15, false), dir = prop($$props, "dir", 3, "ltr"), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  const root18 = MenuRootState.create({
    variant: boxWith(() => "context-menu"),
    dir: boxWith(() => dir()),
    onClose: () => {
      var _a;
      open(false);
      (_a = onOpenChange()) == null ? void 0 : _a(false);
    }
  });
  MenuMenuState.create(
    {
      open: boxWith(() => open(), (v) => {
        open(v);
        onOpenChange()(v);
      }),
      onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
    },
    root18
  );
  Floating_layer($$anchor, {
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      snippet(node, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-sub.svelte
function Menu_sub($$anchor, $$props) {
  push($$props, true);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  MenuSubmenuState.create({
    open: boxWith(() => open(), (v) => {
      var _a;
      open(v);
      (_a = onOpenChange()) == null ? void 0 : _a(v);
    }),
    onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
  });
  Floating_layer($$anchor, {
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      snippet(node, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-item.svelte
var root_249 = from_html(`<div><!></div>`);
function Menu_item($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), closeOnSelect = prop($$props, "closeOnSelect", 3, true), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "ref",
    "id",
    "disabled",
    "onSelect",
    "closeOnSelect"
  ]);
  const itemState = MenuItemState.create({
    id: boxWith(() => id()),
    disabled: boxWith(() => disabled()),
    onSelect: boxWith(() => onSelect()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    closeOnSelect: boxWith(() => closeOnSelect())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_249();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-group.svelte
var root_250 = from_html(`<div><!></div>`);
function Menu_group($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const groupState = MenuGroupState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, groupState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_250();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-group-heading.svelte
var root_251 = from_html(`<div><!></div>`);
function Menu_group_heading($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const groupHeadingState = MenuGroupHeadingState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, groupHeadingState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_251();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-arrow.svelte
function Menu_arrow($$anchor, $$props) {
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref"]);
  const arrowState = MenuArrowState.create();
  const mergedProps = user_derived(() => mergeProps(restProps, arrowState.props));
  Floating_layer_arrow($$anchor, spread_props(() => get(mergedProps), {
    get ref() {
      return ref();
    },
    set ref($$value) {
      ref($$value);
    }
  }));
  pop();
}

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content.svelte
var root_47 = from_html(`<div><div><!></div></div>`);
var root_93 = from_html(`<div><div><!></div></div>`);
function Context_menu_content($$anchor, $$props) {
  push($$props, true);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, true), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), trapFocus = prop($$props, "trapFocus", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "child",
    "children",
    "ref",
    "loop",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "preventScroll",
    "onEscapeKeydown",
    "forceMount",
    "trapFocus"
  ]);
  const contentState = MenuContentState.create({
    id: boxWith(() => id()),
    loop: boxWith(() => loop()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: boxWith(() => onCloseAutoFocus())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    if (e.target && e.target instanceof Element) {
      const subContentSelector = `[${contentState.parentMenu.root.getBitsAttr("sub-content")}]`;
      if (e.target.closest(subContentSelector)) return;
    }
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function isValidEvent2(e) {
    if ("button" in e && e.button === 2) {
      const target = e.target;
      if (!target) return false;
      const isAnotherContextTrigger = target.closest(`[${CONTEXT_MENU_TRIGGER_ATTR}]`) !== contentState.parentMenu.triggerNode;
      return isAnotherContextTrigger;
    }
    return false;
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("context-menu")
          }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_47();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_3 = child(div_1);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          side: "right",
          sideOffset: 2,
          align: "start",
          get enabled() {
            return contentState.parentMenu.opts.open.current;
          },
          get preventScroll() {
            return preventScroll();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          get onOpenAutoFocus() {
            return onOpenAutoFocus();
          },
          isValidEvent: isValidEvent2,
          get trapFocus() {
            return trapFocus();
          },
          get loop() {
            return loop();
          },
          get id() {
            return id();
          },
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("context-menu")
              }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_93();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_6 = child(div_3);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              side: "right",
              sideOffset: 2,
              align: "start",
              get open() {
                return contentState.parentMenu.opts.open.current;
              },
              get preventScroll() {
                return preventScroll();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              get onOpenAutoFocus() {
                return onOpenAutoFocus();
              },
              isValidEvent: isValidEvent2,
              get trapFocus() {
                return trapFocus();
              },
              get loop() {
                return loop();
              },
              get id() {
                return id();
              },
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content-static.svelte
var root_48 = from_html(`<div><!></div>`);
var root_94 = from_html(`<div><!></div>`);
function Context_menu_content_static($$anchor, $$props) {
  push($$props, true);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, true), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "child",
    "children",
    "ref",
    "loop",
    "onInteractOutside",
    "onCloseAutoFocus",
    "preventScroll",
    "onEscapeKeydown",
    "forceMount"
  ]);
  const contentState = MenuContentState.create({
    id: boxWith(() => id()),
    loop: boxWith(() => loop()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: boxWith(() => onCloseAutoFocus())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function isValidEvent2(e) {
    if ("button" in e && e.button === 2) {
      const target = e.target;
      if (!target) return false;
      const isAnotherContextTrigger = target.closest(`[${CONTEXT_MENU_TRIGGER_ATTR}]`) !== contentState.parentMenu.triggerNode;
      return isAnotherContextTrigger;
    }
    return false;
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("context-menu")
          }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_48();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_3 = child(div);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          isStatic: true,
          side: "right",
          sideOffset: 2,
          align: "start",
          get enabled() {
            return contentState.parentMenu.opts.open.current;
          },
          get preventScroll() {
            return preventScroll();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          isValidEvent: isValidEvent2,
          trapFocus: true,
          get loop() {
            return loop();
          },
          get forceMount() {
            return forceMount();
          },
          get id() {
            return id();
          },
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("context-menu")
              }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_94();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_6 = child(div_1);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              isStatic: true,
              side: "right",
              sideOffset: 2,
              align: "start",
              get open() {
                return contentState.parentMenu.opts.open.current;
              },
              get preventScroll() {
                return preventScroll();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              isValidEvent: isValidEvent2,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              get id() {
                return id();
              },
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-trigger.svelte
var root_39 = from_html(`<div><!></div>`);
function Context_menu_trigger($$anchor, $$props) {
  push($$props, true);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "child",
    "children",
    "disabled"
  ]);
  const triggerState = ContextMenuTriggerState.create({
    id: boxWith(() => id()),
    disabled: boxWith(() => disabled()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props, { style: { pointerEvents: "auto" } }, { style: $$props.style }));
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Anchor, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      get id() {
        return id();
      },
      get virtualEl() {
        return triggerState.virtualElement;
      },
      get ref() {
        return triggerState.opts.ref;
      },
      children: ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          };
          var alternate = ($$anchor4) => {
            var div = root_39();
            attribute_effect(div, () => ({ ...get(mergedProps) }));
            var node_3 = child(div);
            snippet(node_3, () => $$props.children ?? noop);
            reset(div);
            append($$anchor4, div);
          };
          if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_1);
      },
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-radio-item.svelte
var root_252 = from_html(`<div><!></div>`);
function Menu_radio_item($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), onSelect = prop($$props, "onSelect", 3, noop3), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), closeOnSelect = prop($$props, "closeOnSelect", 3, true), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "value",
    "onSelect",
    "id",
    "disabled",
    "closeOnSelect"
  ]);
  const radioItemState = MenuRadioItemState.create({
    value: boxWith(() => $$props.value),
    id: boxWith(() => id()),
    disabled: boxWith(() => disabled()),
    onSelect: boxWith(() => handleSelect),
    ref: boxWith(() => ref(), (v) => ref(v)),
    closeOnSelect: boxWith(() => closeOnSelect())
  });
  function handleSelect(e) {
    onSelect()(e);
    if (e.defaultPrevented) return;
    radioItemState.selectValue();
  }
  const mergedProps = user_derived(() => mergeProps(restProps, radioItemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        checked: radioItemState.isChecked
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_252();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ checked: radioItemState.isChecked }));
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-separator.svelte
var root_253 = from_html(`<div><!></div>`);
function Menu_separator($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "child",
    "children"
  ]);
  const separatorState = MenuSeparatorState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, separatorState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_253();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-radio-group.svelte
var root_254 = from_html(`<div><!></div>`);
function Menu_radio_group($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "children",
    "child",
    "ref",
    "value",
    "onValueChange"
  ]);
  const radioGroupState = MenuRadioGroupState.create({
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    ref: boxWith(() => ref(), (v) => ref(v)),
    id: boxWith(() => id())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, radioGroupState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_254();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-content.svelte
var root_49 = from_html(`<div><div><!></div></div>`);
var root_95 = from_html(`<div><div><!></div></div>`);
function Menu_sub_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "defer-otherwise-close"), escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "defer-otherwise-close"), onOpenAutoFocusProp = prop($$props, "onOpenAutoFocus", 3, noop3), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), side = prop($$props, "side", 3, "right"), trapFocus = prop($$props, "trapFocus", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child",
    "loop",
    "onInteractOutside",
    "forceMount",
    "onEscapeKeydown",
    "interactOutsideBehavior",
    "escapeKeydownBehavior",
    "onOpenAutoFocus",
    "onCloseAutoFocus",
    "onFocusOutside",
    "side",
    "trapFocus"
  ]);
  const subContentState = MenuContentState.create({
    id: boxWith(() => id()),
    loop: boxWith(() => loop()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    isSub: true,
    onCloseAutoFocus: boxWith(() => handleCloseAutoFocus)
  });
  function onkeydown(e) {
    const isKeyDownInside = e.currentTarget.contains(e.target);
    const isCloseKey = SUB_CLOSE_KEYS[subContentState.parentMenu.root.opts.dir.current].includes(e.key);
    if (isKeyDownInside && isCloseKey) {
      subContentState.parentMenu.onClose();
      const triggerNode = subContentState.parentMenu.triggerNode;
      triggerNode == null ? void 0 : triggerNode.focus();
      e.preventDefault();
    }
  }
  const dataAttr = user_derived(() => subContentState.parentMenu.root.getBitsAttr("sub-content"));
  const mergedProps = user_derived(() => mergeProps(restProps, subContentState.props, {
    side: side(),
    onkeydown,
    [get(dataAttr)]: ""
  }));
  function handleOpenAutoFocus(e) {
    onOpenAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
    if (subContentState.parentMenu.root.isUsingKeyboard && subContentState.parentMenu.contentNode) {
      MenuOpenEvent.dispatch(subContentState.parentMenu.contentNode);
    }
  }
  function handleCloseAutoFocus(e) {
    onCloseAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
  }
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleOnFocusOutside(e) {
    var _a;
    onFocusOutside()(e);
    if (e.defaultPrevented) return;
    if (!isHTMLElement2(e.target)) return;
    if (e.target.id !== ((_a = subContentState.parentMenu.triggerNode) == null ? void 0 : _a.id)) {
      subContentState.parentMenu.onClose();
    }
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                wrapperProps: wrapperProps(),
                ...subContentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_49();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_3 = child(div_1);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), {
          get ref() {
            return subContentState.opts.ref;
          },
          get interactOutsideBehavior() {
            return interactOutsideBehavior();
          },
          get escapeKeydownBehavior() {
            return escapeKeydownBehavior();
          },
          onOpenAutoFocus: handleOpenAutoFocus,
          get enabled() {
            return subContentState.parentMenu.opts.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onFocusOutside: handleOnFocusOutside,
          preventScroll: false,
          get loop() {
            return loop();
          },
          get trapFocus() {
            return trapFocus();
          },
          get shouldRender() {
            return subContentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    wrapperProps: wrapperProps(),
                    ...subContentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_95();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_6 = child(div_3);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), {
              get ref() {
                return subContentState.opts.ref;
              },
              get interactOutsideBehavior() {
                return interactOutsideBehavior();
              },
              get escapeKeydownBehavior() {
                return escapeKeydownBehavior();
              },
              onCloseAutoFocus: handleCloseAutoFocus,
              onOpenAutoFocus: handleOpenAutoFocus,
              get open() {
                return subContentState.parentMenu.opts.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onFocusOutside: handleOnFocusOutside,
              preventScroll: false,
              get loop() {
                return loop();
              },
              get trapFocus() {
                return trapFocus();
              },
              get shouldRender() {
                return subContentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-content-static.svelte
var root_410 = from_html(`<div><!></div>`);
var root_96 = from_html(`<div><!></div>`);
function Menu_sub_content_static($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "defer-otherwise-close"), escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "defer-otherwise-close"), onOpenAutoFocusProp = prop($$props, "onOpenAutoFocus", 3, noop3), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), trapFocus = prop($$props, "trapFocus", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child",
    "loop",
    "onInteractOutside",
    "forceMount",
    "onEscapeKeydown",
    "interactOutsideBehavior",
    "escapeKeydownBehavior",
    "onOpenAutoFocus",
    "onCloseAutoFocus",
    "onFocusOutside",
    "trapFocus"
  ]);
  const subContentState = MenuContentState.create({
    id: boxWith(() => id()),
    loop: boxWith(() => loop()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: boxWith(() => handleCloseAutoFocus),
    isSub: true
  });
  function onkeydown(e) {
    const isKeyDownInside = e.currentTarget.contains(e.target);
    const isCloseKey = SUB_CLOSE_KEYS[subContentState.parentMenu.root.opts.dir.current].includes(e.key);
    if (isKeyDownInside && isCloseKey) {
      subContentState.parentMenu.onClose();
      const triggerNode = subContentState.parentMenu.triggerNode;
      triggerNode == null ? void 0 : triggerNode.focus();
      e.preventDefault();
    }
  }
  const dataAttr = user_derived(() => subContentState.parentMenu.root.getBitsAttr("sub-content"));
  const mergedProps = user_derived(() => mergeProps(restProps, subContentState.props, { onkeydown, [get(dataAttr)]: "" }));
  function handleOpenAutoFocus(e) {
    onOpenAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    afterTick(() => {
      e.preventDefault();
      if (subContentState.parentMenu.root.isUsingKeyboard) {
        const subContentEl = subContentState.parentMenu.contentNode;
        subContentEl == null ? void 0 : subContentEl.focus();
      }
    });
  }
  function handleCloseAutoFocus(e) {
    onCloseAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
  }
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleOnFocusOutside(e) {
    var _a;
    onFocusOutside()(e);
    if (e.defaultPrevented) return;
    if (!isHTMLElement2(e.target)) return;
    if (e.target.id !== ((_a = subContentState.parentMenu.triggerNode) == null ? void 0 : _a.id)) {
      subContentState.parentMenu.onClose();
    }
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                ...subContentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_410();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_3 = child(div);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), {
          get ref() {
            return subContentState.opts.ref;
          },
          get interactOutsideBehavior() {
            return interactOutsideBehavior();
          },
          get escapeKeydownBehavior() {
            return escapeKeydownBehavior();
          },
          onOpenAutoFocus: handleOpenAutoFocus,
          get enabled() {
            return subContentState.parentMenu.opts.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onFocusOutside: handleOnFocusOutside,
          preventScroll: false,
          get loop() {
            return loop();
          },
          get trapFocus() {
            return trapFocus();
          },
          isStatic: true,
          get shouldRender() {
            return subContentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    ...subContentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_96();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_6 = child(div_1);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), {
              get ref() {
                return subContentState.opts.ref;
              },
              get interactOutsideBehavior() {
                return interactOutsideBehavior();
              },
              get escapeKeydownBehavior() {
                return escapeKeydownBehavior();
              },
              onCloseAutoFocus: handleCloseAutoFocus,
              onOpenAutoFocus: handleOpenAutoFocus,
              get open() {
                return subContentState.parentMenu.opts.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onFocusOutside: handleOnFocusOutside,
              preventScroll: false,
              get loop() {
                return loop();
              },
              get trapFocus() {
                return trapFocus();
              },
              isStatic: true,
              get shouldRender() {
                return subContentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-trigger.svelte
var root_310 = from_html(`<div><!></div>`);
function Menu_sub_trigger($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), onSelect = prop($$props, "onSelect", 3, noop3), openDelay = prop($$props, "openDelay", 3, 100), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "disabled",
    "ref",
    "children",
    "child",
    "onSelect",
    "openDelay"
  ]);
  const subTriggerState = MenuSubTriggerState.create({
    disabled: boxWith(() => disabled()),
    onSelect: boxWith(() => onSelect()),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    openDelay: boxWith(() => openDelay())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, subTriggerState.props));
  Floating_layer_anchor($$anchor, {
    get id() {
      return id();
    },
    get ref() {
      return subTriggerState.opts.ref;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_1 = first_child(fragment_2);
          snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_310();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_2 = child(div);
          snippet(node_2, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-item.svelte
var root_255 = from_html(`<div><!></div>`);
function Menu_checkbox_item($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), checked = prop($$props, "checked", 15, false), id = prop($$props, "id", 19, () => createId(uid)), onCheckedChange = prop($$props, "onCheckedChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), closeOnSelect = prop($$props, "closeOnSelect", 3, true), indeterminate = prop($$props, "indeterminate", 15, false), onIndeterminateChange = prop($$props, "onIndeterminateChange", 3, noop3), value = prop($$props, "value", 3, ""), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "ref",
    "checked",
    "id",
    "onCheckedChange",
    "disabled",
    "onSelect",
    "closeOnSelect",
    "indeterminate",
    "onIndeterminateChange",
    "value"
  ]);
  const group = MenuCheckboxGroupContext.getOr(null);
  if (group && value()) {
    if (group.opts.value.current.includes(value())) {
      checked(true);
    } else {
      checked(false);
    }
  }
  watch.pre(() => value(), () => {
    if (group && value()) {
      if (group.opts.value.current.includes(value())) {
        checked(true);
      } else {
        checked(false);
      }
    }
  });
  const checkboxItemState = MenuCheckboxItemState.create(
    {
      checked: boxWith(() => checked(), (v) => {
        if (v !== checked()) {
          checked(v);
          onCheckedChange()(v);
        }
      }),
      id: boxWith(() => id()),
      disabled: boxWith(() => disabled()),
      onSelect: boxWith(() => handleSelect),
      ref: boxWith(() => ref(), (v) => ref(v)),
      closeOnSelect: boxWith(() => closeOnSelect()),
      indeterminate: boxWith(() => indeterminate(), (v) => {
        if (v !== indeterminate()) {
          indeterminate(v);
          onIndeterminateChange()(v);
        }
      }),
      value: boxWith(() => value())
    },
    group
  );
  function handleSelect(e) {
    onSelect()(e);
    if (e.defaultPrevented) return;
    checkboxItemState.toggleChecked();
  }
  const mergedProps = user_derived(() => mergeProps(restProps, checkboxItemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        checked: checked(),
        indeterminate: indeterminate(),
        props: get(mergedProps)
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_255();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({
        checked: checked(),
        indeterminate: indeterminate()
      }));
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-group.svelte
var root_256 = from_html(`<div><!></div>`);
function Menu_checkbox_group($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 31, () => proxy([])), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "children",
    "child",
    "ref",
    "value",
    "onValueChange"
  ]);
  const checkboxGroupState = MenuCheckboxGroupState.create({
    value: boxWith(() => snapshot(value()), (v) => {
      value(snapshot(v));
      onValueChange()(v);
    }),
    onValueChange: boxWith(() => onValueChange()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    id: boxWith(() => id())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, checkboxGroupState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_256();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-field/exports.js
var exports_exports12 = {};
__export(exports_exports12, {
  Input: () => Date_field_input,
  Label: () => Date_field_label,
  Root: () => Date_field,
  Segment: () => Date_field_segment
});

// node_modules/bits-ui/dist/bits/date-field/date-field.svelte.js
var dateFieldAttrs = createBitsAttrs({
  component: "date-field",
  parts: ["input", "label", "segment"]
});
var SEGMENT_CONFIGS = {
  day: {
    min: 1,
    max: (root18) => {
      const segmentMonthValue = root18.segmentValues.month;
      const placeholder = root18.value.current ?? root18.placeholder.current;
      return segmentMonthValue ? getDaysInMonth(placeholder.set({ month: Number.parseInt(segmentMonthValue) })) : getDaysInMonth(placeholder);
    },
    cycle: 1,
    padZero: true
  },
  month: {
    min: 1,
    max: 12,
    cycle: 1,
    padZero: true,
    getAnnouncement: (month, root18) => {
      if (!root18.placeholder.current) return "";
      return `${month} - ${root18.formatter.fullMonth(toDate(root18.placeholder.current.set({ month })))}`;
    }
  },
  year: { min: 1, max: 9999, cycle: 1, padZero: false },
  hour: {
    min: (root18) => root18.hourCycle.current === 12 ? 1 : 0,
    max: (root18) => {
      if (root18.hourCycle.current === 24) return 23;
      if (root18.hourCycle.current === 12) return 12;
      const inferredHourCycle = getDefaultHourCycle(root18.locale.current);
      return inferredHourCycle === 12 ? 12 : 23;
    },
    cycle: 1,
    canBeZero: true,
    padZero: true
  },
  minute: {
    min: 0,
    max: 59,
    cycle: 1,
    canBeZero: true,
    padZero: true
  },
  second: {
    min: 0,
    max: 59,
    cycle: 1,
    canBeZero: true,
    padZero: true
  }
};
var DateFieldRootContext = new Context("DateField.Root");
var _segmentValues, _readonlySegmentsSet, _fieldNode, _labelNode3, _descriptionNode2, _validationNode, _dayPeriodNode, _name2, _DateFieldRootState_instances, clearUpdating_fn, _validationStatus, _isInvalid2, _inferredGranularity, _dateRef, _allSegmentContent, _segmentContents, getLabelledBy_fn;
var _DateFieldRootState = class _DateFieldRootState {
  constructor(props, rangeRoot) {
    __privateAdd(this, _DateFieldRootState_instances);
    __publicField(this, "value");
    __publicField(this, "placeholder");
    __publicField(this, "validate");
    __publicField(this, "minValue");
    __publicField(this, "maxValue");
    __publicField(this, "disabled");
    __publicField(this, "readonly");
    __publicField(this, "granularity");
    __publicField(this, "readonlySegments");
    __publicField(this, "hourCycle");
    __publicField(this, "locale");
    __publicField(this, "hideTimeZone");
    __publicField(this, "required");
    __publicField(this, "onInvalid");
    __publicField(this, "errorMessageId");
    __publicField(this, "isInvalidProp");
    __publicField(this, "descriptionId", useId());
    __publicField(this, "formatter");
    __publicField(this, "initialSegments");
    __privateAdd(this, _segmentValues, state());
    __publicField(this, "announcer");
    __privateAdd(this, _readonlySegmentsSet, user_derived(() => new Set(this.readonlySegments.current)));
    __publicField(this, "segmentStates", initSegmentStates());
    __privateAdd(this, _fieldNode, state(null));
    __privateAdd(this, _labelNode3, state(null));
    __privateAdd(this, _descriptionNode2, state(null));
    __privateAdd(this, _validationNode, state(null));
    __publicField(this, "states", initSegmentStates());
    __privateAdd(this, _dayPeriodNode, state(null));
    __publicField(this, "rangeRoot");
    __privateAdd(this, _name2, state(""));
    __publicField(this, "domContext", new DOMContext(() => null));
    __privateAdd(this, _validationStatus, user_derived(() => {
      var _a, _b;
      const value = this.value.current;
      if (!value) return false;
      const msg = (_b = (_a = this.validate).current) == null ? void 0 : _b.call(_a, value);
      if (msg) {
        return { reason: "custom", message: msg };
      }
      const minValue = this.minValue.current;
      if (minValue && isBefore(value, minValue)) {
        return { reason: "min" };
      }
      const maxValue = this.maxValue.current;
      if (maxValue && isBefore(maxValue, value)) {
        return { reason: "max" };
      }
      return false;
    }));
    __privateAdd(this, _isInvalid2, user_derived(() => {
      if (this.validationStatus === false) return false;
      if (this.isInvalidProp.current) return true;
      return true;
    }));
    __privateAdd(this, _inferredGranularity, user_derived(() => {
      const granularity = this.granularity.current;
      if (granularity) return granularity;
      const inferred = inferGranularity(this.placeholder.current, this.granularity.current);
      return inferred;
    }));
    __privateAdd(this, _dateRef, user_derived(() => this.value.current !== void 0 ? this.value.current : this.placeholder.current));
    __privateAdd(this, _allSegmentContent, user_derived(() => {
      return createContent({
        segmentValues: this.segmentValues,
        formatter: this.formatter,
        locale: this.locale.current,
        granularity: this.inferredGranularity,
        dateRef: this.dateRef,
        hideTimeZone: this.hideTimeZone.current,
        hourCycle: this.hourCycle.current
      });
    }));
    __privateAdd(this, _segmentContents, user_derived(() => this.allSegmentContent.arr));
    __publicField(this, "sharedSegmentAttrs", {
      role: "spinbutton",
      contenteditable: "true",
      tabindex: 0,
      spellcheck: false,
      inputmode: "numeric",
      autocorrect: "off",
      enterkeyhint: "next",
      style: { caretColor: "transparent" }
    });
    this.rangeRoot = rangeRoot;
    this.value = props.value;
    this.placeholder = rangeRoot ? rangeRoot.opts.placeholder : props.placeholder;
    this.validate = rangeRoot ? simpleBox(void 0) : props.validate;
    this.minValue = rangeRoot ? rangeRoot.opts.minValue : props.minValue;
    this.maxValue = rangeRoot ? rangeRoot.opts.maxValue : props.maxValue;
    this.disabled = rangeRoot ? rangeRoot.opts.disabled : props.disabled;
    this.readonly = rangeRoot ? rangeRoot.opts.readonly : props.readonly;
    this.granularity = rangeRoot ? rangeRoot.opts.granularity : props.granularity;
    this.readonlySegments = rangeRoot ? rangeRoot.opts.readonlySegments : props.readonlySegments;
    this.hourCycle = rangeRoot ? rangeRoot.opts.hourCycle : props.hourCycle;
    this.locale = rangeRoot ? rangeRoot.opts.locale : props.locale;
    this.hideTimeZone = rangeRoot ? rangeRoot.opts.hideTimeZone : props.hideTimeZone;
    this.required = rangeRoot ? rangeRoot.opts.required : props.required;
    this.onInvalid = rangeRoot ? rangeRoot.opts.onInvalid : props.onInvalid;
    this.errorMessageId = rangeRoot ? rangeRoot.opts.errorMessageId : props.errorMessageId;
    this.isInvalidProp = props.isInvalidProp;
    this.formatter = createFormatter({
      initialLocale: this.locale.current,
      monthFormat: boxWith(() => "long"),
      yearFormat: boxWith(() => "numeric")
    });
    this.initialSegments = initializeSegmentValues(this.inferredGranularity);
    this.segmentValues = this.initialSegments;
    this.announcer = getAnnouncer(null);
    this.getFieldNode = this.getFieldNode.bind(this);
    this.updateSegment = this.updateSegment.bind(this);
    this.handleSegmentClick = this.handleSegmentClick.bind(this);
    this.getBaseSegmentAttrs = this.getBaseSegmentAttrs.bind(this);
    user_effect(() => {
      untrack(() => {
        this.initialSegments = initializeSegmentValues(this.inferredGranularity);
      });
    });
    onMount(() => {
      this.announcer = getAnnouncer(this.domContext.getDocument());
    });
    onDestroyEffect(() => {
      if (rangeRoot) return;
      removeDescriptionElement(this.descriptionId, this.domContext.getDocument());
    });
    user_effect(() => {
      if (rangeRoot) return;
      if (this.formatter.getLocale() === this.locale.current) return;
      this.formatter.setLocale(this.locale.current);
    });
    user_effect(() => {
      if (rangeRoot) return;
      if (this.value.current) {
        const descriptionId = untrack(() => this.descriptionId);
        setDescription({
          id: descriptionId,
          formatter: this.formatter,
          value: this.value.current,
          doc: this.domContext.getDocument()
        });
      }
      const placeholder = untrack(() => this.placeholder.current);
      if (this.value.current && placeholder !== this.value.current) {
        untrack(() => {
          if (this.value.current) {
            this.placeholder.current = this.value.current;
          }
        });
      }
    });
    if (this.value.current) {
      this.syncSegmentValues(this.value.current);
    }
    user_effect(() => {
      this.locale.current;
      if (this.value.current) {
        this.syncSegmentValues(this.value.current);
      }
      __privateMethod(this, _DateFieldRootState_instances, clearUpdating_fn).call(this);
    });
    user_effect(() => {
      if (this.value.current === void 0) {
        this.segmentValues = initializeSegmentValues(this.inferredGranularity);
      }
    });
    watch(() => this.validationStatus, () => {
      var _a, _b;
      if (this.validationStatus !== false) {
        (_b = (_a = this.onInvalid).current) == null ? void 0 : _b.call(_a, this.validationStatus.reason, this.validationStatus.message);
      }
    });
  }
  static create(opts, rangeRoot) {
    return DateFieldRootContext.set(new _DateFieldRootState(opts, rangeRoot));
  }
  get segmentValues() {
    return get(__privateGet(this, _segmentValues));
  }
  set segmentValues(value) {
    set(__privateGet(this, _segmentValues), value, true);
  }
  get readonlySegmentsSet() {
    return get(__privateGet(this, _readonlySegmentsSet));
  }
  set readonlySegmentsSet(value) {
    set(__privateGet(this, _readonlySegmentsSet), value);
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode2));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode2), value, true);
  }
  get validationNode() {
    return get(__privateGet(this, _validationNode));
  }
  set validationNode(value) {
    set(__privateGet(this, _validationNode), value, true);
  }
  get dayPeriodNode() {
    return get(__privateGet(this, _dayPeriodNode));
  }
  set dayPeriodNode(value) {
    set(__privateGet(this, _dayPeriodNode), value, true);
  }
  get name() {
    return get(__privateGet(this, _name2));
  }
  set name(value) {
    set(__privateGet(this, _name2), value, true);
  }
  setName(name) {
    this.name = name;
  }
  /**
   * Sets the field node for the `DateFieldRootState` instance. We use this method so we can
   * keep `#fieldNode` private to prevent accidental usage of the incorrect field node.
   */
  setFieldNode(node) {
    set(__privateGet(this, _fieldNode), node, true);
  }
  /**
   * Gets the correct field node for the date field regardless of whether it's being
   * used in a standalone context or within a `DateRangeField` component.
   */
  getFieldNode() {
    if (!this.rangeRoot) {
      return get(__privateGet(this, _fieldNode));
    } else {
      return this.rangeRoot.fieldNode;
    }
  }
  /**
   * Sets the label node for the `DateFieldRootState` instance. We use this method so we can
   * keep `#labelNode` private to prevent accidental usage of the incorrect label node.
   */
  setLabelNode(node) {
    set(__privateGet(this, _labelNode3), node, true);
  }
  /**
   * Gets the correct label node for the date field regardless of whether it's being used in
   * a standalone context or within a `DateRangeField` component.
   */
  getLabelNode() {
    if (!this.rangeRoot) {
      return get(__privateGet(this, _labelNode3));
    }
    return this.rangeRoot.labelNode;
  }
  setValue(value) {
    this.value.current = value;
  }
  syncSegmentValues(value) {
    const dateValues = DATE_SEGMENT_PARTS.map((part) => {
      const partValue = value[part];
      if (part === "month") {
        if (this.states.month.updating) {
          return [part, this.states.month.updating];
        }
        if (partValue < 10) {
          return [part, `0${partValue}`];
        }
      }
      if (part === "day") {
        if (this.states.day.updating) {
          return [part, this.states.day.updating];
        }
        if (partValue < 10) {
          return [part, `0${partValue}`];
        }
      }
      if (part === "year") {
        if (this.states.year.updating) {
          return [part, this.states.year.updating];
        }
        const valueDigits = `${partValue}`.length;
        const diff = 4 - valueDigits;
        if (diff > 0) {
          return [part, `${"0".repeat(diff)}${partValue}`];
        }
      }
      return [part, `${partValue}`];
    });
    if ("hour" in value) {
      const timeValues = EDITABLE_TIME_SEGMENT_PARTS.map((part) => {
        if (part === "dayPeriod") {
          if (this.states.dayPeriod.updating) {
            return [part, this.states.dayPeriod.updating];
          } else {
            return [
              part,
              this.formatter.dayPeriod(toDate(value))
            ];
          }
        } else if (part === "hour") {
          if (this.states.hour.updating) {
            return [part, this.states.hour.updating];
          }
          if (value[part] !== void 0 && value[part] < 10) {
            return [part, `0${value[part]}`];
          }
          if (value[part] === 0) {
            if (this.dayPeriodNode) {
              return [part, "12"];
            }
          }
        } else if (part === "minute") {
          if (this.states.minute.updating) {
            return [part, this.states.minute.updating];
          }
          if (value[part] !== void 0 && value[part] < 10) {
            return [part, `0${value[part]}`];
          }
        } else if (part === "second") {
          if (this.states.second.updating) {
            return [part, this.states.second.updating];
          }
          if (value[part] !== void 0 && value[part] < 10) {
            return [part, `0${value[part]}`];
          }
        }
        return [part, `${value[part]}`];
      });
      const mergedSegmentValues = [...dateValues, ...timeValues];
      this.segmentValues = Object.fromEntries(mergedSegmentValues);
      __privateMethod(this, _DateFieldRootState_instances, clearUpdating_fn).call(this);
      return;
    }
    this.segmentValues = Object.fromEntries(dateValues);
  }
  get validationStatus() {
    return get(__privateGet(this, _validationStatus));
  }
  set validationStatus(value) {
    set(__privateGet(this, _validationStatus), value);
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid2));
  }
  set isInvalid(value) {
    set(__privateGet(this, _isInvalid2), value);
  }
  get inferredGranularity() {
    return get(__privateGet(this, _inferredGranularity));
  }
  set inferredGranularity(value) {
    set(__privateGet(this, _inferredGranularity), value);
  }
  get dateRef() {
    return get(__privateGet(this, _dateRef));
  }
  set dateRef(value) {
    set(__privateGet(this, _dateRef), value);
  }
  get allSegmentContent() {
    return get(__privateGet(this, _allSegmentContent));
  }
  set allSegmentContent(value) {
    set(__privateGet(this, _allSegmentContent), value);
  }
  get segmentContents() {
    return get(__privateGet(this, _segmentContents));
  }
  set segmentContents(value) {
    set(__privateGet(this, _segmentContents), value);
  }
  updateSegment(part, cb) {
    const disabled = this.disabled.current;
    const readonly = this.readonly.current;
    const readonlySegmentsSet = this.readonlySegmentsSet;
    if (disabled || readonly || readonlySegmentsSet.has(part)) return;
    const prev2 = this.segmentValues;
    let newSegmentValues = prev2;
    const dateRef = this.placeholder.current;
    if (isDateAndTimeSegmentObj(prev2)) {
      const pVal = prev2[part];
      const castCb = cb;
      if (part === "month") {
        const next3 = castCb(pVal);
        this.states.month.updating = next3;
        if (next3 !== null && prev2.day !== null) {
          const date = dateRef.set({ month: Number.parseInt(next3) });
          const daysInMonth = getDaysInMonth(toDate(date));
          const prevDay = Number.parseInt(prev2.day);
          if (prevDay > daysInMonth) {
            prev2.day = `${daysInMonth}`;
          }
        }
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (part === "dayPeriod") {
        const next3 = castCb(pVal);
        this.states.dayPeriod.updating = next3;
        const date = this.value.current;
        if (date && "hour" in date) {
          const trueHour = date.hour;
          if (next3 === "AM") {
            if (trueHour >= 12) {
              prev2.hour = `${trueHour - 12}`;
            }
          } else if (next3 === "PM") {
            if (trueHour < 12) {
              prev2.hour = `${trueHour + 12}`;
            }
          }
        }
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (part === "hour") {
        const next3 = castCb(pVal);
        this.states.hour.updating = next3;
        if (next3 !== null && prev2.dayPeriod !== null) {
          const dayPeriod = this.formatter.dayPeriod(toDate(dateRef.set({ hour: Number.parseInt(next3) })), this.hourCycle.current);
          if (dayPeriod === "AM" || dayPeriod === "PM") {
            prev2.dayPeriod = dayPeriod;
          }
        }
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (part === "minute") {
        const next3 = castCb(pVal);
        this.states.minute.updating = next3;
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (part === "second") {
        const next3 = castCb(pVal);
        this.states.second.updating = next3;
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (part === "year") {
        const next3 = castCb(pVal);
        this.states.year.updating = next3;
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (part === "day") {
        const next3 = castCb(pVal);
        this.states.day.updating = next3;
        newSegmentValues = { ...prev2, [part]: next3 };
      } else {
        const next3 = castCb(pVal);
        newSegmentValues = { ...prev2, [part]: next3 };
      }
    } else if (isDateSegmentPart(part)) {
      const pVal = prev2[part];
      const castCb = cb;
      const next3 = castCb(pVal);
      if (part === "month" && next3 !== null && prev2.day !== null) {
        this.states.month.updating = next3;
        const date = dateRef.set({ month: Number.parseInt(next3) });
        const daysInMonth = getDaysInMonth(toDate(date));
        if (Number.parseInt(prev2.day) > daysInMonth) {
          prev2.day = `${daysInMonth}`;
        }
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (part === "year") {
        const next4 = castCb(pVal);
        this.states.year.updating = next4;
        newSegmentValues = { ...prev2, [part]: next4 };
      } else if (part === "day") {
        const next4 = castCb(pVal);
        this.states.day.updating = next4;
        newSegmentValues = { ...prev2, [part]: next4 };
      } else {
        newSegmentValues = { ...prev2, [part]: next3 };
      }
    }
    this.segmentValues = newSegmentValues;
    if (areAllSegmentsFilled(newSegmentValues, get(__privateGet(this, _fieldNode)))) {
      this.setValue(getValueFromSegments({
        segmentObj: newSegmentValues,
        fieldNode: get(__privateGet(this, _fieldNode)),
        dateRef: this.placeholder.current
      }));
    } else {
      this.setValue(void 0);
      this.segmentValues = newSegmentValues;
    }
  }
  handleSegmentClick(e) {
    if (this.disabled.current) {
      e.preventDefault();
    }
  }
  getBaseSegmentAttrs(part, segmentId) {
    var _a, _b;
    const inReadonlySegments = this.readonlySegmentsSet.has(part);
    const defaultAttrs = {
      "aria-invalid": boolToStrTrueOrUndef(this.isInvalid),
      "aria-disabled": boolToStr(this.disabled.current),
      "aria-readonly": boolToStr(this.readonly.current || inReadonlySegments),
      "data-invalid": boolToEmptyStrOrUndef(this.isInvalid),
      "data-disabled": boolToEmptyStrOrUndef(this.disabled.current),
      "data-readonly": boolToEmptyStrOrUndef(this.readonly.current || inReadonlySegments),
      "data-segment": `${part}`,
      [dateFieldAttrs.segment]: ""
    };
    if (part === "literal") return defaultAttrs;
    const descriptionId = (_a = this.descriptionNode) == null ? void 0 : _a.id;
    const hasDescription = isFirstSegment(segmentId, get(__privateGet(this, _fieldNode))) && descriptionId;
    const errorMsgId = (_b = this.errorMessageId) == null ? void 0 : _b.current;
    const describedBy = hasDescription ? `${descriptionId} ${this.isInvalid && errorMsgId ? errorMsgId : ""}` : void 0;
    const contenteditable = !(this.readonly.current || inReadonlySegments || this.disabled.current);
    return {
      ...defaultAttrs,
      "aria-labelledby": __privateMethod(this, _DateFieldRootState_instances, getLabelledBy_fn).call(this, segmentId),
      contenteditable: contenteditable ? "true" : void 0,
      "aria-describedby": describedBy,
      tabindex: this.disabled.current ? void 0 : 0
    };
  }
};
_segmentValues = new WeakMap();
_readonlySegmentsSet = new WeakMap();
_fieldNode = new WeakMap();
_labelNode3 = new WeakMap();
_descriptionNode2 = new WeakMap();
_validationNode = new WeakMap();
_dayPeriodNode = new WeakMap();
_name2 = new WeakMap();
_DateFieldRootState_instances = new WeakSet();
clearUpdating_fn = function() {
  this.states.day.updating = null;
  this.states.month.updating = null;
  this.states.year.updating = null;
  this.states.hour.updating = null;
  this.states.minute.updating = null;
  this.states.dayPeriod.updating = null;
};
_validationStatus = new WeakMap();
_isInvalid2 = new WeakMap();
_inferredGranularity = new WeakMap();
_dateRef = new WeakMap();
_allSegmentContent = new WeakMap();
_segmentContents = new WeakMap();
getLabelledBy_fn = function(segmentId) {
  var _a;
  return `${segmentId} ${((_a = this.getLabelNode()) == null ? void 0 : _a.id) ?? ""}`;
};
var DateFieldRootState = _DateFieldRootState;
var _ariaDescribedBy, _props80;
var _DateFieldInputState = class _DateFieldInputState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "domContext");
    __publicField(this, "attachment");
    __privateAdd(this, _ariaDescribedBy, user_derived(() => {
      if (!isBrowser) return void 0;
      const doesDescriptionExist = this.domContext.getElementById(this.root.descriptionId);
      if (!doesDescriptionExist) return void 0;
      return this.root.descriptionId;
    }));
    __privateAdd(this, _props80, user_derived(() => {
      var _a;
      return {
        id: this.opts.id.current,
        role: "group",
        "aria-labelledby": ((_a = this.root.getLabelNode()) == null ? void 0 : _a.id) ?? void 0,
        "aria-describedby": get(__privateGet(this, _ariaDescribedBy)),
        "aria-disabled": boolToStr(this.root.disabled.current),
        "data-invalid": this.root.isInvalid ? "" : void 0,
        "data-disabled": boolToEmptyStrOrUndef(this.root.disabled.current),
        [dateFieldAttrs.input]: "",
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    this.domContext = new DOMContext(opts.ref);
    this.root.domContext = this.domContext;
    this.attachment = attachRef(opts.ref, (v) => this.root.setFieldNode(v));
    watch(() => this.opts.name.current, (v) => {
      this.root.setName(v);
    });
  }
  static create(opts) {
    return new _DateFieldInputState(opts, DateFieldRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props80));
  }
  set props(value) {
    set(__privateGet(this, _props80), value);
  }
};
_ariaDescribedBy = new WeakMap();
_props80 = new WeakMap();
var DateFieldInputState = _DateFieldInputState;
var _shouldRender8, _isoValue, _props81;
var _DateFieldHiddenInputState = class _DateFieldHiddenInputState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _shouldRender8, user_derived(() => this.root.name !== ""));
    __privateAdd(this, _isoValue, user_derived(() => this.root.value.current ? this.root.value.current.toString() : ""));
    __privateAdd(this, _props81, user_derived(() => {
      return {
        name: this.root.name,
        value: this.isoValue,
        required: this.root.required.current
      };
    }));
    this.root = root18;
  }
  static create() {
    return new _DateFieldHiddenInputState(DateFieldRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender8));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender8), value);
  }
  get isoValue() {
    return get(__privateGet(this, _isoValue));
  }
  set isoValue(value) {
    set(__privateGet(this, _isoValue), value);
  }
  get props() {
    return get(__privateGet(this, _props81));
  }
  set props(value) {
    set(__privateGet(this, _props81), value);
  }
};
_shouldRender8 = new WeakMap();
_isoValue = new WeakMap();
_props81 = new WeakMap();
var DateFieldHiddenInputState = _DateFieldHiddenInputState;
var _props82;
var _DateFieldLabelState = class _DateFieldLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props82, user_derived(() => ({
      id: this.opts.id.current,
      "data-invalid": boolToEmptyStrOrUndef(this.root.isInvalid),
      "data-disabled": boolToEmptyStrOrUndef(this.root.disabled.current),
      [dateFieldAttrs.label]: "",
      onclick: this.onclick,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.onclick = this.onclick.bind(this);
    this.attachment = attachRef(opts.ref, (v) => this.root.setLabelNode(v));
  }
  static create(opts) {
    return new _DateFieldLabelState(opts, DateFieldRootContext.get());
  }
  onclick(_) {
    if (this.root.disabled.current) return;
    const firstSegment = getFirstSegment(this.root.getFieldNode());
    if (!firstSegment) return;
    firstSegment.focus();
  }
  get props() {
    return get(__privateGet(this, _props82));
  }
  set props(value) {
    set(__privateGet(this, _props82), value);
  }
};
_props82 = new WeakMap();
var DateFieldLabelState = _DateFieldLabelState;
var _BaseNumericSegmentState_instances, getMax_fn, getMin_fn, getAnnouncement_fn, formatValue_fn, handleArrowUp_fn, handleArrowDown_fn, handleNumberKey_fn, handleBackspace_fn, _props83;
var BaseNumericSegmentState = class {
  constructor(opts, root18, part, config) {
    __privateAdd(this, _BaseNumericSegmentState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "announcer");
    __publicField(this, "part");
    __publicField(this, "config");
    __publicField(this, "attachment");
    __privateAdd(this, _props83, user_derived(() => {
      return {
        ...this.root.sharedSegmentAttrs,
        id: this.opts.id.current,
        ...this.getSegmentProps(),
        onkeydown: this.onkeydown,
        onfocusout: this.onfocusout,
        onclick: this.root.handleSegmentClick,
        ...this.root.getBaseSegmentAttrs(this.part, this.opts.id.current),
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    this.part = part;
    this.config = config;
    this.announcer = root18.announcer;
    this.onkeydown = this.onkeydown.bind(this);
    this.onfocusout = this.onfocusout.bind(this);
    this.attachment = attachRef(opts.ref);
  }
  onkeydown(e) {
    const placeholder = this.root.value.current ?? this.root.placeholder.current;
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if ((this.part === "hour" || this.part === "minute" || this.part === "second") && !(this.part in placeholder)) return;
    if (e.key !== kbd_constants_exports.TAB) e.preventDefault();
    if (!isAcceptableSegmentKey(e.key)) return;
    if (isArrowUp(e.key)) {
      __privateMethod(this, _BaseNumericSegmentState_instances, handleArrowUp_fn).call(this, placeholder);
      return;
    }
    if (isArrowDown(e.key)) {
      __privateMethod(this, _BaseNumericSegmentState_instances, handleArrowDown_fn).call(this, placeholder);
      return;
    }
    if (isNumberString(e.key)) {
      __privateMethod(this, _BaseNumericSegmentState_instances, handleNumberKey_fn).call(this, e);
      return;
    }
    if (isBackspace(e.key)) {
      __privateMethod(this, _BaseNumericSegmentState_instances, handleBackspace_fn).call(this, e);
      return;
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  onfocusout(_) {
    const stateKey = this.part;
    if (stateKey in this.root.states) {
      this.root.states[stateKey].hasLeftFocus = true;
    }
    if (this.config.padZero) {
      this.root.updateSegment(this.part, (prev2) => {
        if (prev2 && prev2.length === 1) {
          return `0${prev2}`;
        }
        return prev2;
      });
    }
  }
  getSegmentProps() {
    const segmentValues = this.root.segmentValues;
    const placeholder = this.root.placeholder.current;
    const isEmpty = segmentValues[this.part] === null;
    let date = placeholder;
    if (segmentValues[this.part]) {
      date = placeholder.set({
        [this.part]: Number.parseInt(segmentValues[this.part])
      });
    }
    const valueNow = date[this.part];
    const valueMin = __privateMethod(this, _BaseNumericSegmentState_instances, getMin_fn).call(this);
    const valueMax = __privateMethod(this, _BaseNumericSegmentState_instances, getMax_fn).call(this);
    let valueText = isEmpty ? "Empty" : `${valueNow}`;
    if (this.part === "hour" && "dayPeriod" in segmentValues && segmentValues.dayPeriod) {
      valueText = isEmpty ? "Empty" : `${valueNow} ${segmentValues.dayPeriod}`;
    }
    return {
      "aria-label": `${this.part}, `,
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  get props() {
    return get(__privateGet(this, _props83));
  }
  set props(value) {
    set(__privateGet(this, _props83), value);
  }
};
_BaseNumericSegmentState_instances = new WeakSet();
getMax_fn = function() {
  return typeof this.config.max === "function" ? this.config.max(this.root) : this.config.max;
};
getMin_fn = function() {
  return typeof this.config.min === "function" ? this.config.min(this.root) : this.config.min;
};
getAnnouncement_fn = function(value) {
  if (this.config.getAnnouncement) {
    return this.config.getAnnouncement(value, this.root);
  }
  return value;
};
formatValue_fn = function(value, forDisplay = true) {
  const str = String(value);
  if (forDisplay && this.config.padZero && str.length === 1) {
    return `0${value}`;
  }
  return str;
};
handleArrowUp_fn = function(placeholder) {
  const stateKey = this.part;
  if (stateKey in this.root.states) {
    this.root.states[stateKey].hasLeftFocus = false;
  }
  this.root.updateSegment(this.part, (prev2) => {
    if (prev2 === null) {
      const next4 = placeholder[this.part];
      this.announcer.announce(__privateMethod(this, _BaseNumericSegmentState_instances, getAnnouncement_fn).call(this, next4));
      return __privateMethod(this, _BaseNumericSegmentState_instances, formatValue_fn).call(this, next4);
    }
    const current = placeholder.set({ [this.part]: Number.parseInt(prev2) });
    const next3 = current.cycle(this.part, this.config.cycle)[this.part];
    this.announcer.announce(__privateMethod(this, _BaseNumericSegmentState_instances, getAnnouncement_fn).call(this, next3));
    return __privateMethod(this, _BaseNumericSegmentState_instances, formatValue_fn).call(this, next3);
  });
};
handleArrowDown_fn = function(placeholder) {
  const stateKey = this.part;
  if (stateKey in this.root.states) {
    this.root.states[stateKey].hasLeftFocus = false;
  }
  this.root.updateSegment(this.part, (prev2) => {
    if (prev2 === null) {
      const next4 = placeholder[this.part];
      this.announcer.announce(__privateMethod(this, _BaseNumericSegmentState_instances, getAnnouncement_fn).call(this, next4));
      return __privateMethod(this, _BaseNumericSegmentState_instances, formatValue_fn).call(this, next4);
    }
    const current = placeholder.set({ [this.part]: Number.parseInt(prev2) });
    const next3 = current.cycle(this.part, -this.config.cycle)[this.part];
    this.announcer.announce(__privateMethod(this, _BaseNumericSegmentState_instances, getAnnouncement_fn).call(this, next3));
    return __privateMethod(this, _BaseNumericSegmentState_instances, formatValue_fn).call(this, next3);
  });
};
handleNumberKey_fn = function(e) {
  const num = Number.parseInt(e.key);
  let moveToNext = false;
  const max = __privateMethod(this, _BaseNumericSegmentState_instances, getMax_fn).call(this);
  const maxStart = Math.floor(max / 10);
  const numIsZero = num === 0;
  const stateKey = this.part;
  this.root.updateSegment(this.part, (prev2) => {
    if (stateKey in this.root.states && this.root.states[stateKey].hasLeftFocus) {
      prev2 = null;
      this.root.states[stateKey].hasLeftFocus = false;
    }
    if (prev2 === null) {
      if (numIsZero) {
        if (stateKey in this.root.states) {
          this.root.states[stateKey].lastKeyZero = true;
        }
        this.announcer.announce("0");
        return "0";
      }
      if (stateKey in this.root.states && (this.root.states[stateKey].lastKeyZero || num > maxStart)) {
        moveToNext = true;
      }
      if (stateKey in this.root.states) {
        this.root.states[stateKey].lastKeyZero = false;
      }
      if (moveToNext && String(num).length === 1) {
        this.announcer.announce(num);
        return `0${num}`;
      }
      return `${num}`;
    }
    if (stateKey in this.root.states && this.root.states[stateKey].lastKeyZero) {
      if (num !== 0) {
        moveToNext = true;
        this.root.states[stateKey].lastKeyZero = false;
        return `0${num}`;
      }
      if (this.part === "hour" && num === 0 && this.root.hourCycle.current === 24) {
        moveToNext = true;
        this.root.states[stateKey].lastKeyZero = false;
        return `00`;
      }
      if ((this.part === "minute" || this.part === "second") && num === 0) {
        moveToNext = true;
        this.root.states[stateKey].lastKeyZero = false;
        return "00";
      }
      return prev2;
    }
    const total = Number.parseInt(prev2 + num.toString());
    if (total > max) {
      moveToNext = true;
      return `0${num}`;
    }
    moveToNext = true;
    return `${total}`;
  });
  if (moveToNext) {
    moveToNextSegment(e, this.root.getFieldNode());
  }
};
handleBackspace_fn = function(e) {
  const stateKey = this.part;
  if (stateKey in this.root.states) {
    this.root.states[stateKey].hasLeftFocus = false;
  }
  let moveToPrev = false;
  this.root.updateSegment(this.part, (prev2) => {
    if (prev2 === null) {
      moveToPrev = true;
      this.announcer.announce(null);
      return null;
    }
    if (prev2.length === 2 && prev2.startsWith("0")) {
      this.announcer.announce(null);
      return null;
    }
    const str = prev2.toString();
    if (str.length === 1) {
      this.announcer.announce(null);
      return null;
    }
    const next3 = Number.parseInt(str.slice(0, -1));
    this.announcer.announce(__privateMethod(this, _BaseNumericSegmentState_instances, getAnnouncement_fn).call(this, next3));
    return `${next3}`;
  });
  if (moveToPrev) {
    moveToPrevSegment(e, this.root.getFieldNode());
  }
};
_props83 = new WeakMap();
var _pressedKeys, _backspaceCount, _DateFieldYearSegmentState_instances, resetBackspaceCount_fn, incrementBackspaceCount_fn, handleYearNumberKey_fn, handleYearBackspace_fn;
var DateFieldYearSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "year", SEGMENT_CONFIGS.year);
    __privateAdd(this, _DateFieldYearSegmentState_instances);
    __privateAdd(this, _pressedKeys, []);
    __privateAdd(this, _backspaceCount, 0);
  }
  onkeydown(e) {
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if (e.key !== kbd_constants_exports.TAB) e.preventDefault();
    if (!isAcceptableSegmentKey(e.key)) return;
    if (isArrowUp(e.key)) {
      __privateMethod(this, _DateFieldYearSegmentState_instances, resetBackspaceCount_fn).call(this);
      super.onkeydown(e);
      return;
    }
    if (isArrowDown(e.key)) {
      __privateMethod(this, _DateFieldYearSegmentState_instances, resetBackspaceCount_fn).call(this);
      super.onkeydown(e);
      return;
    }
    if (isNumberString(e.key)) {
      __privateMethod(this, _DateFieldYearSegmentState_instances, handleYearNumberKey_fn).call(this, e);
      return;
    }
    if (isBackspace(e.key)) {
      __privateMethod(this, _DateFieldYearSegmentState_instances, handleYearBackspace_fn).call(this, e);
      return;
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  onfocusout(_) {
    this.root.states.year.hasLeftFocus = true;
    __privateSet(this, _pressedKeys, []);
    __privateMethod(this, _DateFieldYearSegmentState_instances, resetBackspaceCount_fn).call(this);
    this.root.updateSegment("year", (prev2) => {
      if (prev2 && prev2.length !== 4) {
        return prependYearZeros(Number.parseInt(prev2));
      }
      return prev2;
    });
  }
};
_pressedKeys = new WeakMap();
_backspaceCount = new WeakMap();
_DateFieldYearSegmentState_instances = new WeakSet();
resetBackspaceCount_fn = function() {
  __privateSet(this, _backspaceCount, 0);
};
incrementBackspaceCount_fn = function() {
  __privateWrapper(this, _backspaceCount)._++;
};
handleYearNumberKey_fn = function(e) {
  __privateGet(this, _pressedKeys).push(e.key);
  let moveToNext = false;
  const num = Number.parseInt(e.key);
  this.root.updateSegment("year", (prev2) => {
    if (this.root.states.year.hasLeftFocus) {
      prev2 = null;
      this.root.states.year.hasLeftFocus = false;
    }
    if (prev2 === null) {
      this.announcer.announce(num);
      return `000${num}`;
    }
    const str = prev2.toString() + num.toString();
    const mergedInt = Number.parseInt(str);
    const mergedIntDigits = String(mergedInt).length;
    if (mergedIntDigits < 4) {
      if (__privateGet(this, _backspaceCount) > 0 && __privateGet(this, _pressedKeys).length <= __privateGet(this, _backspaceCount) && str.length <= 4) {
        this.announcer.announce(mergedInt);
        return str;
      }
      this.announcer.announce(mergedInt);
      return prependYearZeros(mergedInt);
    }
    this.announcer.announce(mergedInt);
    moveToNext = true;
    const mergedIntStr = `${mergedInt}`;
    if (mergedIntStr.length > 4) {
      return mergedIntStr.slice(0, 4);
    }
    return mergedIntStr;
  });
  if (__privateGet(this, _pressedKeys).length === 4 || __privateGet(this, _pressedKeys).length === __privateGet(this, _backspaceCount)) {
    moveToNext = true;
  }
  if (moveToNext) {
    moveToNextSegment(e, this.root.getFieldNode());
  }
};
handleYearBackspace_fn = function(e) {
  __privateSet(this, _pressedKeys, []);
  __privateMethod(this, _DateFieldYearSegmentState_instances, incrementBackspaceCount_fn).call(this);
  let moveToPrev = false;
  this.root.updateSegment("year", (prev2) => {
    this.root.states.year.hasLeftFocus = false;
    if (prev2 === null) {
      moveToPrev = true;
      this.announcer.announce(null);
      return null;
    }
    const str = prev2.toString();
    if (str.length === 1) {
      this.announcer.announce(null);
      return null;
    }
    const next3 = str.slice(0, -1);
    this.announcer.announce(next3);
    return `${next3}`;
  });
  if (moveToPrev) {
    moveToPrevSegment(e, this.root.getFieldNode());
  }
};
var DateFieldDaySegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "day", SEGMENT_CONFIGS.day);
  }
};
var DateFieldMonthSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "month", SEGMENT_CONFIGS.month);
  }
};
var DateFieldHourSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "hour", SEGMENT_CONFIGS.hour);
  }
  // Override to handle special hour logic
  onkeydown(e) {
    if (isNumberString(e.key)) {
      const oldUpdateSegment = this.root.updateSegment.bind(this.root);
      this.root.updateSegment = (part, cb) => {
        const result = oldUpdateSegment(part, cb);
        if (part === "hour" && "hour" in this.root.segmentValues) {
          const hourValue = this.root.segmentValues.hour;
          if (hourValue === "0" && this.root.dayPeriodNode && this.root.hourCycle.current !== 24) {
            this.root.segmentValues.hour = "12";
          }
        }
        return result;
      };
    }
    super.onkeydown(e);
    this.root.updateSegment = this.root.updateSegment.bind(this.root);
  }
};
var DateFieldMinuteSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "minute", SEGMENT_CONFIGS.minute);
  }
};
var DateFieldSecondSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "second", SEGMENT_CONFIGS.second);
  }
};
var _announcer, _props84;
var _DateFieldDayPeriodSegmentState = class _DateFieldDayPeriodSegmentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _announcer);
    __privateAdd(this, _props84, user_derived(() => {
      const segmentValues = this.root.segmentValues;
      if (!("dayPeriod" in segmentValues)) return;
      const valueMin = 0;
      const valueMax = 12;
      const valueNow = segmentValues.dayPeriod === "AM" ? 0 : 12;
      const valueText = segmentValues.dayPeriod ?? "AM";
      return {
        ...this.root.sharedSegmentAttrs,
        id: this.opts.id.current,
        inputmode: "text",
        "aria-label": "AM/PM",
        "aria-valuemin": valueMin,
        "aria-valuemax": valueMax,
        "aria-valuenow": valueNow,
        "aria-valuetext": valueText,
        onkeydown: this.onkeydown,
        onclick: this.root.handleSegmentClick,
        ...this.root.getBaseSegmentAttrs("dayPeriod", this.opts.id.current),
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    __privateSet(this, _announcer, this.root.announcer);
    this.onkeydown = this.onkeydown.bind(this);
    this.attachment = attachRef(opts.ref, (v) => this.root.dayPeriodNode = v);
  }
  static create(opts) {
    return new _DateFieldDayPeriodSegmentState(opts, DateFieldRootContext.get());
  }
  onkeydown(e) {
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if (e.key !== kbd_constants_exports.TAB) e.preventDefault();
    if (!isAcceptableDayPeriodKey(e.key)) return;
    if (isArrowUp(e.key) || isArrowDown(e.key)) {
      this.root.updateSegment("dayPeriod", (prev2) => {
        if (prev2 === "AM") {
          const next4 = "PM";
          __privateGet(this, _announcer).announce(next4);
          return next4;
        }
        const next3 = "AM";
        __privateGet(this, _announcer).announce(next3);
        return next3;
      });
      return;
    }
    if (isBackspace(e.key)) {
      this.root.states.dayPeriod.hasLeftFocus = false;
      this.root.updateSegment("dayPeriod", () => {
        const next3 = "AM";
        __privateGet(this, _announcer).announce(next3);
        return next3;
      });
    }
    if (e.key === kbd_constants_exports.A || e.key === kbd_constants_exports.P || kbd_constants_exports.a || kbd_constants_exports.p) {
      this.root.updateSegment("dayPeriod", () => {
        const next3 = e.key === kbd_constants_exports.A || e.key === kbd_constants_exports.a ? "AM" : "PM";
        __privateGet(this, _announcer).announce(next3);
        return next3;
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  get props() {
    return get(__privateGet(this, _props84));
  }
  set props(value) {
    set(__privateGet(this, _props84), value);
  }
};
_announcer = new WeakMap();
_props84 = new WeakMap();
var DateFieldDayPeriodSegmentState = _DateFieldDayPeriodSegmentState;
var _props85;
var _DateFieldLiteralSegmentState = class _DateFieldLiteralSegmentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props85, user_derived(() => ({
      id: this.opts.id.current,
      "aria-hidden": boolToStrTrueOrUndef(true),
      ...this.root.getBaseSegmentAttrs("literal", this.opts.id.current),
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _DateFieldLiteralSegmentState(opts, DateFieldRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props85));
  }
  set props(value) {
    set(__privateGet(this, _props85), value);
  }
};
_props85 = new WeakMap();
var DateFieldLiteralSegmentState = _DateFieldLiteralSegmentState;
var _props86;
var _DateFieldTimeZoneSegmentState = class _DateFieldTimeZoneSegmentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props86, user_derived(() => ({
      role: "textbox",
      id: this.opts.id.current,
      "aria-label": "timezone, ",
      style: { caretColor: "transparent" },
      onkeydown: this.onkeydown,
      ...this.root.getBaseSegmentAttrs("timeZoneName", this.opts.id.current),
      "data-readonly": boolToEmptyStrOrUndef(true),
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.onkeydown = this.onkeydown.bind(this);
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _DateFieldTimeZoneSegmentState(opts, DateFieldRootContext.get());
  }
  onkeydown(e) {
    if (e.key !== kbd_constants_exports.TAB) e.preventDefault();
    if (this.root.disabled.current) return;
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  get props() {
    return get(__privateGet(this, _props86));
  }
  set props(value) {
    set(__privateGet(this, _props86), value);
  }
};
_props86 = new WeakMap();
var DateFieldTimeZoneSegmentState = _DateFieldTimeZoneSegmentState;
var DateFieldSegmentState = class {
  static create(part, opts) {
    const root18 = DateFieldRootContext.get();
    switch (part) {
      case "day":
        return new DateFieldDaySegmentState(opts, root18);
      case "month":
        return new DateFieldMonthSegmentState(opts, root18);
      case "year":
        return new DateFieldYearSegmentState(opts, root18);
      case "hour":
        return new DateFieldHourSegmentState(opts, root18);
      case "minute":
        return new DateFieldMinuteSegmentState(opts, root18);
      case "second":
        return new DateFieldSecondSegmentState(opts, root18);
      case "dayPeriod":
        return new DateFieldDayPeriodSegmentState(opts, root18);
      case "literal":
        return new DateFieldLiteralSegmentState(opts, root18);
      case "timeZoneName":
        return new DateFieldTimeZoneSegmentState(opts, root18);
    }
  }
};
function isAcceptableDayPeriodKey(key) {
  return isAcceptableSegmentKey(key) || key === kbd_constants_exports.A || key === kbd_constants_exports.P || key === kbd_constants_exports.a || key === kbd_constants_exports.p;
}
function isArrowUp(key) {
  return key === kbd_constants_exports.ARROW_UP;
}
function isArrowDown(key) {
  return key === kbd_constants_exports.ARROW_DOWN;
}
function isBackspace(key) {
  return key === kbd_constants_exports.BACKSPACE;
}
function prependYearZeros(year) {
  const digits = String(year).length;
  const diff = 4 - digits;
  return `${"0".repeat(diff)}${year}`;
}

// node_modules/bits-ui/dist/bits/date-field/components/date-field.svelte
function Date_field($$anchor, $$props) {
  push($$props, true);
  let disabled = prop($$props, "disabled", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), onValueChange = prop($$props, "onValueChange", 3, noop3), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), placeholder = prop($$props, "placeholder", 15), value = prop($$props, "value", 15), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), required = prop($$props, "required", 3, false);
  function handleDefaultPlaceholder(setPlaceholder = true) {
    if (placeholder() !== void 0) return placeholder();
    const defaultPlaceholder = getDefaultDate({
      granularity: $$props.granularity,
      defaultValue: value()
    });
    if (setPlaceholder) {
      placeholder(defaultPlaceholder);
    }
    return defaultPlaceholder;
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  DateFieldRootState.create({
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: boxWith(
      () => {
        if (placeholder() === void 0) return handleDefaultPlaceholder(false);
        return placeholder();
      },
      (v) => {
        if (v === void 0) return;
        placeholder(v);
        onPlaceholderChange()(v);
      }
    ),
    disabled: boxWith(() => disabled()),
    granularity: boxWith(() => $$props.granularity),
    hideTimeZone: boxWith(() => hideTimeZone()),
    hourCycle: boxWith(() => $$props.hourCycle),
    locale: resolveLocaleProp(() => $$props.locale),
    maxValue: boxWith(() => $$props.maxValue),
    minValue: boxWith(() => $$props.minValue),
    validate: boxWith(() => validate()),
    readonly: boxWith(() => readonly()),
    readonlySegments: boxWith(() => readonlySegments()),
    required: boxWith(() => required()),
    onInvalid: boxWith(() => onInvalid()),
    errorMessageId: boxWith(() => $$props.errorMessageId),
    isInvalidProp: boxWith(() => void 0)
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-field/components/date-field-hidden-input.svelte
function Date_field_hidden_input($$anchor, $$props) {
  push($$props, false);
  const hiddenInputState = DateFieldHiddenInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Hidden_input($$anchor2, spread_props(() => hiddenInputState.props));
    };
    if_block(node, ($$render) => {
      if (hiddenInputState.shouldRender) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-field/components/date-field-input.svelte
var root_257 = from_html(`<div><!></div>`);
var root7 = from_html(`<!> <!>`, 1);
function Date_field_input($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "name",
    "children",
    "child"
  ]);
  const inputState = DateFieldInputState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    name: boxWith(() => name())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, inputState.props));
  var fragment = root7();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        segments: inputState.root.segmentContents
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_257();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents }));
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  Date_field_hidden_input(node_3, {});
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-field/components/date-field-label.svelte
var root_258 = from_html(`<div><!></div>`);
function Date_field_label($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const labelState = DateFieldLabelState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, labelState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_258();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-field/components/date-field-segment.svelte
var root_259 = from_html(`<span><!></span>`);
function Date_field_segment($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child",
    "part"
  ]);
  const segmentState = DateFieldSegmentState.create($$props.part, {
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, segmentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_259();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-picker/exports.js
var exports_exports13 = {};
__export(exports_exports13, {
  Arrow: () => Popover_arrow,
  Calendar: () => Date_picker_calendar,
  Cell: () => Calendar_cell,
  Close: () => Popover_close,
  Content: () => Date_picker_content,
  ContentStatic: () => Date_picker_content_static,
  Day: () => Calendar_day,
  Grid: () => Calendar_grid,
  GridBody: () => Calendar_grid_body,
  GridHead: () => Calendar_grid_head,
  GridRow: () => Calendar_grid_row,
  HeadCell: () => Calendar_head_cell,
  Header: () => Calendar_header,
  Heading: () => Calendar_heading,
  Input: () => Date_field_input,
  Label: () => Date_field_label,
  MonthSelect: () => Calendar_month_select,
  NextButton: () => Calendar_next_button,
  Portal: () => Portal,
  PrevButton: () => Calendar_prev_button,
  Root: () => Date_picker,
  Segment: () => Date_field_segment,
  Trigger: () => Date_picker_trigger,
  YearSelect: () => Calendar_year_select
});

// node_modules/bits-ui/dist/bits/date-picker/date-picker.svelte.js
var DatePickerRootContext = new Context("DatePicker.Root");
var DatePickerRootState = class _DatePickerRootState {
  constructor(opts) {
    __publicField(this, "opts");
    this.opts = opts;
  }
  static create(opts) {
    return DatePickerRootContext.set(new _DatePickerRootState(opts));
  }
};

// node_modules/bits-ui/dist/bits/popover/popover.svelte.js
var popoverAttrs = createBitsAttrs({
  component: "popover",
  parts: [
    "root",
    "trigger",
    "content",
    "close",
    "overlay"
  ]
});
var PopoverRootContext = new Context("Popover.Root");
var _contentNode6, _triggerNode4, _overlayNode2;
var _PopoverRootState = class _PopoverRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _contentNode6, state(null));
    __publicField(this, "contentPresence");
    __privateAdd(this, _triggerNode4, state(null));
    __privateAdd(this, _overlayNode2, state(null));
    __publicField(this, "overlayPresence");
    this.opts = opts;
    this.contentPresence = new PresenceManager({
      ref: boxWith(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    this.overlayPresence = new PresenceManager({
      ref: boxWith(() => this.overlayNode),
      open: this.opts.open
    });
  }
  static create(opts) {
    return PopoverRootContext.set(new _PopoverRootState(opts));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode6));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode6), value, true);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode4));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode4), value, true);
  }
  get overlayNode() {
    return get(__privateGet(this, _overlayNode2));
  }
  set overlayNode(value) {
    set(__privateGet(this, _overlayNode2), value, true);
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  handleClose() {
    if (!this.opts.open.current) return;
    this.opts.open.current = false;
  }
};
_contentNode6 = new WeakMap();
_triggerNode4 = new WeakMap();
_overlayNode2 = new WeakMap();
var PopoverRootState = _PopoverRootState;
var _PopoverTriggerState_instances, getAriaControls_fn, _props87;
var _PopoverTriggerState = class _PopoverTriggerState {
  constructor(opts, root18) {
    __privateAdd(this, _PopoverTriggerState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props87, user_derived(() => ({
      id: this.opts.id.current,
      "aria-haspopup": "dialog",
      "aria-expanded": boolToStr(this.root.opts.open.current),
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "aria-controls": __privateMethod(this, _PopoverTriggerState_instances, getAriaControls_fn).call(this),
      [popoverAttrs.trigger]: "",
      disabled: this.opts.disabled.current,
      //
      onkeydown: this.onkeydown,
      onclick: this.onclick,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.triggerNode = v);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _PopoverTriggerState(opts, PopoverRootContext.get());
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (e.button !== 0) return;
    this.root.toggleOpen();
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (!(e.key === kbd_constants_exports.ENTER || e.key === kbd_constants_exports.SPACE)) return;
    e.preventDefault();
    this.root.toggleOpen();
  }
  get props() {
    return get(__privateGet(this, _props87));
  }
  set props(value) {
    set(__privateGet(this, _props87), value);
  }
};
_PopoverTriggerState_instances = new WeakSet();
getAriaControls_fn = function() {
  var _a, _b;
  if (this.root.opts.open.current && ((_a = this.root.contentNode) == null ? void 0 : _a.id)) {
    return (_b = this.root.contentNode) == null ? void 0 : _b.id;
  }
  return void 0;
};
_props87 = new WeakMap();
var PopoverTriggerState = _PopoverTriggerState;
var _snippetProps15, _props88;
var _PopoverContentState = class _PopoverContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __publicField(this, "onInteractOutside", (e) => {
      this.opts.onInteractOutside.current(e);
      if (e.defaultPrevented) return;
      if (!isElement2(e.target)) return;
      const closestTrigger = e.target.closest(popoverAttrs.selector("trigger"));
      if (closestTrigger && closestTrigger === this.root.triggerNode) return;
      if (this.opts.customAnchor.current) {
        if (isElement2(this.opts.customAnchor.current)) {
          if (this.opts.customAnchor.current.contains(e.target)) return;
        } else if (typeof this.opts.customAnchor.current === "string") {
          const el = document.querySelector(this.opts.customAnchor.current);
          if (el && el.contains(e.target)) return;
        }
      }
      this.root.handleClose();
    });
    __publicField(this, "onEscapeKeydown", (e) => {
      this.opts.onEscapeKeydown.current(e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __privateAdd(this, _snippetProps15, user_derived(() => ({ open: this.root.opts.open.current })));
    __privateAdd(this, _props88, user_derived(() => ({
      id: this.opts.id.current,
      tabindex: -1,
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      [popoverAttrs.content]: "",
      style: { pointerEvents: "auto" },
      ...this.attachment
    })));
    __publicField(this, "popperProps", {
      onInteractOutside: this.onInteractOutside,
      onEscapeKeydown: this.onEscapeKeydown
    });
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.contentNode = v);
  }
  static create(opts) {
    return new _PopoverContentState(opts, PopoverRootContext.get());
  }
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps15));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps15), value);
  }
  get props() {
    return get(__privateGet(this, _props88));
  }
  set props(value) {
    set(__privateGet(this, _props88), value);
  }
};
_snippetProps15 = new WeakMap();
_props88 = new WeakMap();
var PopoverContentState = _PopoverContentState;
var _props89;
var _PopoverCloseState = class _PopoverCloseState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props89, user_derived(() => ({
      id: this.opts.id.current,
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      type: "button",
      [popoverAttrs.close]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _PopoverCloseState(opts, PopoverRootContext.get());
  }
  onclick(_) {
    this.root.handleClose();
  }
  onkeydown(e) {
    if (!(e.key === kbd_constants_exports.ENTER || e.key === kbd_constants_exports.SPACE)) return;
    e.preventDefault();
    this.root.handleClose();
  }
  get props() {
    return get(__privateGet(this, _props89));
  }
  set props(value) {
    set(__privateGet(this, _props89), value);
  }
};
_props89 = new WeakMap();
var PopoverCloseState = _PopoverCloseState;
var _snippetProps16, _props90;
var _PopoverOverlayState = class _PopoverOverlayState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps16, user_derived(() => ({ open: this.root.opts.open.current })));
    __privateAdd(this, _props90, user_derived(() => ({
      id: this.opts.id.current,
      [popoverAttrs.overlay]: "",
      style: { pointerEvents: "auto" },
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.overlayNode = v);
  }
  static create(opts) {
    return new _PopoverOverlayState(opts, PopoverRootContext.get());
  }
  get shouldRender() {
    return this.root.overlayPresence.shouldRender;
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps16));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps16), value);
  }
  get props() {
    return get(__privateGet(this, _props90));
  }
  set props(value) {
    set(__privateGet(this, _props90), value);
  }
};
_snippetProps16 = new WeakMap();
_props90 = new WeakMap();
var PopoverOverlayState = _PopoverOverlayState;

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker.svelte
function Date_picker($$anchor, $$props) {
  push($$props, true);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), hideTimeZone = prop($$props, "hideTimeZone", 3, false), required = prop($$props, "required", 3, false), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), preventDeselect = prop($$props, "preventDeselect", 3, false), pagedNavigation = prop($$props, "pagedNavigation", 3, false), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), closeOnDateSelect = prop($$props, "closeOnDateSelect", 3, true), initialFocus = prop($$props, "initialFocus", 3, false), monthFormat = prop($$props, "monthFormat", 3, "long"), yearFormat = prop($$props, "yearFormat", 3, "numeric");
  const defaultPlaceholder = getDefaultDate({
    granularity: $$props.granularity,
    defaultValue: value()
  });
  function handleDefaultPlaceholder() {
    if (placeholder() !== void 0) return;
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function onDateSelect() {
    if (closeOnDateSelect()) {
      open(false);
    }
  }
  const pickerRootState = DatePickerRootState.create({
    open: boxWith(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: boxWith(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    isDateUnavailable: boxWith(() => isDateUnavailable()),
    minValue: boxWith(() => $$props.minValue),
    maxValue: boxWith(() => $$props.maxValue),
    disabled: boxWith(() => disabled()),
    readonly: boxWith(() => readonly()),
    granularity: boxWith(() => $$props.granularity),
    readonlySegments: boxWith(() => readonlySegments()),
    hourCycle: boxWith(() => $$props.hourCycle),
    locale: resolveLocaleProp(() => $$props.locale),
    hideTimeZone: boxWith(() => hideTimeZone()),
    required: boxWith(() => required()),
    calendarLabel: boxWith(() => calendarLabel()),
    disableDaysOutsideMonth: boxWith(() => disableDaysOutsideMonth()),
    preventDeselect: boxWith(() => preventDeselect()),
    pagedNavigation: boxWith(() => pagedNavigation()),
    weekStartsOn: boxWith(() => $$props.weekStartsOn),
    weekdayFormat: boxWith(() => weekdayFormat()),
    isDateDisabled: boxWith(() => isDateDisabled()),
    fixedWeeks: boxWith(() => fixedWeeks()),
    numberOfMonths: boxWith(() => numberOfMonths()),
    initialFocus: boxWith(() => initialFocus()),
    onDateSelect: boxWith(() => onDateSelect),
    defaultPlaceholder,
    monthFormat: boxWith(() => monthFormat()),
    yearFormat: boxWith(() => yearFormat())
  });
  PopoverRootState.create({
    open: pickerRootState.opts.open,
    onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
  });
  DateFieldRootState.create({
    value: pickerRootState.opts.value,
    disabled: pickerRootState.opts.disabled,
    readonly: pickerRootState.opts.readonly,
    readonlySegments: pickerRootState.opts.readonlySegments,
    validate: boxWith(() => validate()),
    onInvalid: boxWith(() => onInvalid()),
    minValue: pickerRootState.opts.minValue,
    maxValue: pickerRootState.opts.maxValue,
    granularity: pickerRootState.opts.granularity,
    hideTimeZone: pickerRootState.opts.hideTimeZone,
    hourCycle: pickerRootState.opts.hourCycle,
    locale: pickerRootState.opts.locale,
    required: pickerRootState.opts.required,
    placeholder: pickerRootState.opts.placeholder,
    errorMessageId: boxWith(() => $$props.errorMessageId),
    isInvalidProp: boxWith(() => void 0)
  });
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Root, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      children: ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop);
        append($$anchor3, fragment_1);
      },
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-calendar.svelte
var root_260 = from_html(`<div><!></div>`);
function Date_picker_calendar($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref"
  ]);
  const datePickerRootState = DatePickerRootContext.get();
  const calendarState = CalendarRootState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    calendarLabel: datePickerRootState.opts.calendarLabel,
    fixedWeeks: datePickerRootState.opts.fixedWeeks,
    isDateDisabled: datePickerRootState.opts.isDateDisabled,
    isDateUnavailable: datePickerRootState.opts.isDateUnavailable,
    locale: datePickerRootState.opts.locale,
    numberOfMonths: datePickerRootState.opts.numberOfMonths,
    pagedNavigation: datePickerRootState.opts.pagedNavigation,
    preventDeselect: datePickerRootState.opts.preventDeselect,
    readonly: datePickerRootState.opts.readonly,
    type: boxWith(() => "single"),
    weekStartsOn: datePickerRootState.opts.weekStartsOn,
    weekdayFormat: datePickerRootState.opts.weekdayFormat,
    disabled: datePickerRootState.opts.disabled,
    disableDaysOutsideMonth: datePickerRootState.opts.disableDaysOutsideMonth,
    maxValue: datePickerRootState.opts.maxValue,
    minValue: datePickerRootState.opts.minValue,
    placeholder: datePickerRootState.opts.placeholder,
    value: datePickerRootState.opts.value,
    onDateSelect: datePickerRootState.opts.onDateSelect,
    initialFocus: datePickerRootState.opts.initialFocus,
    defaultPlaceholder: datePickerRootState.opts.defaultPlaceholder,
    maxDays: boxWith(() => void 0),
    monthFormat: datePickerRootState.opts.monthFormat,
    yearFormat: datePickerRootState.opts.yearFormat
  });
  const mergedProps = user_derived(() => mergeProps(restProps, calendarState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...calendarState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_260();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => calendarState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/popover/components/popover-content.svelte
var root_411 = from_html(`<div><div><!></div></div>`);
var root_97 = from_html(`<div><div><!></div></div>`);
function Popover_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, false), customAnchor = prop($$props, "customAnchor", 3, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "ref",
    "id",
    "forceMount",
    "onCloseAutoFocus",
    "onEscapeKeydown",
    "onInteractOutside",
    "trapFocus",
    "preventScroll",
    "customAnchor"
  ]);
  const contentState = PopoverContentState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onInteractOutside: boxWith(() => onInteractOutside()),
    onEscapeKeydown: boxWith(() => onEscapeKeydown()),
    customAnchor: boxWith(() => customAnchor())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("popover")
          }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_411();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_3 = child(div_1);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          get trapFocus() {
            return trapFocus();
          },
          get preventScroll() {
            return preventScroll();
          },
          loop: true,
          forceMount: true,
          get customAnchor() {
            return customAnchor();
          },
          get onCloseAutoFocus() {
            return onCloseAutoFocus();
          },
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("popover")
              }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_97();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_6 = child(div_3);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              get trapFocus() {
                return trapFocus();
              },
              get preventScroll() {
                return preventScroll();
              },
              loop: true,
              forceMount: false,
              get customAnchor() {
                return customAnchor();
              },
              get onCloseAutoFocus() {
                return onCloseAutoFocus();
              },
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content.svelte
function Date_picker_content($$anchor, $$props) {
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "onOpenAutoFocus"
  ]);
  const mergedProps = user_derived(() => mergeProps({ onOpenAutoFocus: $$props.onOpenAutoFocus }, { onOpenAutoFocus: pickerOpenFocus }));
  Popover_content($$anchor, spread_props(() => get(mergedProps), () => restProps, {
    get ref() {
      return ref();
    },
    set ref($$value) {
      ref($$value);
    }
  }));
  pop();
}

// node_modules/bits-ui/dist/bits/popover/components/popover-content-static.svelte
var root_412 = from_html(`<div><!></div>`);
var root_98 = from_html(`<div><!></div>`);
function Popover_content_static($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "ref",
    "id",
    "forceMount",
    "onCloseAutoFocus",
    "onEscapeKeydown",
    "onInteractOutside",
    "trapFocus",
    "preventScroll"
  ]);
  const contentState = PopoverContentState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onInteractOutside: boxWith(() => onInteractOutside()),
    onEscapeKeydown: boxWith(() => onEscapeKeydown()),
    customAnchor: boxWith(() => null)
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("popover")
          }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_412();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_3 = child(div);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          isStatic: true,
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          get trapFocus() {
            return trapFocus();
          },
          get preventScroll() {
            return preventScroll();
          },
          loop: true,
          forceMount: true,
          get onCloseAutoFocus() {
            return onCloseAutoFocus();
          },
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("popover")
              }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_98();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_6 = child(div_1);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              isStatic: true,
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              get trapFocus() {
                return trapFocus();
              },
              get preventScroll() {
                return preventScroll();
              },
              loop: true,
              forceMount: false,
              get onCloseAutoFocus() {
                return onCloseAutoFocus();
              },
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content-static.svelte
function Date_picker_content_static($$anchor, $$props) {
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "onOpenAutoFocus"
  ]);
  const mergedProps = user_derived(() => mergeProps({ onOpenAutoFocus: $$props.onOpenAutoFocus }, { onOpenAutoFocus: pickerOpenFocus }));
  Popover_content_static($$anchor, spread_props(() => get(mergedProps), () => restProps, {
    get ref() {
      return ref();
    },
    set ref($$value) {
      ref($$value);
    }
  }));
  pop();
}

// node_modules/bits-ui/dist/bits/popover/components/popover-trigger.svelte
var root_311 = from_html(`<button><!></button>`);
function Popover_trigger($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "type",
    "disabled"
  ]);
  const triggerState = PopoverTriggerState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    disabled: boxWith(() => Boolean(disabled()))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
  Floating_layer_anchor($$anchor, {
    get id() {
      return id();
    },
    get ref() {
      return triggerState.opts.ref;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_1 = first_child(fragment_2);
          snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var button = root_311();
          attribute_effect(button, () => ({ ...get(mergedProps) }));
          var node_2 = child(button);
          snippet(node_2, () => $$props.children ?? noop);
          reset(button);
          append($$anchor3, button);
        };
        if_block(node, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-trigger.svelte
function Date_picker_trigger($$anchor, $$props) {
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "onkeydown"
  ]);
  function onKeydown(e) {
    if (isSegmentNavigationKey(e.key)) {
      const currNode = e.currentTarget;
      const dateFieldInputNode = currNode.closest(dateFieldAttrs.selector("input"));
      if (!dateFieldInputNode) return;
      handleSegmentNavigation(e, dateFieldInputNode);
    }
  }
  const mergedProps = user_derived(() => mergeProps({ onkeydown: $$props.onkeydown }, { onkeydown: onKeydown }));
  Popover_trigger($$anchor, spread_props(() => restProps, { "data-segment": "trigger" }, () => get(mergedProps), {
    get ref() {
      return ref();
    },
    set ref($$value) {
      ref($$value);
    }
  }));
  pop();
}

// node_modules/bits-ui/dist/bits/popover/components/popover-arrow.svelte
function Popover_arrow($$anchor, $$props) {
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref"]);
  Floating_layer_arrow($$anchor, spread_props(() => restProps, {
    "data-popover-arrow": "",
    get ref() {
      return ref();
    },
    set ref($$value) {
      ref($$value);
    }
  }));
  pop();
}

// node_modules/bits-ui/dist/bits/popover/components/popover-close.svelte
var root_261 = from_html(`<button><!></button>`);
function Popover_close($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "id",
    "ref"
  ]);
  const closeState = PopoverCloseState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, closeState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_261();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-range-field/exports.js
var exports_exports14 = {};
__export(exports_exports14, {
  Input: () => Date_range_field_input,
  Label: () => Date_range_field_label,
  Root: () => Date_range_field,
  Segment: () => Date_field_segment
});

// node_modules/bits-ui/dist/bits/date-range-field/date-range-field.svelte.js
var dateRangeFieldAttrs = createBitsAttrs({
  component: "date-range-field",
  parts: ["root", "label"]
});
var DateRangeFieldRootContext = new Context("DateRangeField.Root");
var _fieldNode2, _labelNode4, _descriptionNode3, _startValueComplete, _endValueComplete, _rangeComplete, _validationStatus2, _isInvalid3, _DateRangeFieldRootState_instances, updateValue_fn, _props91;
var _DateRangeFieldRootState = class _DateRangeFieldRootState {
  constructor(opts) {
    __privateAdd(this, _DateRangeFieldRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "startFieldState");
    __publicField(this, "endFieldState");
    __publicField(this, "descriptionId", useId());
    __publicField(this, "formatter");
    __privateAdd(this, _fieldNode2, state(null));
    __privateAdd(this, _labelNode4, state(null));
    __privateAdd(this, _descriptionNode3, state(null));
    __privateAdd(this, _startValueComplete, user_derived(() => this.opts.startValue.current !== void 0));
    __privateAdd(this, _endValueComplete, user_derived(() => this.opts.endValue.current !== void 0));
    __privateAdd(this, _rangeComplete, user_derived(() => this.startValueComplete && this.endValueComplete));
    __publicField(this, "domContext");
    __publicField(this, "attachment");
    __privateAdd(this, _validationStatus2, user_derived(() => {
      var _a, _b;
      const value = this.opts.value.current;
      if (value === void 0) return false;
      if (value.start === void 0 || value.end === void 0) return false;
      const msg = (_b = (_a = this.opts.validate).current) == null ? void 0 : _b.call(_a, { start: value.start, end: value.end });
      if (msg) {
        return { reason: "custom", message: msg };
      }
      const minValue = this.opts.minValue.current;
      if (minValue && value.start && isBefore(value.start, minValue)) {
        return { reason: "min" };
      }
      const maxValue = this.opts.maxValue.current;
      if (maxValue && value.end && isBefore(maxValue, value.end) || maxValue && value.start && isBefore(maxValue, value.start)) {
        return { reason: "max" };
      }
      return false;
    }));
    __privateAdd(this, _isInvalid3, user_derived(() => {
      if (this.validationStatus === false) return false;
      return true;
    }));
    __privateAdd(this, _props91, user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      [dateRangeFieldAttrs.root]: "",
      "data-invalid": boolToEmptyStrOrUndef(this.isInvalid),
      ...this.attachment
    })));
    this.opts = opts;
    this.formatter = createFormatter({
      initialLocale: this.opts.locale.current,
      monthFormat: boxWith(() => "long"),
      yearFormat: boxWith(() => "numeric")
    });
    this.domContext = new DOMContext(this.opts.ref);
    this.attachment = attachRef(this.opts.ref, (v) => this.fieldNode = v);
    onDestroyEffect(() => {
      removeDescriptionElement(this.descriptionId, this.domContext.getDocument());
    });
    user_effect(() => {
      if (this.formatter.getLocale() === this.opts.locale.current) return;
      this.formatter.setLocale(this.opts.locale.current);
    });
    watch(() => this.opts.value.current, (value) => {
      if (value.start && value.end) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = value.end;
      } else if (value.start) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = void 0;
      } else if (value.start === void 0 && value.end === void 0) {
        this.opts.startValue.current = void 0;
        this.opts.endValue.current = void 0;
      }
    });
    watch(() => this.opts.value.current, (value) => {
      const startValue = value.start;
      if (startValue && this.opts.placeholder.current !== startValue) {
        this.opts.placeholder.current = startValue;
      }
    });
    watch(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current
      ],
      ([startValue, endValue]) => {
        if (this.opts.value.current && this.opts.value.current.start === startValue && this.opts.value.current.end === endValue) {
          return;
        }
        if (startValue && endValue) {
          __privateMethod(this, _DateRangeFieldRootState_instances, updateValue_fn).call(this, (prev2) => {
            if (prev2.start === startValue && prev2.end === endValue) {
              return prev2;
            }
            return { start: startValue, end: endValue };
          });
        } else if (this.opts.value.current && this.opts.value.current.start && this.opts.value.current.end) {
          this.opts.value.current.start = void 0;
          this.opts.value.current.end = void 0;
        }
      }
    );
  }
  static create(opts) {
    return DateRangeFieldRootContext.set(new _DateRangeFieldRootState(opts));
  }
  get fieldNode() {
    return get(__privateGet(this, _fieldNode2));
  }
  set fieldNode(value) {
    set(__privateGet(this, _fieldNode2), value, true);
  }
  get labelNode() {
    return get(__privateGet(this, _labelNode4));
  }
  set labelNode(value) {
    set(__privateGet(this, _labelNode4), value, true);
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode3));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode3), value, true);
  }
  get startValueComplete() {
    return get(__privateGet(this, _startValueComplete));
  }
  set startValueComplete(value) {
    set(__privateGet(this, _startValueComplete), value);
  }
  get endValueComplete() {
    return get(__privateGet(this, _endValueComplete));
  }
  set endValueComplete(value) {
    set(__privateGet(this, _endValueComplete), value);
  }
  get rangeComplete() {
    return get(__privateGet(this, _rangeComplete));
  }
  set rangeComplete(value) {
    set(__privateGet(this, _rangeComplete), value);
  }
  get validationStatus() {
    return get(__privateGet(this, _validationStatus2));
  }
  set validationStatus(value) {
    set(__privateGet(this, _validationStatus2), value);
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid3));
  }
  set isInvalid(value) {
    set(__privateGet(this, _isInvalid3), value);
  }
  get props() {
    return get(__privateGet(this, _props91));
  }
  set props(value) {
    set(__privateGet(this, _props91), value);
  }
};
_fieldNode2 = new WeakMap();
_labelNode4 = new WeakMap();
_descriptionNode3 = new WeakMap();
_startValueComplete = new WeakMap();
_endValueComplete = new WeakMap();
_rangeComplete = new WeakMap();
_validationStatus2 = new WeakMap();
_isInvalid3 = new WeakMap();
_DateRangeFieldRootState_instances = new WeakSet();
updateValue_fn = function(cb) {
  const value = this.opts.value.current;
  const newValue = cb(value);
  this.opts.value.current = newValue;
};
_props91 = new WeakMap();
var DateRangeFieldRootState = _DateRangeFieldRootState;
var _onclick, _props92;
var _DateRangeFieldLabelState = class _DateRangeFieldLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _onclick, () => {
      if (this.root.opts.disabled.current) return;
      const firstSegment = getFirstSegment(this.root.fieldNode);
      if (!firstSegment) return;
      firstSegment.focus();
    });
    __privateAdd(this, _props92, user_derived(() => ({
      id: this.opts.id.current,
      "data-invalid": boolToEmptyStrOrUndef(this.root.isInvalid),
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      [dateRangeFieldAttrs.label]: "",
      onclick: __privateGet(this, _onclick),
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.labelNode = v);
  }
  static create(opts) {
    return new _DateRangeFieldLabelState(opts, DateRangeFieldRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props92));
  }
  set props(value) {
    set(__privateGet(this, _props92), value);
  }
};
_onclick = new WeakMap();
_props92 = new WeakMap();
var DateRangeFieldLabelState = _DateRangeFieldLabelState;
var DateRangeFieldInputState = class {
  static create(opts, type) {
    const root18 = DateRangeFieldRootContext.get();
    const fieldState = DateFieldRootState.create(
      {
        value: type === "start" ? root18.opts.startValue : root18.opts.endValue,
        disabled: root18.opts.disabled,
        readonly: root18.opts.readonly,
        readonlySegments: root18.opts.readonlySegments,
        validate: boxWith(() => void 0),
        minValue: root18.opts.minValue,
        maxValue: root18.opts.maxValue,
        hourCycle: root18.opts.hourCycle,
        locale: root18.opts.locale,
        hideTimeZone: root18.opts.hideTimeZone,
        required: root18.opts.required,
        granularity: root18.opts.granularity,
        placeholder: root18.opts.placeholder,
        onInvalid: root18.opts.onInvalid,
        errorMessageId: root18.opts.errorMessageId,
        isInvalidProp: boxWith(() => root18.isInvalid)
      },
      root18
    );
    return new DateFieldInputState({ name: opts.name, id: opts.id, ref: opts.ref }, fieldState);
  }
};

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field.svelte
var root_262 = from_html(`<div><!></div>`);
function Date_range_field($$anchor, $$props) {
  var _a, _b;
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), required = prop($$props, "required", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), readonlySegments = prop($$props, "readonlySegments", 19, () => []), onStartValueChange = prop($$props, "onStartValueChange", 3, noop3), onEndValueChange = prop($$props, "onEndValueChange", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "value",
    "onValueChange",
    "placeholder",
    "onPlaceholderChange",
    "disabled",
    "readonly",
    "required",
    "hourCycle",
    "granularity",
    "locale",
    "hideTimeZone",
    "validate",
    "onInvalid",
    "maxValue",
    "minValue",
    "readonlySegments",
    "children",
    "child",
    "onStartValueChange",
    "onEndValueChange",
    "errorMessageId"
  ]);
  let startValue = state(proxy((_a = value()) == null ? void 0 : _a.start));
  let endValue = state(proxy((_b = value()) == null ? void 0 : _b.end));
  function handleDefaultPlaceholder() {
    var _a2;
    if (placeholder() !== void 0) return;
    const defaultPlaceholder = getDefaultDate({
      granularity: $$props.granularity,
      defaultValue: (_a2 = value()) == null ? void 0 : _a2.start
    });
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function handleDefaultValue() {
    if (value() !== void 0) return;
    const defaultValue = { start: void 0, end: void 0 };
    value(defaultValue);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = DateRangeFieldRootState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    disabled: boxWith(() => disabled()),
    readonly: boxWith(() => readonly()),
    required: boxWith(() => required()),
    hourCycle: boxWith(() => $$props.hourCycle),
    granularity: boxWith(() => $$props.granularity),
    locale: resolveLocaleProp(() => $$props.locale),
    hideTimeZone: boxWith(() => hideTimeZone()),
    validate: boxWith(() => validate()),
    maxValue: boxWith(() => $$props.maxValue),
    minValue: boxWith(() => $$props.minValue),
    placeholder: boxWith(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    readonlySegments: boxWith(() => readonlySegments()),
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    startValue: boxWith(() => get(startValue), (v) => {
      set(startValue, v, true);
      onStartValueChange()(v);
    }),
    endValue: boxWith(() => get(endValue), (v) => {
      set(endValue, v, true);
      onEndValueChange()(v);
    }),
    onInvalid: boxWith(() => onInvalid()),
    errorMessageId: boxWith(() => $$props.errorMessageId)
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_262();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-input.svelte
var root_263 = from_html(`<div><!></div>`);
var root8 = from_html(`<!> <!>`, 1);
function Date_range_field_input($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "name",
    "child",
    "children",
    "type"
  ]);
  const inputState = DateRangeFieldInputState.create(
    {
      id: boxWith(() => id()),
      ref: boxWith(() => ref(), (v) => ref(v)),
      name: boxWith(() => name())
    },
    $$props.type
  );
  const mergedProps = user_derived(() => mergeProps(restProps, inputState.props, { role: "presentation" }));
  var fragment = root8();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        segments: inputState.root.segmentContents
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_263();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents }));
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  Date_field_hidden_input(node_3, {});
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-label.svelte
var root_264 = from_html(`<span><!></span>`);
function Date_range_field_label($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const labelState = DateRangeFieldLabelState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, labelState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_264();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-range-picker/exports.js
var exports_exports15 = {};
__export(exports_exports15, {
  Arrow: () => Popover_arrow,
  Calendar: () => Date_range_picker_calendar,
  Cell: () => Range_calendar_cell,
  Close: () => Popover_close,
  Content: () => Date_picker_content,
  Day: () => Range_calendar_day,
  Grid: () => Calendar_grid,
  GridBody: () => Calendar_grid_body,
  GridHead: () => Calendar_grid_head,
  GridRow: () => Calendar_grid_row,
  HeadCell: () => Calendar_head_cell,
  Header: () => Calendar_header,
  Heading: () => Calendar_heading,
  Input: () => Date_range_field_input,
  Label: () => Date_range_field_label,
  MonthSelect: () => Calendar_month_select,
  NextButton: () => Calendar_next_button,
  PrevButton: () => Calendar_prev_button,
  Root: () => Date_range_picker,
  Segment: () => Date_field_segment,
  Trigger: () => Date_range_picker_trigger,
  YearSelect: () => Calendar_year_select
});

// node_modules/bits-ui/dist/bits/date-range-picker/date-range-picker.svelte.js
var DateRangePickerRootContext = new Context("DateRangePicker.Root");
var DateRangePickerRootState = class _DateRangePickerRootState {
  constructor(opts) {
    __publicField(this, "opts");
    this.opts = opts;
  }
  static create(opts) {
    return DateRangePickerRootContext.set(new _DateRangePickerRootState(opts));
  }
};

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker.svelte
var root_312 = from_html(`<div><!></div>`);
function Date_range_picker($$anchor, $$props) {
  var _a, _b, _c;
  push($$props, true);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), value = prop($$props, "value", 15), id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), onInvalid = prop($$props, "onInvalid", 3, noop3), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), hideTimeZone = prop($$props, "hideTimeZone", 3, false), required = prop($$props, "required", 3, false), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), preventDeselect = prop($$props, "preventDeselect", 3, false), pagedNavigation = prop($$props, "pagedNavigation", 3, false), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), closeOnRangeSelect = prop($$props, "closeOnRangeSelect", 3, true), onStartValueChange = prop($$props, "onStartValueChange", 3, noop3), onEndValueChange = prop($$props, "onEndValueChange", 3, noop3), validate = prop($$props, "validate", 3, noop3), excludeDisabled = prop($$props, "excludeDisabled", 3, false), monthFormat = prop($$props, "monthFormat", 3, "long"), yearFormat = prop($$props, "yearFormat", 3, "numeric"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "open",
    "onOpenChange",
    "onOpenChangeComplete",
    "value",
    "id",
    "ref",
    "onValueChange",
    "placeholder",
    "onPlaceholderChange",
    "isDateUnavailable",
    "onInvalid",
    "minValue",
    "maxValue",
    "disabled",
    "readonly",
    "granularity",
    "readonlySegments",
    "hourCycle",
    "locale",
    "hideTimeZone",
    "required",
    "calendarLabel",
    "disableDaysOutsideMonth",
    "preventDeselect",
    "pagedNavigation",
    "weekStartsOn",
    "weekdayFormat",
    "isDateDisabled",
    "fixedWeeks",
    "numberOfMonths",
    "closeOnRangeSelect",
    "onStartValueChange",
    "onEndValueChange",
    "validate",
    "errorMessageId",
    "minDays",
    "maxDays",
    "excludeDisabled",
    "child",
    "children",
    "monthFormat",
    "yearFormat"
  ]);
  let startValue = state(proxy((_a = value()) == null ? void 0 : _a.start));
  let endValue = state(proxy((_b = value()) == null ? void 0 : _b.end));
  function handleDefaultValue() {
    if (value() !== void 0) return;
    value({ start: void 0, end: void 0 });
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const defaultPlaceholder = getDefaultDate({
    granularity: $$props.granularity,
    defaultValue: (_c = value()) == null ? void 0 : _c.start
  });
  function handleDefaultPlaceholder() {
    if (placeholder() !== void 0) return;
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function onRangeSelect() {
    if (closeOnRangeSelect()) {
      open(false);
    }
  }
  const pickerRootState = DateRangePickerRootState.create({
    open: boxWith(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: boxWith(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    isDateUnavailable: boxWith(() => isDateUnavailable()),
    minValue: boxWith(() => $$props.minValue),
    maxValue: boxWith(() => $$props.maxValue),
    minDays: boxWith(() => $$props.minDays),
    maxDays: boxWith(() => $$props.maxDays),
    disabled: boxWith(() => disabled()),
    readonly: boxWith(() => readonly()),
    granularity: boxWith(() => $$props.granularity),
    readonlySegments: boxWith(() => readonlySegments()),
    hourCycle: boxWith(() => $$props.hourCycle),
    locale: resolveLocaleProp(() => $$props.locale),
    hideTimeZone: boxWith(() => hideTimeZone()),
    required: boxWith(() => required()),
    calendarLabel: boxWith(() => calendarLabel()),
    disableDaysOutsideMonth: boxWith(() => disableDaysOutsideMonth()),
    preventDeselect: boxWith(() => preventDeselect()),
    pagedNavigation: boxWith(() => pagedNavigation()),
    weekStartsOn: boxWith(() => $$props.weekStartsOn),
    weekdayFormat: boxWith(() => weekdayFormat()),
    isDateDisabled: boxWith(() => isDateDisabled()),
    fixedWeeks: boxWith(() => fixedWeeks()),
    numberOfMonths: boxWith(() => numberOfMonths()),
    excludeDisabled: boxWith(() => excludeDisabled()),
    onRangeSelect: boxWith(() => onRangeSelect),
    startValue: boxWith(() => get(startValue), (v) => {
      set(startValue, v, true);
      onStartValueChange()(v);
    }),
    endValue: boxWith(() => get(endValue), (v) => {
      set(endValue, v, true);
      onEndValueChange()(v);
    }),
    monthFormat: boxWith(() => monthFormat()),
    yearFormat: boxWith(() => yearFormat()),
    defaultPlaceholder
  });
  PopoverRootState.create({
    open: pickerRootState.opts.open,
    onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
  });
  const fieldRootState = DateRangeFieldRootState.create({
    value: pickerRootState.opts.value,
    disabled: pickerRootState.opts.disabled,
    readonly: pickerRootState.opts.readonly,
    readonlySegments: pickerRootState.opts.readonlySegments,
    validate: boxWith(() => validate()),
    minValue: pickerRootState.opts.minValue,
    maxValue: pickerRootState.opts.maxValue,
    granularity: pickerRootState.opts.granularity,
    hideTimeZone: pickerRootState.opts.hideTimeZone,
    hourCycle: pickerRootState.opts.hourCycle,
    locale: pickerRootState.opts.locale,
    required: pickerRootState.opts.required,
    placeholder: pickerRootState.opts.placeholder,
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    startValue: pickerRootState.opts.startValue,
    endValue: pickerRootState.opts.endValue,
    onInvalid: boxWith(() => onInvalid()),
    errorMessageId: boxWith(() => $$props.errorMessageId)
  });
  const mergedProps = user_derived(() => mergeProps(restProps, fieldRootState.props));
  Floating_layer($$anchor, {
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_1 = first_child(fragment_2);
          snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_312();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_2 = child(div);
          snippet(node_2, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/bits-ui/dist/bits/range-calendar/range-calendar.svelte.js
var RangeCalendarCellContext = new Context("RangeCalendar.Cell");
var _visibleMonths2, _months2, _focusedValue, _weekdays2, _isStartInvalid, _isEndInvalid, _isInvalid4, _isNextButtonDisabled2, _isPrevButtonDisabled2, _headingValue2, _fullCalendarLabel2, _highlightedRange, _initialPlaceholderYear2, _defaultYears2, _RangeCalendarRootState_instances, updateValue_fn2, setStartValue_fn, setEndValue_fn, isRangeValid_fn, announceEmpty_fn, announceSelectedDate_fn, announceSelectedRange_fn, _snippetProps17, _props93, hasDisabledDatesInRange_fn;
var _RangeCalendarRootState = class _RangeCalendarRootState {
  constructor(opts) {
    __privateAdd(this, _RangeCalendarRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _visibleMonths2, user_derived(() => this.months.map((month) => month.value)));
    __privateAdd(this, _months2, state(proxy([])));
    __publicField(this, "announcer");
    __publicField(this, "formatter");
    __publicField(this, "accessibleHeadingId", useId());
    __privateAdd(this, _focusedValue, state(void 0));
    __publicField(this, "lastPressedDateValue");
    __publicField(this, "domContext");
    __privateAdd(this, _weekdays2, user_derived(() => {
      return getWeekdays({
        months: this.months,
        formatter: this.formatter,
        weekdayFormat: this.opts.weekdayFormat.current
      });
    }));
    __privateAdd(this, _isStartInvalid, user_derived(() => {
      if (!this.opts.startValue.current) return false;
      return this.isDateUnavailable(this.opts.startValue.current) || this.isDateDisabled(this.opts.startValue.current);
    }));
    __privateAdd(this, _isEndInvalid, user_derived(() => {
      if (!this.opts.endValue.current) return false;
      return this.isDateUnavailable(this.opts.endValue.current) || this.isDateDisabled(this.opts.endValue.current);
    }));
    __privateAdd(this, _isInvalid4, user_derived(() => {
      if (this.isStartInvalid || this.isEndInvalid) return true;
      if (this.opts.endValue.current && this.opts.startValue.current && isBefore(this.opts.endValue.current, this.opts.startValue.current)) return true;
      return false;
    }));
    __privateAdd(this, _isNextButtonDisabled2, user_derived(() => {
      return getIsNextButtonDisabled({
        maxValue: this.opts.maxValue.current,
        months: this.months,
        disabled: this.opts.disabled.current
      });
    }));
    __privateAdd(this, _isPrevButtonDisabled2, user_derived(() => {
      return getIsPrevButtonDisabled({
        minValue: this.opts.minValue.current,
        months: this.months,
        disabled: this.opts.disabled.current
      });
    }));
    __privateAdd(this, _headingValue2, user_derived(() => {
      this.opts.monthFormat.current;
      this.opts.yearFormat.current;
      return getCalendarHeadingValue({
        months: this.months,
        formatter: this.formatter,
        locale: this.opts.locale.current
      });
    }));
    __privateAdd(this, _fullCalendarLabel2, user_derived(() => `${this.opts.calendarLabel.current} ${this.headingValue}`));
    __privateAdd(this, _highlightedRange, user_derived(() => {
      if (this.opts.startValue.current && this.opts.endValue.current) return null;
      if (!this.opts.startValue.current || !this.focusedValue) return null;
      const isStartBeforeFocused = isBefore(this.opts.startValue.current, this.focusedValue);
      const start = isStartBeforeFocused ? this.opts.startValue.current : this.focusedValue;
      const end = isStartBeforeFocused ? this.focusedValue : this.opts.startValue.current;
      const range = { start, end };
      if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start.add({ days: 1 }), end) || $14e0f24ef4ac5c92$export$ea39ec197993aef0(start, end)) {
        return range;
      }
      const isValid = areAllDaysBetweenValid(start, end, this.isDateUnavailable, this.isDateDisabled);
      if (isValid) return range;
      return null;
    }));
    __privateAdd(this, _initialPlaceholderYear2, user_derived(() => untrack(() => this.opts.placeholder.current.year)));
    __privateAdd(this, _defaultYears2, user_derived(() => {
      return getDefaultYears({
        minValue: this.opts.minValue.current,
        maxValue: this.opts.maxValue.current,
        placeholderYear: this.initialPlaceholderYear
      });
    }));
    __publicField(this, "setMonths", (months) => {
      this.months = months;
    });
    __publicField(this, "getBitsAttr", (part) => {
      return calendarAttrs.getAttr(part, "range-calendar");
    });
    __privateAdd(this, _snippetProps17, user_derived(() => ({ months: this.months, weekdays: this.weekdays })));
    __privateAdd(this, _props93, user_derived(() => ({
      ...getCalendarElementProps({
        fullCalendarLabel: this.fullCalendarLabel,
        id: this.opts.id.current,
        isInvalid: this.isInvalid,
        disabled: this.opts.disabled.current,
        readonly: this.opts.readonly.current
      }),
      [this.getBitsAttr("root")]: "",
      //
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.domContext = new DOMContext(opts.ref);
    this.announcer = getAnnouncer(null);
    this.formatter = createFormatter({
      initialLocale: this.opts.locale.current,
      monthFormat: this.opts.monthFormat,
      yearFormat: this.opts.yearFormat
    });
    this.months = createMonths({
      dateObj: this.opts.placeholder.current,
      weekStartsOn: this.opts.weekStartsOn.current,
      locale: this.opts.locale.current,
      fixedWeeks: this.opts.fixedWeeks.current,
      numberOfMonths: this.opts.numberOfMonths.current
    });
    user_pre_effect(() => {
      if (this.formatter.getLocale() === this.opts.locale.current) return;
      this.formatter.setLocale(this.opts.locale.current);
    });
    onMount(() => {
      this.announcer = getAnnouncer(this.domContext.getDocument());
    });
    useMonthViewPlaceholderSync({
      placeholder: this.opts.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.opts.weekStartsOn,
      locale: this.opts.locale,
      fixedWeeks: this.opts.fixedWeeks,
      numberOfMonths: this.opts.numberOfMonths,
      setMonths: this.setMonths
    });
    useMonthViewOptionsSync({
      fixedWeeks: this.opts.fixedWeeks,
      locale: this.opts.locale,
      numberOfMonths: this.opts.numberOfMonths,
      placeholder: this.opts.placeholder,
      setMonths: this.setMonths,
      weekStartsOn: this.opts.weekStartsOn
    });
    user_effect(() => {
      const node = this.domContext.getElementById(this.accessibleHeadingId);
      if (!node) return;
      node.textContent = this.fullCalendarLabel;
    });
    watch(() => this.opts.value.current, (value) => {
      if (value.start && value.end) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = value.end;
      } else if (value.start) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = void 0;
      } else if (value.start === void 0 && value.end === void 0) {
        this.opts.startValue.current = void 0;
        this.opts.endValue.current = void 0;
      }
    });
    watch(() => this.opts.value.current, (value) => {
      const startValue = value.start;
      if (startValue && this.opts.placeholder.current !== startValue) {
        this.opts.placeholder.current = startValue;
      }
    });
    watch(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current,
        () => this.opts.excludeDisabled.current
      ],
      ([startValue, endValue, excludeDisabled]) => {
        if (!excludeDisabled || !startValue || !endValue) return;
        if (__privateMethod(this, _RangeCalendarRootState_instances, hasDisabledDatesInRange_fn).call(this, startValue, endValue)) {
          __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, void 0);
          __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
          __privateMethod(this, _RangeCalendarRootState_instances, announceEmpty_fn).call(this);
        }
      }
    );
    watch(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current
      ],
      ([startValue, endValue]) => {
        if (this.opts.value.current && this.opts.value.current.start === startValue && this.opts.value.current.end === endValue) {
          return;
        }
        if (startValue && endValue) {
          __privateMethod(this, _RangeCalendarRootState_instances, updateValue_fn2).call(this, (prev2) => {
            if (prev2.start === startValue && prev2.end === endValue) {
              return prev2;
            }
            if (isBefore(endValue, startValue)) {
              const start = startValue;
              const end = endValue;
              __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, end);
              __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, start);
              if (!__privateMethod(this, _RangeCalendarRootState_instances, isRangeValid_fn).call(this, endValue, startValue)) {
                __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, startValue);
                __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
                return { start: startValue, end: void 0 };
              }
              return { start: endValue, end: startValue };
            } else {
              if (!__privateMethod(this, _RangeCalendarRootState_instances, isRangeValid_fn).call(this, startValue, endValue)) {
                __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, endValue);
                __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
                return { start: endValue, end: void 0 };
              }
              return { start: startValue, end: endValue };
            }
          });
        } else if (this.opts.value.current && this.opts.value.current.start && this.opts.value.current.end) {
          this.opts.value.current.start = void 0;
          this.opts.value.current.end = void 0;
        }
      }
    );
    this.shiftFocus = this.shiftFocus.bind(this);
    this.handleCellClick = this.handleCellClick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.nextPage = this.nextPage.bind(this);
    this.prevPage = this.prevPage.bind(this);
    this.nextYear = this.nextYear.bind(this);
    this.prevYear = this.prevYear.bind(this);
    this.setYear = this.setYear.bind(this);
    this.setMonth = this.setMonth.bind(this);
    this.isDateDisabled = this.isDateDisabled.bind(this);
    this.isDateUnavailable = this.isDateUnavailable.bind(this);
    this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this);
    this.isSelected = this.isSelected.bind(this);
    useEnsureNonDisabledPlaceholder({
      placeholder: opts.placeholder,
      defaultPlaceholder: opts.defaultPlaceholder,
      isDateDisabled: opts.isDateDisabled,
      maxValue: opts.maxValue,
      minValue: opts.minValue,
      ref: opts.ref
    });
  }
  static create(opts) {
    return CalendarRootContext.set(new _RangeCalendarRootState(opts));
  }
  get visibleMonths() {
    return get(__privateGet(this, _visibleMonths2));
  }
  set visibleMonths(value) {
    set(__privateGet(this, _visibleMonths2), value);
  }
  get months() {
    return get(__privateGet(this, _months2));
  }
  set months(value) {
    set(__privateGet(this, _months2), value, true);
  }
  get focusedValue() {
    return get(__privateGet(this, _focusedValue));
  }
  set focusedValue(value) {
    set(__privateGet(this, _focusedValue), value, true);
  }
  get weekdays() {
    return get(__privateGet(this, _weekdays2));
  }
  set weekdays(value) {
    set(__privateGet(this, _weekdays2), value);
  }
  get isStartInvalid() {
    return get(__privateGet(this, _isStartInvalid));
  }
  set isStartInvalid(value) {
    set(__privateGet(this, _isStartInvalid), value);
  }
  get isEndInvalid() {
    return get(__privateGet(this, _isEndInvalid));
  }
  set isEndInvalid(value) {
    set(__privateGet(this, _isEndInvalid), value);
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid4));
  }
  set isInvalid(value) {
    set(__privateGet(this, _isInvalid4), value);
  }
  get isNextButtonDisabled() {
    return get(__privateGet(this, _isNextButtonDisabled2));
  }
  set isNextButtonDisabled(value) {
    set(__privateGet(this, _isNextButtonDisabled2), value);
  }
  get isPrevButtonDisabled() {
    return get(__privateGet(this, _isPrevButtonDisabled2));
  }
  set isPrevButtonDisabled(value) {
    set(__privateGet(this, _isPrevButtonDisabled2), value);
  }
  get headingValue() {
    return get(__privateGet(this, _headingValue2));
  }
  set headingValue(value) {
    set(__privateGet(this, _headingValue2), value);
  }
  get fullCalendarLabel() {
    return get(__privateGet(this, _fullCalendarLabel2));
  }
  set fullCalendarLabel(value) {
    set(__privateGet(this, _fullCalendarLabel2), value);
  }
  get highlightedRange() {
    return get(__privateGet(this, _highlightedRange));
  }
  set highlightedRange(value) {
    set(__privateGet(this, _highlightedRange), value);
  }
  get initialPlaceholderYear() {
    return get(__privateGet(this, _initialPlaceholderYear2));
  }
  set initialPlaceholderYear(value) {
    set(__privateGet(this, _initialPlaceholderYear2), value);
  }
  get defaultYears() {
    return get(__privateGet(this, _defaultYears2));
  }
  set defaultYears(value) {
    set(__privateGet(this, _defaultYears2), value);
  }
  isOutsideVisibleMonths(date) {
    return !this.visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, month));
  }
  isDateDisabled(date) {
    if (this.opts.isDateDisabled.current(date) || this.opts.disabled.current) return true;
    const minValue = this.opts.minValue.current;
    const maxValue = this.opts.maxValue.current;
    if (minValue && isBefore(date, minValue)) return true;
    if (maxValue && isAfter(date, maxValue)) return true;
    return false;
  }
  isDateUnavailable(date) {
    if (this.opts.isDateUnavailable.current(date)) return true;
    return false;
  }
  isSelectionStart(date) {
    if (!this.opts.startValue.current) return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, this.opts.startValue.current);
  }
  isSelectionEnd(date) {
    if (!this.opts.endValue.current) return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, this.opts.endValue.current);
  }
  isSelected(date) {
    if (this.opts.startValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.startValue.current, date)) return true;
    if (this.opts.endValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.endValue.current, date)) return true;
    if (this.opts.startValue.current && this.opts.endValue.current) {
      return isBetweenInclusive(date, this.opts.startValue.current, this.opts.endValue.current);
    }
    return false;
  }
  shiftFocus(node, add) {
    return shiftCalendarFocus({
      node,
      add,
      placeholder: this.opts.placeholder,
      calendarNode: this.opts.ref.current,
      isPrevButtonDisabled: this.isPrevButtonDisabled,
      isNextButtonDisabled: this.isNextButtonDisabled,
      months: this.months,
      numberOfMonths: this.opts.numberOfMonths.current
    });
  }
  handleCellClick(e, date) {
    if (this.isDateDisabled(date) || this.isDateUnavailable(date)) return;
    const prevLastPressedDate = this.lastPressedDateValue;
    this.lastPressedDateValue = date;
    if (this.opts.startValue.current && this.highlightedRange === null) {
      if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.startValue.current, date) && !this.opts.preventDeselect.current && !this.opts.endValue.current) {
        __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, void 0);
        this.opts.placeholder.current = date;
        __privateMethod(this, _RangeCalendarRootState_instances, announceEmpty_fn).call(this);
        return;
      } else if (!this.opts.endValue.current) {
        e.preventDefault();
        if (prevLastPressedDate && $14e0f24ef4ac5c92$export$ea39ec197993aef0(prevLastPressedDate, date)) {
          __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, date);
          __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedDate_fn).call(this, date);
        }
      }
    }
    if (this.opts.startValue.current && this.opts.endValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.endValue.current, date) && !this.opts.preventDeselect.current) {
      __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, void 0);
      __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
      this.opts.placeholder.current = date;
      __privateMethod(this, _RangeCalendarRootState_instances, announceEmpty_fn).call(this);
      return;
    }
    if (!this.opts.startValue.current) {
      __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedDate_fn).call(this, date);
      __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, date);
    } else if (!this.opts.endValue.current) {
      const startDate = this.opts.startValue.current;
      const endDate = date;
      const orderedStart = isBefore(endDate, startDate) ? endDate : startDate;
      const orderedEnd = isBefore(endDate, startDate) ? startDate : endDate;
      if (!__privateMethod(this, _RangeCalendarRootState_instances, isRangeValid_fn).call(this, orderedStart, orderedEnd)) {
        __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, date);
        __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
        __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedDate_fn).call(this, date);
      } else {
        if (isBefore(endDate, startDate)) {
          __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, endDate);
          __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, startDate);
          __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedRange_fn).call(this, endDate, startDate);
        } else {
          __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, date);
          __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedRange_fn).call(this, this.opts.startValue.current, date);
        }
      }
    } else if (this.opts.endValue.current && this.opts.startValue.current) {
      __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
      __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedDate_fn).call(this, date);
      __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, date);
    }
  }
  onkeydown(event) {
    return handleCalendarKeydown({
      event,
      handleCellClick: this.handleCellClick,
      placeholderValue: this.opts.placeholder.current,
      shiftFocus: this.shiftFocus
    });
  }
  /**
   * Navigates to the next page of the calendar.
   */
  nextPage() {
    handleCalendarNextPage({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (date) => this.opts.placeholder.current = date,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  /**
   * Navigates to the previous page of the calendar.
   */
  prevPage() {
    handleCalendarPrevPage({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (date) => this.opts.placeholder.current = date,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  nextYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.add({ years: 1 });
  }
  prevYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.subtract({ years: 1 });
  }
  setYear(year) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ year });
  }
  setMonth(month) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ month });
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps17));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps17), value);
  }
  get props() {
    return get(__privateGet(this, _props93));
  }
  set props(value) {
    set(__privateGet(this, _props93), value);
  }
};
_visibleMonths2 = new WeakMap();
_months2 = new WeakMap();
_focusedValue = new WeakMap();
_weekdays2 = new WeakMap();
_isStartInvalid = new WeakMap();
_isEndInvalid = new WeakMap();
_isInvalid4 = new WeakMap();
_isNextButtonDisabled2 = new WeakMap();
_isPrevButtonDisabled2 = new WeakMap();
_headingValue2 = new WeakMap();
_fullCalendarLabel2 = new WeakMap();
_highlightedRange = new WeakMap();
_initialPlaceholderYear2 = new WeakMap();
_defaultYears2 = new WeakMap();
_RangeCalendarRootState_instances = new WeakSet();
updateValue_fn2 = function(cb) {
  var _a, _b;
  const value = this.opts.value.current;
  const newValue = cb(value);
  this.opts.value.current = newValue;
  if (newValue.start && newValue.end) {
    (_b = (_a = this.opts.onRangeSelect) == null ? void 0 : _a.current) == null ? void 0 : _b.call(_a);
  }
};
setStartValue_fn = function(value) {
  this.opts.startValue.current = value;
  __privateMethod(this, _RangeCalendarRootState_instances, updateValue_fn2).call(this, (prev2) => ({ ...prev2, start: value }));
};
setEndValue_fn = function(value) {
  this.opts.endValue.current = value;
  __privateMethod(this, _RangeCalendarRootState_instances, updateValue_fn2).call(this, (prev2) => ({ ...prev2, end: value }));
};
isRangeValid_fn = function(start, end) {
  const orderedStart = isBefore(end, start) ? end : start;
  const orderedEnd = isBefore(end, start) ? start : end;
  const startDate = orderedStart.toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2());
  const endDate = orderedEnd.toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2());
  const timeDifference = endDate.getTime() - startDate.getTime();
  const daysDifference = Math.floor(timeDifference / (1e3 * 60 * 60 * 24));
  const daysInRange = daysDifference + 1;
  if (this.opts.minDays.current && daysInRange < this.opts.minDays.current) return false;
  if (this.opts.maxDays.current && daysInRange > this.opts.maxDays.current) return false;
  if (this.opts.excludeDisabled.current && __privateMethod(this, _RangeCalendarRootState_instances, hasDisabledDatesInRange_fn).call(this, orderedStart, orderedEnd)) {
    return false;
  }
  return true;
};
announceEmpty_fn = function() {
  this.announcer.announce("Selected date is now empty.", "polite");
};
announceSelectedDate_fn = function(date) {
  this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(date, false)}`, "polite");
};
announceSelectedRange_fn = function(start, end) {
  this.announcer.announce(`Selected Dates: ${this.formatter.selectedDate(start, false)} to ${this.formatter.selectedDate(end, false)}`, "polite");
};
_snippetProps17 = new WeakMap();
_props93 = new WeakMap();
hasDisabledDatesInRange_fn = function(start, end) {
  for (let date = start; isBefore(date, end) || $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, end); date = date.add({ days: 1 })) {
    if (this.isDateDisabled(date)) return true;
  }
  return false;
};
var RangeCalendarRootState = _RangeCalendarRootState;
var _cellDate2, _isOutsideMonth2, _isDisabled9, _isUnavailable2, _isDateToday2, _isOutsideVisibleMonths2, _isFocusedDate2, _isSelectedDate2, _isSelectionStart, _isRangeStart, _isRangeEnd, _isRangeMiddle, _isSelectionMiddle, _isSelectionEnd, _isHighlighted2, _labelText2, _snippetProps18, _ariaDisabled2, _sharedDataAttrs2, _props94;
var _RangeCalendarCellState = class _RangeCalendarCellState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _cellDate2, user_derived(() => toDate(this.opts.date.current)));
    __privateAdd(this, _isOutsideMonth2, user_derived(() => !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(this.opts.date.current, this.opts.month.current)));
    __privateAdd(this, _isDisabled9, user_derived(() => this.root.isDateDisabled(this.opts.date.current) || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current));
    __privateAdd(this, _isUnavailable2, user_derived(() => this.root.opts.isDateUnavailable.current(this.opts.date.current)));
    __privateAdd(this, _isDateToday2, user_derived(() => $14e0f24ef4ac5c92$export$629b0a497aa65267(this.opts.date.current, $14e0f24ef4ac5c92$export$aa8b41735afcabd2())));
    __privateAdd(this, _isOutsideVisibleMonths2, user_derived(() => this.root.isOutsideVisibleMonths(this.opts.date.current)));
    __privateAdd(this, _isFocusedDate2, user_derived(() => $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.date.current, this.root.opts.placeholder.current)));
    __privateAdd(this, _isSelectedDate2, user_derived(() => this.root.isSelected(this.opts.date.current)));
    __privateAdd(this, _isSelectionStart, user_derived(() => this.root.isSelectionStart(this.opts.date.current)));
    __privateAdd(this, _isRangeStart, user_derived(() => this.root.isSelectionStart(this.opts.date.current)));
    __privateAdd(this, _isRangeEnd, user_derived(() => {
      if (!this.root.opts.endValue.current) return this.root.isSelectionStart(this.opts.date.current);
      return this.root.isSelectionEnd(this.opts.date.current);
    }));
    __privateAdd(this, _isRangeMiddle, user_derived(() => this.isSelectionMiddle));
    __privateAdd(this, _isSelectionMiddle, user_derived(() => {
      return this.isSelectedDate && !this.isSelectionStart && !this.isSelectionEnd;
    }));
    __privateAdd(this, _isSelectionEnd, user_derived(() => this.root.isSelectionEnd(this.opts.date.current)));
    __privateAdd(this, _isHighlighted2, user_derived(() => this.root.highlightedRange ? isBetweenInclusive(this.opts.date.current, this.root.highlightedRange.start, this.root.highlightedRange.end) : false));
    __privateAdd(this, _labelText2, user_derived(() => this.root.formatter.custom(this.cellDate, {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })));
    __privateAdd(this, _snippetProps18, user_derived(() => ({
      disabled: this.isDisabled,
      unavailable: this.isUnavailable,
      selected: this.isSelectedDate
    })));
    __privateAdd(this, _ariaDisabled2, user_derived(() => {
      return this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current || this.isUnavailable;
    }));
    __privateAdd(this, _sharedDataAttrs2, user_derived(() => ({
      "data-unavailable": boolToEmptyStrOrUndef(this.isUnavailable),
      "data-today": this.isDateToday ? "" : void 0,
      "data-outside-month": this.isOutsideMonth ? "" : void 0,
      "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
      "data-focused": this.isFocusedDate ? "" : void 0,
      "data-selection-start": this.isSelectionStart ? "" : void 0,
      "data-selection-end": this.isSelectionEnd ? "" : void 0,
      "data-range-start": this.isRangeStart ? "" : void 0,
      "data-range-end": this.isRangeEnd ? "" : void 0,
      "data-range-middle": this.isRangeMiddle ? "" : void 0,
      "data-highlighted": this.isHighlighted ? "" : void 0,
      "data-selected": boolToEmptyStrOrUndef(this.isSelectedDate),
      "data-value": this.opts.date.current.toString(),
      "data-type": getDateValueType(this.opts.date.current),
      "data-disabled": boolToEmptyStrOrUndef(this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current)
    })));
    __privateAdd(this, _props94, user_derived(() => ({
      id: this.opts.id.current,
      role: "gridcell",
      "aria-selected": boolToStr(this.isSelectedDate),
      "aria-disabled": boolToStr(this.ariaDisabled),
      ...this.sharedDataAttrs,
      [this.root.getBitsAttr("cell")]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return RangeCalendarCellContext.set(new _RangeCalendarCellState(opts, CalendarRootContext.get()));
  }
  get cellDate() {
    return get(__privateGet(this, _cellDate2));
  }
  set cellDate(value) {
    set(__privateGet(this, _cellDate2), value);
  }
  get isOutsideMonth() {
    return get(__privateGet(this, _isOutsideMonth2));
  }
  set isOutsideMonth(value) {
    set(__privateGet(this, _isOutsideMonth2), value);
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled9));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled9), value);
  }
  get isUnavailable() {
    return get(__privateGet(this, _isUnavailable2));
  }
  set isUnavailable(value) {
    set(__privateGet(this, _isUnavailable2), value);
  }
  get isDateToday() {
    return get(__privateGet(this, _isDateToday2));
  }
  set isDateToday(value) {
    set(__privateGet(this, _isDateToday2), value);
  }
  get isOutsideVisibleMonths() {
    return get(__privateGet(this, _isOutsideVisibleMonths2));
  }
  set isOutsideVisibleMonths(value) {
    set(__privateGet(this, _isOutsideVisibleMonths2), value);
  }
  get isFocusedDate() {
    return get(__privateGet(this, _isFocusedDate2));
  }
  set isFocusedDate(value) {
    set(__privateGet(this, _isFocusedDate2), value);
  }
  get isSelectedDate() {
    return get(__privateGet(this, _isSelectedDate2));
  }
  set isSelectedDate(value) {
    set(__privateGet(this, _isSelectedDate2), value);
  }
  get isSelectionStart() {
    return get(__privateGet(this, _isSelectionStart));
  }
  set isSelectionStart(value) {
    set(__privateGet(this, _isSelectionStart), value);
  }
  get isRangeStart() {
    return get(__privateGet(this, _isRangeStart));
  }
  set isRangeStart(value) {
    set(__privateGet(this, _isRangeStart), value);
  }
  get isRangeEnd() {
    return get(__privateGet(this, _isRangeEnd));
  }
  set isRangeEnd(value) {
    set(__privateGet(this, _isRangeEnd), value);
  }
  get isRangeMiddle() {
    return get(__privateGet(this, _isRangeMiddle));
  }
  set isRangeMiddle(value) {
    set(__privateGet(this, _isRangeMiddle), value);
  }
  get isSelectionMiddle() {
    return get(__privateGet(this, _isSelectionMiddle));
  }
  set isSelectionMiddle(value) {
    set(__privateGet(this, _isSelectionMiddle), value);
  }
  get isSelectionEnd() {
    return get(__privateGet(this, _isSelectionEnd));
  }
  set isSelectionEnd(value) {
    set(__privateGet(this, _isSelectionEnd), value);
  }
  get isHighlighted() {
    return get(__privateGet(this, _isHighlighted2));
  }
  set isHighlighted(value) {
    set(__privateGet(this, _isHighlighted2), value);
  }
  get labelText() {
    return get(__privateGet(this, _labelText2));
  }
  set labelText(value) {
    set(__privateGet(this, _labelText2), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps18));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps18), value);
  }
  get ariaDisabled() {
    return get(__privateGet(this, _ariaDisabled2));
  }
  set ariaDisabled(value) {
    set(__privateGet(this, _ariaDisabled2), value);
  }
  get sharedDataAttrs() {
    return get(__privateGet(this, _sharedDataAttrs2));
  }
  set sharedDataAttrs(value) {
    set(__privateGet(this, _sharedDataAttrs2), value);
  }
  get props() {
    return get(__privateGet(this, _props94));
  }
  set props(value) {
    set(__privateGet(this, _props94), value);
  }
};
_cellDate2 = new WeakMap();
_isOutsideMonth2 = new WeakMap();
_isDisabled9 = new WeakMap();
_isUnavailable2 = new WeakMap();
_isDateToday2 = new WeakMap();
_isOutsideVisibleMonths2 = new WeakMap();
_isFocusedDate2 = new WeakMap();
_isSelectedDate2 = new WeakMap();
_isSelectionStart = new WeakMap();
_isRangeStart = new WeakMap();
_isRangeEnd = new WeakMap();
_isRangeMiddle = new WeakMap();
_isSelectionMiddle = new WeakMap();
_isSelectionEnd = new WeakMap();
_isHighlighted2 = new WeakMap();
_labelText2 = new WeakMap();
_snippetProps18 = new WeakMap();
_ariaDisabled2 = new WeakMap();
_sharedDataAttrs2 = new WeakMap();
_props94 = new WeakMap();
var RangeCalendarCellState = _RangeCalendarCellState;
var _tabindex2, _snippetProps19, _props95;
var _RangeCalendarDayState = class _RangeCalendarDayState {
  constructor(opts, cell) {
    __publicField(this, "opts");
    __publicField(this, "cell");
    __publicField(this, "attachment");
    __privateAdd(this, _tabindex2, user_derived(() => this.cell.isOutsideMonth && this.cell.root.opts.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : this.cell.isFocusedDate ? 0 : -1));
    __privateAdd(this, _snippetProps19, user_derived(() => ({
      disabled: this.cell.isDisabled,
      unavailable: this.cell.isUnavailable,
      selected: this.cell.isSelectedDate,
      day: `${this.cell.opts.date.current.day}`
    })));
    __privateAdd(this, _props95, user_derived(() => ({
      id: this.opts.id.current,
      role: "button",
      "aria-label": this.cell.labelText,
      "aria-disabled": boolToStr(this.cell.ariaDisabled),
      ...this.cell.sharedDataAttrs,
      tabindex: get(__privateGet(this, _tabindex2)),
      [this.cell.root.getBitsAttr("day")]: "",
      // Shared logic for range calendar and calendar
      "data-bits-day": "",
      //
      onclick: this.onclick,
      onmouseenter: this.onmouseenter,
      onfocusin: this.onfocusin,
      ...this.attachment
    })));
    this.opts = opts;
    this.cell = cell;
    this.attachment = attachRef(opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onmouseenter = this.onmouseenter.bind(this);
    this.onfocusin = this.onfocusin.bind(this);
  }
  static create(opts) {
    return new _RangeCalendarDayState(opts, RangeCalendarCellContext.get());
  }
  onclick(e) {
    if (this.cell.isDisabled) return;
    this.cell.root.handleCellClick(e, this.cell.opts.date.current);
  }
  onmouseenter(_) {
    if (this.cell.isDisabled) return;
    this.cell.root.focusedValue = this.cell.opts.date.current;
  }
  onfocusin(_) {
    if (this.cell.isDisabled) return;
    this.cell.root.focusedValue = this.cell.opts.date.current;
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps19));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps19), value);
  }
  get props() {
    return get(__privateGet(this, _props95));
  }
  set props(value) {
    set(__privateGet(this, _props95), value);
  }
};
_tabindex2 = new WeakMap();
_snippetProps19 = new WeakMap();
_props95 = new WeakMap();
var RangeCalendarDayState = _RangeCalendarDayState;

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-calendar.svelte
var root_265 = from_html(`<div><!></div>`);
function Date_range_picker_calendar($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref"
  ]);
  const dateRangePickerRootState = DateRangePickerRootContext.get();
  const rangeCalendarState = RangeCalendarRootState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    calendarLabel: dateRangePickerRootState.opts.calendarLabel,
    fixedWeeks: dateRangePickerRootState.opts.fixedWeeks,
    isDateDisabled: dateRangePickerRootState.opts.isDateDisabled,
    isDateUnavailable: dateRangePickerRootState.opts.isDateUnavailable,
    locale: dateRangePickerRootState.opts.locale,
    numberOfMonths: dateRangePickerRootState.opts.numberOfMonths,
    pagedNavigation: dateRangePickerRootState.opts.pagedNavigation,
    preventDeselect: dateRangePickerRootState.opts.preventDeselect,
    readonly: dateRangePickerRootState.opts.readonly,
    weekStartsOn: dateRangePickerRootState.opts.weekStartsOn,
    weekdayFormat: dateRangePickerRootState.opts.weekdayFormat,
    disabled: dateRangePickerRootState.opts.disabled,
    disableDaysOutsideMonth: dateRangePickerRootState.opts.disableDaysOutsideMonth,
    maxValue: dateRangePickerRootState.opts.maxValue,
    minValue: dateRangePickerRootState.opts.minValue,
    placeholder: dateRangePickerRootState.opts.placeholder,
    value: dateRangePickerRootState.opts.value,
    excludeDisabled: dateRangePickerRootState.opts.excludeDisabled,
    onRangeSelect: dateRangePickerRootState.opts.onRangeSelect,
    startValue: dateRangePickerRootState.opts.startValue,
    endValue: dateRangePickerRootState.opts.endValue,
    defaultPlaceholder: dateRangePickerRootState.opts.defaultPlaceholder,
    minDays: dateRangePickerRootState.opts.minDays,
    maxDays: dateRangePickerRootState.opts.maxDays,
    monthFormat: dateRangePickerRootState.opts.monthFormat,
    yearFormat: dateRangePickerRootState.opts.yearFormat
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rangeCalendarState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rangeCalendarState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_265();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rangeCalendarState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-trigger.svelte
function Date_range_picker_trigger($$anchor, $$props) {
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "onkeydown"
  ]);
  function onKeydown(e) {
    if (isSegmentNavigationKey(e.key)) {
      const currNode = e.currentTarget;
      const dateFieldInputNode = currNode.closest(dateRangeFieldAttrs.selector("root"));
      if (!dateFieldInputNode) return;
      handleSegmentNavigation(e, dateFieldInputNode);
    }
  }
  const mergedProps = user_derived(() => mergeProps({ onkeydown: $$props.onkeydown }, { onkeydown: onKeydown }));
  Popover_trigger($$anchor, spread_props(() => restProps, { "data-segment": "trigger" }, () => get(mergedProps), {
    get ref() {
      return ref();
    },
    set ref($$value) {
      ref($$value);
    }
  }));
  pop();
}

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-cell.svelte
var root_266 = from_html(`<td><!></td>`);
function Range_calendar_cell($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "date",
    "month"
  ]);
  const cellState = RangeCalendarCellState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    date: boxWith(() => $$props.date),
    month: boxWith(() => $$props.month)
  });
  const mergedProps = user_derived(() => mergeProps(restProps, cellState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...cellState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var td = root_266();
      attribute_effect(td, () => ({ ...get(mergedProps) }));
      var node_2 = child(td);
      snippet(node_2, () => $$props.children ?? noop, () => cellState.snippetProps);
      reset(td);
      append($$anchor2, td);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-day.svelte
var root_267 = from_html(`<div><!></div>`);
function Range_calendar_day($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref"
  ]);
  const dayState = RangeCalendarDayState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, dayState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...dayState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_267();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => dayState.snippetProps);
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, dayState.cell.opts.date.current.day));
          append($$anchor3, text2);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/dialog/exports.js
var exports_exports16 = {};
__export(exports_exports16, {
  Close: () => Dialog_close,
  Content: () => Dialog_content,
  Description: () => Dialog_description,
  Overlay: () => Dialog_overlay,
  Portal: () => Portal,
  Root: () => Dialog,
  Title: () => Dialog_title,
  Trigger: () => Dialog_trigger
});

// node_modules/bits-ui/dist/bits/dialog/components/dialog.svelte
function Dialog($$anchor, $$props) {
  push($$props, true);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  DialogRootState.create({
    variant: boxWith(() => "dialog"),
    open: boxWith(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/dialog/components/dialog-close.svelte
var root_268 = from_html(`<button><!></button>`);
function Dialog_close($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "disabled"
  ]);
  const closeState = DialogCloseState.create({
    variant: boxWith(() => "close"),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    disabled: boxWith(() => Boolean(disabled()))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, closeState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_268();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/dialog/components/dialog-content.svelte
var root_62 = from_html(`<!> <!>`, 1);
var root_82 = from_html(`<!> <div><!></div>`, 1);
function Dialog_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "children",
    "child",
    "ref",
    "forceMount",
    "onCloseAutoFocus",
    "onOpenAutoFocus",
    "onEscapeKeydown",
    "onInteractOutside",
    "trapFocus",
    "preventScroll",
    "restoreScrollDelay"
  ]);
  const contentState = DialogContentState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_2 = ($$anchor2) => {
      {
        const focusScope = ($$anchor3, $$arg0) => {
          let focusScopeProps = () => $$arg0 == null ? void 0 : $$arg0().props;
          Escape_layer($$anchor3, spread_props(() => get(mergedProps), {
            get enabled() {
              return contentState.root.opts.open.current;
            },
            get ref() {
              return contentState.opts.ref;
            },
            onEscapeKeydown: (e) => {
              onEscapeKeydown()(e);
              if (e.defaultPrevented) return;
              contentState.root.handleClose();
            },
            children: ($$anchor4, $$slotProps) => {
              Dismissible_layer($$anchor4, spread_props(() => get(mergedProps), {
                get ref() {
                  return contentState.opts.ref;
                },
                get enabled() {
                  return contentState.root.opts.open.current;
                },
                onInteractOutside: (e) => {
                  onInteractOutside()(e);
                  if (e.defaultPrevented) return;
                  contentState.root.handleClose();
                },
                children: ($$anchor5, $$slotProps2) => {
                  Text_selection_layer($$anchor5, spread_props(() => get(mergedProps), {
                    get ref() {
                      return contentState.opts.ref;
                    },
                    get enabled() {
                      return contentState.root.opts.open.current;
                    },
                    children: ($$anchor6, $$slotProps3) => {
                      var fragment_5 = comment();
                      var node_1 = first_child(fragment_5);
                      {
                        var consequent_1 = ($$anchor7) => {
                          var fragment_6 = root_62();
                          var node_2 = first_child(fragment_6);
                          {
                            var consequent = ($$anchor8) => {
                              Scroll_lock($$anchor8, {
                                get preventScroll() {
                                  return preventScroll();
                                },
                                get restoreScrollDelay() {
                                  return restoreScrollDelay();
                                }
                              });
                            };
                            if_block(node_2, ($$render) => {
                              if (contentState.root.opts.open.current) $$render(consequent);
                            });
                          }
                          var node_3 = sibling(node_2, 2);
                          var render_arg = derived_safe_equal(() => ({
                            props: mergeProps(get(mergedProps), focusScopeProps()),
                            ...contentState.snippetProps
                          }));
                          snippet(node_3, () => $$props.child, () => get(render_arg));
                          append($$anchor7, fragment_6);
                        };
                        var alternate = ($$anchor7) => {
                          var fragment_8 = root_82();
                          var node_4 = first_child(fragment_8);
                          Scroll_lock(node_4, {
                            get preventScroll() {
                              return preventScroll();
                            }
                          });
                          var div = sibling(node_4, 2);
                          attribute_effect(div, ($0) => ({ ...$0 }), [
                            () => mergeProps(get(mergedProps), focusScopeProps())
                          ]);
                          var node_5 = child(div);
                          snippet(node_5, () => $$props.children ?? noop);
                          reset(div);
                          append($$anchor7, fragment_8);
                        };
                        if_block(node_1, ($$render) => {
                          if ($$props.child) $$render(consequent_1);
                          else $$render(alternate, false);
                        });
                      }
                      append($$anchor6, fragment_5);
                    },
                    $$slots: { default: true }
                  }));
                },
                $$slots: { default: true }
              }));
            },
            $$slots: { default: true }
          }));
        };
        Focus_scope($$anchor2, {
          get ref() {
            return contentState.opts.ref;
          },
          loop: true,
          get trapFocus() {
            return trapFocus();
          },
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get onOpenAutoFocus() {
            return onOpenAutoFocus();
          },
          get onCloseAutoFocus() {
            return onCloseAutoFocus();
          },
          focusScope,
          $$slots: { focusScope: true }
        });
      }
    };
    if_block(node, ($$render) => {
      if (contentState.shouldRender || forceMount()) $$render(consequent_2);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/dropdown-menu/exports.js
var exports_exports17 = {};
__export(exports_exports17, {
  Arrow: () => Menu_arrow,
  CheckboxGroup: () => Menu_checkbox_group,
  CheckboxItem: () => Menu_checkbox_item,
  Content: () => Dropdown_menu_content,
  ContentStatic: () => Dropdown_menu_content_static,
  Group: () => Menu_group,
  GroupHeading: () => Menu_group_heading,
  Item: () => Menu_item,
  Portal: () => Portal,
  RadioGroup: () => Menu_radio_group,
  RadioItem: () => Menu_radio_item,
  Root: () => Menu,
  Separator: () => Menu_separator,
  Sub: () => Menu_sub,
  SubContent: () => Menu_sub_content,
  SubContentStatic: () => Menu_sub_content_static,
  SubTrigger: () => Menu_sub_trigger,
  Trigger: () => Menu_trigger
});

// node_modules/bits-ui/dist/bits/menu/components/menu.svelte
function Menu($$anchor, $$props) {
  push($$props, true);
  let open = prop($$props, "open", 15, false), dir = prop($$props, "dir", 3, "ltr"), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), variant = prop($$props, "_internal_variant", 3, "dropdown-menu");
  const root18 = MenuRootState.create({
    variant: boxWith(() => variant()),
    dir: boxWith(() => dir()),
    onClose: () => {
      open(false);
      onOpenChange()(false);
    }
  });
  MenuMenuState.create(
    {
      open: boxWith(() => open(), (v) => {
        open(v);
        onOpenChange()(v);
      }),
      onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
    },
    root18
  );
  Floating_layer($$anchor, {
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      snippet(node, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content.svelte
var root_413 = from_html(`<div><div><!></div></div>`);
var root_99 = from_html(`<div><div><!></div></div>`);
function Dropdown_menu_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), trapFocus = prop($$props, "trapFocus", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "child",
    "children",
    "ref",
    "loop",
    "onInteractOutside",
    "onEscapeKeydown",
    "onCloseAutoFocus",
    "forceMount",
    "trapFocus"
  ]);
  const contentState = MenuContentState.create({
    id: boxWith(() => id()),
    loop: boxWith(() => loop()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: boxWith(() => onCloseAutoFocus())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  function handleInteractOutside(e) {
    contentState.handleInteractOutside(e);
    if (e.defaultPrevented) return;
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    if (e.target && e.target instanceof Element) {
      const subContentSelector = `[${contentState.parentMenu.root.getBitsAttr("sub-content")}]`;
      if (e.target.closest(subContentSelector)) return;
    }
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("dropdown-menu")
          }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_413();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_3 = child(div_1);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.parentMenu.opts.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          get trapFocus() {
            return trapFocus();
          },
          get loop() {
            return loop();
          },
          forceMount: true,
          get id() {
            return id();
          },
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("dropdown-menu")
              }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_99();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_6 = child(div_3);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.parentMenu.opts.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              get trapFocus() {
                return trapFocus();
              },
              get loop() {
                return loop();
              },
              forceMount: false,
              get id() {
                return id();
              },
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content-static.svelte
var root_414 = from_html(`<div><!></div>`);
var root_910 = from_html(`<div><!></div>`);
function Dropdown_menu_content_static($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "child",
    "children",
    "ref",
    "loop",
    "onInteractOutside",
    "onEscapeKeydown",
    "onCloseAutoFocus",
    "forceMount"
  ]);
  const contentState = MenuContentState.create({
    id: boxWith(() => id()),
    loop: boxWith(() => loop()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: boxWith(() => onCloseAutoFocus())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  function handleInteractOutside(e) {
    contentState.handleInteractOutside(e);
    if (e.defaultPrevented) return;
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("dropdown-menu")
          }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_414();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_3 = child(div);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.parentMenu.opts.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          trapFocus: true,
          get loop() {
            return loop();
          },
          forceMount: true,
          isStatic: true,
          get id() {
            return id();
          },
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("dropdown-menu")
              }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_910();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_6 = child(div_1);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.parentMenu.opts.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              isStatic: true,
              get id() {
                return id();
              },
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-trigger.svelte
var root_313 = from_html(`<button><!></button>`);
function Menu_trigger($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "child",
    "children",
    "disabled",
    "type"
  ]);
  const triggerState = DropdownMenuTriggerState.create({
    id: boxWith(() => id()),
    disabled: boxWith(() => disabled() ?? false),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
  Floating_layer_anchor($$anchor, {
    get id() {
      return id();
    },
    get ref() {
      return triggerState.opts.ref;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_1 = first_child(fragment_2);
          snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var button = root_313();
          attribute_effect(button, () => ({ ...get(mergedProps) }));
          var node_2 = child(button);
          snippet(node_2, () => $$props.children ?? noop);
          reset(button);
          append($$anchor3, button);
        };
        if_block(node, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/bits-ui/dist/bits/label/exports.js
var exports_exports18 = {};
__export(exports_exports18, {
  Root: () => Label
});

// node_modules/bits-ui/dist/bits/label/label.svelte.js
var labelAttrs = createBitsAttrs({ component: "label", parts: ["root"] });
var _props96;
var _LabelRootState = class _LabelRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props96, user_derived(() => ({
      id: this.opts.id.current,
      [labelAttrs.root]: "",
      onmousedown: this.onmousedown,
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.onmousedown = this.onmousedown.bind(this);
  }
  static create(opts) {
    return new _LabelRootState(opts);
  }
  onmousedown(e) {
    if (e.detail > 1) e.preventDefault();
  }
  get props() {
    return get(__privateGet(this, _props96));
  }
  set props(value) {
    set(__privateGet(this, _props96), value);
  }
};
_props96 = new WeakMap();
var LabelRootState = _LabelRootState;

// node_modules/bits-ui/dist/bits/label/components/label.svelte
var root_269 = from_html(`<label><!></label>`);
function Label($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "for"
  ]);
  const rootState = LabelRootState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props, { for: $$props.for }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_269();
      attribute_effect(label, () => ({ ...get(mergedProps), for: $$props.for }));
      var node_2 = child(label);
      snippet(node_2, () => $$props.children ?? noop);
      reset(label);
      append($$anchor2, label);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/link-preview/exports.js
var exports_exports19 = {};
__export(exports_exports19, {
  Arrow: () => Floating_layer_arrow,
  Content: () => Link_preview_content,
  ContentStatic: () => Link_preview_content_static,
  Portal: () => Portal,
  Root: () => Link_preview,
  Trigger: () => Link_preview_trigger
});

// node_modules/bits-ui/dist/bits/link-preview/link-preview.svelte.js
var linkPreviewAttrs = createBitsAttrs({
  component: "link-preview",
  parts: ["content", "trigger"]
});
var LinkPreviewRootContext = new Context("LinkPreview.Root");
var _hasSelection, _isPointerDownOnContent, _containsSelection, _contentNode7, _contentMounted, _triggerNode5;
var _LinkPreviewRootState = class _LinkPreviewRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _hasSelection, state(false));
    __privateAdd(this, _isPointerDownOnContent, state(false));
    __privateAdd(this, _containsSelection, state(false));
    __publicField(this, "timeout", null);
    __privateAdd(this, _contentNode7, state(null));
    __privateAdd(this, _contentMounted, state(false));
    __publicField(this, "contentPresence");
    __privateAdd(this, _triggerNode5, state(null));
    __publicField(this, "isOpening", false);
    __publicField(this, "domContext", new DOMContext(() => null));
    this.opts = opts;
    this.contentPresence = new PresenceManager({
      ref: boxWith(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    watch(() => this.opts.open.current, (isOpen) => {
      if (!isOpen) {
        this.hasSelection = false;
        return;
      }
      if (!this.domContext) return;
      const handlePointerUp = () => {
        this.containsSelection = false;
        this.isPointerDownOnContent = false;
        afterSleep(1, () => {
          var _a;
          const isSelection = ((_a = this.domContext.getDocument().getSelection()) == null ? void 0 : _a.toString()) !== "";
          if (isSelection) {
            this.hasSelection = true;
          } else {
            this.hasSelection = false;
          }
        });
      };
      const unsubListener = on(this.domContext.getDocument(), "pointerup", handlePointerUp);
      if (!this.contentNode) return;
      const tabCandidates = getTabbableCandidates(this.contentNode);
      for (const candidate of tabCandidates) {
        candidate.setAttribute("tabindex", "-1");
      }
      return () => {
        unsubListener();
        this.hasSelection = false;
        this.isPointerDownOnContent = false;
      };
    });
  }
  static create(opts) {
    return LinkPreviewRootContext.set(new _LinkPreviewRootState(opts));
  }
  get hasSelection() {
    return get(__privateGet(this, _hasSelection));
  }
  set hasSelection(value) {
    set(__privateGet(this, _hasSelection), value, true);
  }
  get isPointerDownOnContent() {
    return get(__privateGet(this, _isPointerDownOnContent));
  }
  set isPointerDownOnContent(value) {
    set(__privateGet(this, _isPointerDownOnContent), value, true);
  }
  get containsSelection() {
    return get(__privateGet(this, _containsSelection));
  }
  set containsSelection(value) {
    set(__privateGet(this, _containsSelection), value, true);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode7));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode7), value, true);
  }
  get contentMounted() {
    return get(__privateGet(this, _contentMounted));
  }
  set contentMounted(value) {
    set(__privateGet(this, _contentMounted), value, true);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode5));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode5), value, true);
  }
  clearTimeout() {
    if (this.timeout) {
      this.domContext.clearTimeout(this.timeout);
      this.timeout = null;
    }
  }
  handleOpen() {
    this.clearTimeout();
    if (this.opts.open.current || this.opts.disabled.current) return;
    this.isOpening = true;
    this.timeout = this.domContext.setTimeout(
      () => {
        if (this.isOpening) {
          this.opts.open.current = true;
          this.isOpening = false;
        }
      },
      this.opts.openDelay.current
    );
  }
  immediateClose() {
    this.clearTimeout();
    this.isOpening = false;
    this.opts.open.current = false;
  }
  handleClose() {
    this.isOpening = false;
    this.clearTimeout();
    if (!this.isPointerDownOnContent && !this.hasSelection) {
      this.timeout = this.domContext.setTimeout(
        () => {
          this.opts.open.current = false;
        },
        this.opts.closeDelay.current
      );
    }
  }
};
_hasSelection = new WeakMap();
_isPointerDownOnContent = new WeakMap();
_containsSelection = new WeakMap();
_contentNode7 = new WeakMap();
_contentMounted = new WeakMap();
_triggerNode5 = new WeakMap();
var LinkPreviewRootState = _LinkPreviewRootState;
var _props97;
var _LinkPreviewTriggerState = class _LinkPreviewTriggerState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props97, user_derived(() => {
      var _a;
      return {
        id: this.opts.id.current,
        "aria-haspopup": "dialog",
        "aria-expanded": boolToStr(this.root.opts.open.current),
        "data-state": getDataOpenClosed(this.root.opts.open.current),
        "aria-controls": (_a = this.root.contentNode) == null ? void 0 : _a.id,
        role: "button",
        [linkPreviewAttrs.trigger]: "",
        onpointerenter: this.onpointerenter,
        onfocus: this.onfocus,
        onblur: this.onblur,
        onpointerleave: this.onpointerleave,
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.triggerNode = v);
    this.root.domContext = new DOMContext(opts.ref);
    this.onpointerenter = this.onpointerenter.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
    this.onfocus = this.onfocus.bind(this);
    this.onblur = this.onblur.bind(this);
  }
  static create(opts) {
    return new _LinkPreviewTriggerState(opts, LinkPreviewRootContext.get());
  }
  onpointerenter(e) {
    if (isTouch(e)) return;
    this.root.handleOpen();
  }
  onpointerleave(e) {
    if (isTouch(e)) return;
    if (!this.root.contentMounted || !this.root.opts.open.current) {
      this.root.immediateClose();
    }
  }
  onfocus(e) {
    if (!isFocusVisible(e.currentTarget)) return;
    this.root.handleOpen();
  }
  onblur(_) {
    this.root.handleClose();
  }
  get props() {
    return get(__privateGet(this, _props97));
  }
  set props(value) {
    set(__privateGet(this, _props97), value);
  }
};
_props97 = new WeakMap();
var LinkPreviewTriggerState = _LinkPreviewTriggerState;
var _snippetProps20, _props98;
var _LinkPreviewContentState = class _LinkPreviewContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __publicField(this, "onInteractOutside", (e) => {
      this.opts.onInteractOutside.current(e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onEscapeKeydown", (e) => {
      var _a, _b;
      (_b = (_a = this.opts.onEscapeKeydown).current) == null ? void 0 : _b.call(_a, e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onOpenAutoFocus", (e) => {
      e.preventDefault();
    });
    __publicField(this, "onCloseAutoFocus", (e) => {
      e.preventDefault();
    });
    __privateAdd(this, _snippetProps20, user_derived(() => ({ open: this.root.opts.open.current })));
    __privateAdd(this, _props98, user_derived(() => ({
      id: this.opts.id.current,
      tabindex: -1,
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      [linkPreviewAttrs.content]: "",
      onpointerdown: this.onpointerdown,
      onpointerenter: this.onpointerenter,
      onfocusout: this.onfocusout,
      ...this.attachment
    })));
    __publicField(this, "popperProps", {
      onInteractOutside: this.onInteractOutside,
      onEscapeKeydown: this.onEscapeKeydown,
      onOpenAutoFocus: this.onOpenAutoFocus,
      onCloseAutoFocus: this.onCloseAutoFocus
    });
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.contentNode = v);
    this.root.domContext = new DOMContext(opts.ref);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointerenter = this.onpointerenter.bind(this);
    this.onfocusout = this.onfocusout.bind(this);
    new GraceArea({
      triggerNode: () => this.root.triggerNode,
      contentNode: () => this.opts.ref.current,
      enabled: () => this.root.opts.open.current,
      onPointerExit: () => {
        this.root.handleClose();
      }
    });
    onDestroyEffect(() => {
      this.root.clearTimeout();
    });
  }
  static create(opts) {
    return new _LinkPreviewContentState(opts, LinkPreviewRootContext.get());
  }
  onpointerdown(e) {
    const target = e.target;
    if (!isElement2(target)) return;
    if (e.currentTarget.contains(target)) {
      this.root.containsSelection = true;
    }
    this.root.hasSelection = true;
    this.root.isPointerDownOnContent = true;
  }
  onpointerenter(e) {
    if (isTouch(e)) return;
    this.root.handleOpen();
  }
  onfocusout(e) {
    e.preventDefault();
  }
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps20));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps20), value);
  }
  get props() {
    return get(__privateGet(this, _props98));
  }
  set props(value) {
    set(__privateGet(this, _props98), value);
  }
};
_snippetProps20 = new WeakMap();
_props98 = new WeakMap();
var LinkPreviewContentState = _LinkPreviewContentState;

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview.svelte
function Link_preview($$anchor, $$props) {
  push($$props, true);
  let disabled = prop($$props, "disabled", 3, false), open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), openDelay = prop($$props, "openDelay", 3, 700), closeDelay = prop($$props, "closeDelay", 3, 300);
  LinkPreviewRootState.create({
    disabled: boxWith(() => disabled()),
    open: boxWith(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    openDelay: boxWith(() => openDelay()),
    closeDelay: boxWith(() => closeDelay()),
    onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Root, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      children: ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop);
        append($$anchor3, fragment_1);
      },
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content.svelte
var root_415 = from_html(`<div><div><!></div></div>`);
var root_270 = from_html(`<!> <!>`, 1);
var root_911 = from_html(`<div><div><!></div></div>`);
var root_7 = from_html(`<!> <!>`, 1);
function Link_preview_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), side = prop($$props, "side", 3, "top"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), avoidCollisions = prop($$props, "avoidCollisions", 3, true), arrowPadding = prop($$props, "arrowPadding", 3, 0), sticky = prop($$props, "sticky", 3, "partial"), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), collisionPadding = prop($$props, "collisionPadding", 3, 0), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "side",
    "sideOffset",
    "align",
    "avoidCollisions",
    "arrowPadding",
    "sticky",
    "hideWhenDetached",
    "collisionPadding",
    "onInteractOutside",
    "onEscapeKeydown",
    "forceMount"
  ]);
  const contentState = LinkPreviewContentState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onInteractOutside: boxWith(() => onInteractOutside()),
    onEscapeKeydown: boxWith(() => onEscapeKeydown())
  });
  const floatingProps = user_derived(() => ({
    side: side(),
    sideOffset: sideOffset(),
    align: align(),
    avoidCollisions: avoidCollisions(),
    arrowPadding: arrowPadding(),
    sticky: sticky(),
    hideWhenDetached: hideWhenDetached(),
    collisionPadding: collisionPadding()
  }));
  const mergedProps = user_derived(() => mergeProps(restProps, get(floatingProps), contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          var fragment_2 = root_270();
          const mergedProps2 = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("link-preview")
          }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(mergedProps2),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_415();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(mergedProps2) }));
              var node_3 = child(div_1);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          var node_4 = sibling(node_1, 2);
          Mounted(node_4, {
            get mounted() {
              return contentState.root.contentMounted;
            },
            set mounted($$value) {
              contentState.root.contentMounted = $$value;
            }
          });
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          trapFocus: false,
          loop: false,
          preventScroll: false,
          forceMount: true,
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              var fragment_5 = root_7();
              const mergedProps2 = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("link-preview")
              }));
              var node_5 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_6 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(mergedProps2),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_6, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_911();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(mergedProps2) }));
                  var node_7 = child(div_3);
                  snippet(node_7, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_5, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              var node_8 = sibling(node_5, 2);
              Mounted(node_8, {
                get mounted() {
                  return contentState.root.contentMounted;
                },
                set mounted($$value) {
                  contentState.root.contentMounted = $$value;
                }
              });
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              trapFocus: false,
              loop: false,
              preventScroll: false,
              forceMount: false,
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-trigger.svelte
var root_314 = from_html(`<a><!></a>`);
function Link_preview_trigger($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "child",
    "children"
  ]);
  const triggerState = LinkPreviewTriggerState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Anchor, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      get id() {
        return id();
      },
      get ref() {
        return triggerState.opts.ref;
      },
      children: ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          };
          var alternate = ($$anchor4) => {
            var a2 = root_314();
            attribute_effect(a2, () => ({ ...get(mergedProps) }));
            var node_3 = child(a2);
            snippet(node_3, () => $$props.children ?? noop);
            reset(a2);
            append($$anchor4, a2);
          };
          if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_1);
      },
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content-static.svelte
var root_416 = from_html(`<div><!></div>`);
var root_271 = from_html(`<!> <!>`, 1);
var root_912 = from_html(`<div><!></div>`);
function Link_preview_content_static($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "onInteractOutside",
    "onEscapeKeydown",
    "forceMount"
  ]);
  const contentState = LinkPreviewContentState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onInteractOutside: boxWith(() => onInteractOutside()),
    onEscapeKeydown: boxWith(() => onEscapeKeydown())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          var fragment_2 = root_271();
          const mergedProps2 = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("link-preview")
          }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(mergedProps2),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_416();
              attribute_effect(div, () => ({ ...get(mergedProps2) }));
              var node_3 = child(div);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          var node_4 = sibling(node_1, 2);
          Mounted(node_4, {
            get mounted() {
              return contentState.root.contentMounted;
            },
            set mounted($$value) {
              contentState.root.contentMounted = $$value;
            }
          });
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.root.opts.open.current;
          },
          isStatic: true,
          get id() {
            return id();
          },
          trapFocus: false,
          loop: false,
          preventScroll: false,
          forceMount: true,
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              var fragment_5 = comment();
              const mergedProps2 = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("link-preview")
              }));
              var node_5 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_6 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(mergedProps2),
                    ...contentState.snippetProps
                  }));
                  snippet(node_6, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_912();
                  attribute_effect(div_1, () => ({ ...get(mergedProps2) }));
                  var node_7 = child(div_1);
                  snippet(node_7, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_5, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.root.opts.open.current;
              },
              isStatic: true,
              get id() {
                return id();
              },
              trapFocus: false,
              loop: false,
              preventScroll: false,
              forceMount: false,
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menubar/exports.js
var exports_exports20 = {};
__export(exports_exports20, {
  Arrow: () => Menu_arrow,
  CheckboxGroup: () => Menu_checkbox_group,
  CheckboxItem: () => Menu_checkbox_item,
  Content: () => Menubar_content,
  ContentStatic: () => Menubar_content_static,
  Group: () => Menu_group,
  GroupHeading: () => Menu_group_heading,
  Item: () => Menu_item,
  Menu: () => Menubar_menu,
  Portal: () => Portal,
  RadioGroup: () => Menu_radio_group,
  RadioItem: () => Menu_radio_item,
  Root: () => Menubar,
  Separator: () => Menu_separator,
  Sub: () => Menu_sub,
  SubContent: () => Menu_sub_content,
  SubContentStatic: () => Menu_sub_content_static,
  SubTrigger: () => Menu_sub_trigger,
  Trigger: () => Menubar_trigger
});

// node_modules/bits-ui/dist/bits/menubar/menubar.svelte.js
var menubarAttrs = createBitsAttrs({
  component: "menubar",
  parts: ["root", "trigger", "content"]
});
var MenubarRootContext = new Context("Menubar.Root");
var MenubarMenuContext = new Context("Menubar.Menu");
var _wasOpenedByKeyboard, _triggerIds, _props99;
var _MenubarRootState = class _MenubarRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "attachment");
    __privateAdd(this, _wasOpenedByKeyboard, state(false));
    __privateAdd(this, _triggerIds, state(proxy([])));
    __publicField(this, "valueToChangeHandler", /* @__PURE__ */ new Map());
    /**
     * @param id - the id of the trigger to register
     * @returns - a function to de-register the trigger
     */
    __publicField(this, "registerTrigger", (id) => {
      this.triggerIds.push(id);
      return () => {
        this.triggerIds = this.triggerIds.filter((triggerId) => triggerId !== id);
      };
    });
    /**
     * @param value - the value of the menu to register
     * @param contentId - the content id to associate with the value
     * @returns - a function to de-register the menu
     */
    __publicField(this, "registerMenu", (value, onOpenChange) => {
      this.valueToChangeHandler.set(value, onOpenChange);
      return () => {
        this.valueToChangeHandler.delete(value);
      };
    });
    __publicField(this, "updateValue", (value) => {
      var _a, _b;
      const currValue = this.opts.value.current;
      const currHandler = (_a = this.valueToChangeHandler.get(currValue)) == null ? void 0 : _a.current;
      const nextHandler = (_b = this.valueToChangeHandler.get(value)) == null ? void 0 : _b.current;
      this.opts.value.current = value;
      if (currHandler && currValue !== value) {
        currHandler(false);
      }
      if (nextHandler) {
        nextHandler(true);
      }
    });
    __publicField(this, "getTriggers", () => {
      const node = this.opts.ref.current;
      if (!node) return [];
      return Array.from(node.querySelectorAll(menubarAttrs.selector("trigger")));
    });
    __publicField(this, "onMenuOpen", (id, triggerId) => {
      this.updateValue(id);
      this.rovingFocusGroup.setCurrentTabStopId(triggerId);
    });
    __publicField(this, "onMenuClose", () => {
      this.updateValue("");
    });
    __publicField(this, "onMenuToggle", (id) => {
      this.updateValue(this.opts.value.current ? "" : id);
    });
    __privateAdd(this, _props99, user_derived(() => ({
      id: this.opts.id.current,
      role: "menubar",
      [menubarAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: this.opts.ref,
      candidateAttr: menubarAttrs.trigger,
      loop: this.opts.loop,
      orientation: boxWith(() => "horizontal")
    });
  }
  static create(opts) {
    return MenubarRootContext.set(new _MenubarRootState(opts));
  }
  get wasOpenedByKeyboard() {
    return get(__privateGet(this, _wasOpenedByKeyboard));
  }
  set wasOpenedByKeyboard(value) {
    set(__privateGet(this, _wasOpenedByKeyboard), value, true);
  }
  get triggerIds() {
    return get(__privateGet(this, _triggerIds));
  }
  set triggerIds(value) {
    set(__privateGet(this, _triggerIds), value, true);
  }
  get props() {
    return get(__privateGet(this, _props99));
  }
  set props(value) {
    set(__privateGet(this, _props99), value);
  }
};
_wasOpenedByKeyboard = new WeakMap();
_triggerIds = new WeakMap();
_props99 = new WeakMap();
var MenubarRootState = _MenubarRootState;
var _open2, _triggerNode6, _triggerId2, _contentId3, _contentNode8;
var _MenubarMenuState = class _MenubarMenuState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _open2, user_derived(() => this.root.opts.value.current === this.opts.value.current));
    __publicField(this, "wasOpenedByKeyboard", false);
    __privateAdd(this, _triggerNode6, state(null));
    __privateAdd(this, _triggerId2, user_derived(() => {
      var _a;
      return (_a = this.triggerNode) == null ? void 0 : _a.id;
    }));
    __privateAdd(this, _contentId3, user_derived(() => {
      var _a;
      return (_a = this.contentNode) == null ? void 0 : _a.id;
    }));
    __privateAdd(this, _contentNode8, state(null));
    this.opts = opts;
    this.root = root18;
    watch(() => this.open, () => {
      if (!this.open) {
        this.wasOpenedByKeyboard = false;
      }
    });
    onMount(() => {
      return this.root.registerMenu(this.opts.value.current, opts.onOpenChange);
    });
  }
  static create(opts) {
    return MenubarMenuContext.set(new _MenubarMenuState(opts, MenubarRootContext.get()));
  }
  get open() {
    return get(__privateGet(this, _open2));
  }
  set open(value) {
    set(__privateGet(this, _open2), value);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode6));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode6), value, true);
  }
  get triggerId() {
    return get(__privateGet(this, _triggerId2));
  }
  set triggerId(value) {
    set(__privateGet(this, _triggerId2), value);
  }
  get contentId() {
    return get(__privateGet(this, _contentId3));
  }
  set contentId(value) {
    set(__privateGet(this, _contentId3), value);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode8));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode8), value, true);
  }
  getTriggerNode() {
    return this.triggerNode;
  }
  toggleMenu() {
    this.root.onMenuToggle(this.opts.value.current);
  }
  openMenu() {
    var _a;
    this.root.onMenuOpen(this.opts.value.current, ((_a = this.triggerNode) == null ? void 0 : _a.id) ?? "");
  }
};
_open2 = new WeakMap();
_triggerNode6 = new WeakMap();
_triggerId2 = new WeakMap();
_contentId3 = new WeakMap();
_contentNode8 = new WeakMap();
var MenubarMenuState = _MenubarMenuState;
var _isFocused2, _tabIndex, _props100;
var _MenubarTriggerState = class _MenubarTriggerState {
  constructor(opts, menu) {
    __publicField(this, "opts");
    __publicField(this, "menu");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isFocused2, state(false));
    __privateAdd(this, _tabIndex, state(0));
    __publicField(this, "onpointerdown", (e) => {
      if (!this.opts.disabled.current && e.button === 0 && e.ctrlKey === false) {
        if (!this.menu.open) {
          e.preventDefault();
        }
        this.menu.toggleMenu();
      }
    });
    __publicField(this, "onpointerenter", () => {
      var _a;
      const isMenubarOpen = Boolean(this.root.opts.value.current);
      if (isMenubarOpen && !this.menu.open) {
        this.menu.openMenu();
        (_a = this.menu.getTriggerNode()) == null ? void 0 : _a.focus();
      }
    });
    __publicField(this, "onkeydown", (e) => {
      if (this.opts.disabled.current) return;
      if (e.key === kbd_constants_exports.TAB) return;
      if (e.key === kbd_constants_exports.ENTER || e.key === kbd_constants_exports.SPACE) {
        this.root.onMenuToggle(this.menu.opts.value.current);
      }
      if (e.key === kbd_constants_exports.ARROW_DOWN) {
        this.menu.openMenu();
      }
      if (e.key === kbd_constants_exports.ENTER || e.key === kbd_constants_exports.SPACE || e.key === kbd_constants_exports.ARROW_DOWN) {
        this.menu.wasOpenedByKeyboard = true;
        e.preventDefault();
      }
      this.root.rovingFocusGroup.handleKeydown(this.menu.getTriggerNode(), e);
    });
    __publicField(this, "onfocus", () => {
      this.isFocused = true;
    });
    __publicField(this, "onblur", () => {
      this.isFocused = false;
    });
    __privateAdd(this, _props100, user_derived(() => ({
      type: "button",
      role: "menuitem",
      id: this.opts.id.current,
      "aria-haspopup": "menu",
      "aria-expanded": boolToStr(this.menu.open),
      "aria-controls": this.menu.open ? this.menu.contentId : void 0,
      "data-highlighted": this.isFocused ? "" : void 0,
      "data-state": getDataOpenClosed(this.menu.open),
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      "data-menu-value": this.menu.opts.value.current,
      disabled: this.opts.disabled.current ? true : void 0,
      tabindex: get(__privateGet(this, _tabIndex)),
      [menubarAttrs.trigger]: "",
      onpointerdown: this.onpointerdown,
      onpointerenter: this.onpointerenter,
      onkeydown: this.onkeydown,
      onfocus: this.onfocus,
      onblur: this.onblur,
      ...this.attachment
    })));
    this.opts = opts;
    this.menu = menu;
    this.root = menu.root;
    this.attachment = attachRef(this.opts.ref, (v) => this.menu.triggerNode = v);
    onMount(() => {
      return this.root.registerTrigger(opts.id.current);
    });
    user_effect(() => {
      if (this.root.triggerIds.length) {
        set(__privateGet(this, _tabIndex), this.root.rovingFocusGroup.getTabIndex(this.menu.getTriggerNode()), true);
      }
    });
  }
  static create(opts) {
    return new _MenubarTriggerState(opts, MenubarMenuContext.get());
  }
  get isFocused() {
    return get(__privateGet(this, _isFocused2));
  }
  set isFocused(value) {
    set(__privateGet(this, _isFocused2), value, true);
  }
  get props() {
    return get(__privateGet(this, _props100));
  }
  set props(value) {
    set(__privateGet(this, _props100), value);
  }
};
_isFocused2 = new WeakMap();
_tabIndex = new WeakMap();
_props100 = new WeakMap();
var MenubarTriggerState = _MenubarTriggerState;
var _props101;
var _MenubarContentState = class _MenubarContentState {
  constructor(opts, menu) {
    __publicField(this, "opts");
    __publicField(this, "menu");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __publicField(this, "onCloseAutoFocus", (e) => {
      var _a, _b;
      (_b = (_a = this.opts.onCloseAutoFocus).current) == null ? void 0 : _b.call(_a, e);
      if (e.defaultPrevented) return;
    });
    __publicField(this, "onFocusOutside", (e) => {
      const target = e.target;
      const isMenubarTrigger = this.root.getTriggers().some((trigger) => trigger.contains(target));
      if (isMenubarTrigger) e.preventDefault();
      this.opts.onFocusOutside.current(e);
    });
    __publicField(this, "onInteractOutside", (e) => {
      this.opts.onInteractOutside.current(e);
    });
    __publicField(this, "onOpenAutoFocus", (e) => {
      this.opts.onOpenAutoFocus.current(e);
      if (e.defaultPrevented) return;
      afterTick(() => {
        var _a;
        return (_a = this.opts.ref.current) == null ? void 0 : _a.focus();
      });
    });
    __publicField(this, "onkeydown", (e) => {
      if (e.key !== kbd_constants_exports.ARROW_LEFT && e.key !== kbd_constants_exports.ARROW_RIGHT) return;
      const target = e.target;
      const targetIsSubTrigger = target.hasAttribute("data-menu-sub-trigger");
      const isKeydownInsideSubMenu = target.closest("[data-menu-content]") !== e.currentTarget;
      const prevMenuKey = this.root.opts.dir.current === "rtl" ? kbd_constants_exports.ARROW_RIGHT : kbd_constants_exports.ARROW_LEFT;
      const isPrevKey = prevMenuKey === e.key;
      const isNextKey = !isPrevKey;
      if (isNextKey && targetIsSubTrigger) return;
      if (isKeydownInsideSubMenu && isPrevKey) return;
      const items = this.root.getTriggers().filter((trigger) => !trigger.disabled);
      let candidates = items.map((item) => ({
        value: item.getAttribute("data-menu-value"),
        triggerId: item.id ?? ""
      }));
      if (isPrevKey) candidates.reverse();
      const candidateValues = candidates.map(({ value }) => value);
      const currentIndex = candidateValues.indexOf(this.menu.opts.value.current);
      candidates = this.root.opts.loop.current ? wrapArray(candidates, currentIndex + 1) : candidates.slice(currentIndex + 1);
      const [nextValue] = candidates;
      if (nextValue) this.menu.root.onMenuOpen(nextValue.value, nextValue.triggerId);
    });
    __privateAdd(this, _props101, user_derived(() => ({
      id: this.opts.id.current,
      "aria-labelledby": this.menu.triggerId,
      style: getFloatingContentCSSVars("menubar"),
      onkeydown: this.onkeydown,
      "data-menu-content": "",
      [menubarAttrs.content]: "",
      ...this.attachment
    })));
    __publicField(this, "popperProps", {
      onCloseAutoFocus: this.onCloseAutoFocus,
      onFocusOutside: this.onFocusOutside,
      onInteractOutside: this.onInteractOutside,
      onOpenAutoFocus: this.onOpenAutoFocus
    });
    this.opts = opts;
    this.menu = menu;
    this.root = menu.root;
    this.attachment = attachRef(this.opts.ref, (v) => this.menu.contentNode = v);
  }
  static create(opts) {
    return new _MenubarContentState(opts, MenubarMenuContext.get());
  }
  get props() {
    return get(__privateGet(this, _props101));
  }
  set props(value) {
    set(__privateGet(this, _props101), value);
  }
};
_props101 = new WeakMap();
var MenubarContentState = _MenubarContentState;

// node_modules/bits-ui/dist/bits/menubar/components/menubar.svelte
var root_272 = from_html(`<div><!></div>`);
function Menubar($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), dir = prop($$props, "dir", 3, "ltr"), loop = prop($$props, "loop", 3, true), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "children",
    "child",
    "ref",
    "value",
    "dir",
    "loop",
    "onValueChange"
  ]);
  const rootState = MenubarRootState.create({
    id: boxWith(() => id()),
    value: boxWith(() => value(), (v) => {
      var _a;
      value(v);
      (_a = onValueChange()) == null ? void 0 : _a(v);
    }),
    dir: boxWith(() => dir()),
    loop: boxWith(() => loop()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_272();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menubar/components/menubar-menu.svelte
function Menubar_menu($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let value = prop($$props, "value", 19, () => createId(uid)), onOpenChange = prop($$props, "onOpenChange", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "value",
    "onOpenChange"
  ]);
  const menuState = MenubarMenuState.create({
    value: boxWith(() => value()),
    onOpenChange: boxWith(() => onOpenChange())
  });
  Menu($$anchor, spread_props(
    {
      get open() {
        return menuState.open;
      },
      onOpenChange: (open) => {
        if (!open) menuState.root.onMenuClose();
      },
      get dir() {
        return menuState.root.opts.dir.current;
      },
      _internal_variant: "menubar"
    },
    () => restProps
  ));
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-content.svelte
var root_417 = from_html(`<div><div><!></div></div>`);
var root_913 = from_html(`<div><div><!></div></div>`);
function Menu_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "child",
    "children",
    "ref",
    "loop",
    "onInteractOutside",
    "onEscapeKeydown",
    "onCloseAutoFocus",
    "forceMount"
  ]);
  const contentState = MenuContentState.create({
    id: boxWith(() => id()),
    loop: boxWith(() => loop()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: boxWith(() => onCloseAutoFocusProp())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props, { style: { outline: "none" } }));
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    if (e.target && e.target instanceof Element) {
      const subContentSelector = `[${contentState.parentMenu.root.getBitsAttr("sub-content")}]`;
      if (e.target.closest(subContentSelector)) return;
    }
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: {
              outline: "none",
              ...getFloatingContentCSSVars("menu")
            }
          }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_417();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_3 = child(div_1);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.parentMenu.opts.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          trapFocus: true,
          get loop() {
            return loop();
          },
          forceMount: true,
          get id() {
            return id();
          },
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: {
                  outline: "none",
                  ...getFloatingContentCSSVars("menu")
                }
              }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_913();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_6 = child(div_3);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.parentMenu.opts.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              get id() {
                return id();
              },
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menubar/components/menubar-content.svelte
function Menubar_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), id = prop($$props, "id", 19, () => createId(uid)), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "interactOutsideBehavior",
    "id",
    "onInteractOutside",
    "onFocusOutside",
    "onCloseAutoFocus",
    "onOpenAutoFocus"
  ]);
  const contentState = MenubarContentState.create({
    id: boxWith(() => id()),
    interactOutsideBehavior: boxWith(() => interactOutsideBehavior()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onInteractOutside: boxWith(() => onInteractOutside()),
    onFocusOutside: boxWith(() => onFocusOutside()),
    onCloseAutoFocus: boxWith(() => onCloseAutoFocus()),
    onOpenAutoFocus: boxWith(() => onOpenAutoFocus())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  Menu_content($$anchor, spread_props(() => get(mergedProps), () => contentState.popperProps, {
    preventScroll: false,
    get ref() {
      return ref();
    },
    set ref($$value) {
      ref($$value);
    }
  }));
  pop();
}

// node_modules/bits-ui/dist/bits/menu/components/menu-content-static.svelte
var root_418 = from_html(`<div><!></div>`);
var root_914 = from_html(`<div><!></div>`);
function Menu_content_static($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "child",
    "children",
    "ref",
    "loop",
    "onInteractOutside",
    "onEscapeKeydown",
    "onCloseAutoFocus",
    "forceMount"
  ]);
  const contentState = MenuContentState.create({
    id: boxWith(() => id()),
    loop: boxWith(() => loop()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: boxWith(() => onCloseAutoFocusProp())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props, { style: { outline: "none" } }));
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: {
              outline: "none",
              ...getFloatingContentCSSVars("menu")
            }
          }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_418();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_3 = child(div);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.parentMenu.opts.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          trapFocus: true,
          get loop() {
            return loop();
          },
          forceMount: true,
          isStatic: true,
          get id() {
            return id();
          },
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: {
                  outline: "none",
                  ...getFloatingContentCSSVars("menu")
                }
              }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_914();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_6 = child(div_1);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.parentMenu.opts.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              isStatic: true,
              get id() {
                return id();
              },
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/menubar/components/menubar-content-static.svelte
function Menubar_content_static($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), id = prop($$props, "id", 19, () => createId(uid)), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "interactOutsideBehavior",
    "id",
    "onInteractOutside",
    "onCloseAutoFocus",
    "onFocusOutside",
    "onOpenAutoFocus"
  ]);
  const contentState = MenubarContentState.create({
    id: boxWith(() => id()),
    interactOutsideBehavior: boxWith(() => interactOutsideBehavior()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onInteractOutside: boxWith(() => onInteractOutside()),
    onFocusOutside: boxWith(() => onFocusOutside()),
    onCloseAutoFocus: boxWith(() => onCloseAutoFocus()),
    onOpenAutoFocus: boxWith(() => onOpenAutoFocus())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  Menu_content_static($$anchor, spread_props(() => get(mergedProps), () => contentState.popperProps, {
    preventScroll: false,
    get ref() {
      return ref();
    },
    set ref($$value) {
      ref($$value);
    }
  }));
  pop();
}

// node_modules/bits-ui/dist/bits/menubar/components/menubar-trigger.svelte
var root_315 = from_html(`<button><!></button>`);
function Menubar_trigger($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "disabled",
    "children",
    "child",
    "ref"
  ]);
  const triggerState = MenubarTriggerState.create({
    id: boxWith(() => id()),
    disabled: boxWith(() => disabled() ?? false),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const dropdownTriggerState = DropdownMenuTriggerState.create(triggerState.opts);
  const triggerAttachment = attachRef((v) => dropdownTriggerState.parentMenu.triggerNode = v);
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props, { ...triggerAttachment }));
  Floating_layer_anchor($$anchor, {
    get id() {
      return id();
    },
    get ref() {
      return triggerState.opts.ref;
    },
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_1 = first_child(fragment_2);
          snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var button = root_315();
          attribute_effect(button, () => ({ ...get(mergedProps) }));
          var node_2 = child(button);
          snippet(node_2, () => $$props.children ?? noop);
          reset(button);
          append($$anchor3, button);
        };
        if_block(node, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/bits-ui/dist/bits/meter/exports.js
var exports_exports21 = {};
__export(exports_exports21, {
  Root: () => Meter
});

// node_modules/bits-ui/dist/bits/meter/meter.svelte.js
var meterAttrs = createBitsAttrs({ component: "meter", parts: ["root"] });
var _props102;
var _MeterRootState = class _MeterRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props102, user_derived(() => ({
      role: "meter",
      value: this.opts.value.current,
      "aria-valuemin": this.opts.min.current,
      "aria-valuemax": this.opts.max.current,
      "aria-valuenow": this.opts.value.current,
      "data-value": this.opts.value.current,
      "data-max": this.opts.max.current,
      "data-min": this.opts.min.current,
      [meterAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _MeterRootState(opts);
  }
  get props() {
    return get(__privateGet(this, _props102));
  }
  set props(value) {
    set(__privateGet(this, _props102), value);
  }
};
_props102 = new WeakMap();
var MeterRootState = _MeterRootState;

// node_modules/bits-ui/dist/bits/meter/components/meter.svelte
var root_273 = from_html(`<div><!></div>`);
function Meter($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let value = prop($$props, "value", 3, 0), max = prop($$props, "max", 3, 100), min = prop($$props, "min", 3, 0), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "value",
    "max",
    "min",
    "id",
    "ref"
  ]);
  const rootState = MeterRootState.create({
    value: boxWith(() => value()),
    max: boxWith(() => max()),
    min: boxWith(() => min()),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_273();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/navigation-menu/exports.js
var exports_exports22 = {};
__export(exports_exports22, {
  Content: () => Navigation_menu_content,
  Indicator: () => Navigation_menu_indicator,
  Item: () => Navigation_menu_item,
  Link: () => Navigation_menu_link,
  List: () => Navigation_menu_list,
  Root: () => Navigation_menu,
  Sub: () => Navigation_menu_sub,
  Trigger: () => Navigation_menu_trigger,
  Viewport: () => Navigation_menu_viewport
});

// node_modules/bits-ui/dist/bits/pin-input/usePasswordManager.svelte.js
var PWM_BADGE_MARGIN_RIGHT = 18;
var PWM_BADGE_SPACE_WIDTH_PX = 40;
var PWM_BADGE_SPACE_WIDTH = `${PWM_BADGE_SPACE_WIDTH_PX}px`;
var PASSWORD_MANAGER_SELECTORS = [
  "[data-lastpass-icon-root]",
  // LastPass,
  "com-1password-button",
  // 1Password,
  "[data-dashlanecreated]",
  // Dashlane,
  '[style$="2147483647 !important;"]'
  // Bitwarden
].join(",");
function usePasswordManagerBadge({
  containerRef,
  inputRef,
  pushPasswordManagerStrategy,
  isFocused,
  domContext
}) {
  let hasPwmBadge = state(false);
  let hasPwmBadgeSpace = state(false);
  let done = state(false);
  function willPushPwmBadge() {
    const strategy = pushPasswordManagerStrategy.current;
    if (strategy === "none") return false;
    const increaseWidthCase = strategy === "increase-width" && get(hasPwmBadge) && get(hasPwmBadgeSpace);
    return increaseWidthCase;
  }
  function trackPwmBadge() {
    const container = containerRef.current;
    const input = inputRef.current;
    if (!container || !input || get(done) || pushPasswordManagerStrategy.current === "none") return;
    const elementToCompare = container;
    const rightCornerX = elementToCompare.getBoundingClientRect().left + elementToCompare.offsetWidth;
    const centeredY = elementToCompare.getBoundingClientRect().top + elementToCompare.offsetHeight / 2;
    const x = rightCornerX - PWM_BADGE_MARGIN_RIGHT;
    const y = centeredY;
    const passwordManagerStrategy = domContext.querySelectorAll(PASSWORD_MANAGER_SELECTORS);
    if (passwordManagerStrategy.length === 0) {
      const maybeBadgeEl = domContext.getDocument().elementFromPoint(x, y);
      if (maybeBadgeEl === container) return;
    }
    set(hasPwmBadge, true);
    set(done, true);
  }
  user_effect(() => {
    const container = containerRef.current;
    if (!container || pushPasswordManagerStrategy.current === "none") return;
    function checkHasSpace() {
      const viewportWidth = getWindow(container).innerWidth;
      const distanceToRightEdge = viewportWidth - container.getBoundingClientRect().right;
      set(hasPwmBadgeSpace, distanceToRightEdge >= PWM_BADGE_SPACE_WIDTH_PX);
    }
    checkHasSpace();
    const interval = setInterval(checkHasSpace, 1e3);
    return () => {
      clearInterval(interval);
    };
  });
  user_effect(() => {
    const focused = isFocused.current || domContext.getActiveElement() === inputRef.current;
    if (pushPasswordManagerStrategy.current === "none" || !focused) return;
    const t1 = setTimeout(trackPwmBadge, 0);
    const t2 = setTimeout(trackPwmBadge, 2e3);
    const t3 = setTimeout(trackPwmBadge, 5e3);
    const t4 = setTimeout(
      () => {
        set(done, true);
      },
      6e3
    );
    return () => {
      clearTimeout(t1);
      clearTimeout(t2);
      clearTimeout(t3);
      clearTimeout(t4);
    };
  });
  return {
    get hasPwmBadge() {
      return get(hasPwmBadge);
    },
    get willPushPwmBadge() {
      return willPushPwmBadge();
    },
    PWM_BADGE_SPACE_WIDTH
  };
}

// node_modules/bits-ui/dist/bits/pin-input/pin-input.svelte.js
var REGEXP_ONLY_DIGITS = "^\\d+$";
var REGEXP_ONLY_CHARS = "^[a-zA-Z]+$";
var REGEXP_ONLY_DIGITS_AND_CHARS = "^[a-zA-Z0-9]+$";
var pinInputAttrs = createBitsAttrs({
  component: "pin-input",
  parts: ["root", "cell"]
});
var KEYS_TO_IGNORE = [
  "Backspace",
  "Delete",
  "ArrowLeft",
  "ArrowRight",
  "ArrowUp",
  "ArrowDown",
  "Home",
  "End",
  "Escape",
  "Enter",
  "Tab",
  "Shift",
  "Control",
  "Meta"
];
var _inputRef, _isHoveringInput, _isFocused3, _mirrorSelectionStart, _mirrorSelectionEnd, _previousValue, _regexPattern, _prevInputMetadata, _pwmb, _initialLoad, _rootStyles, _rootProps, _inputWrapperProps, _inputStyle, _PinInputRootState_instances, applyStyles_fn, _onDocumentSelectionChange, _inputProps, _cells, _snippetProps21;
var _PinInputRootState = class _PinInputRootState {
  constructor(opts) {
    __privateAdd(this, _PinInputRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _inputRef, simpleBox(null));
    __privateAdd(this, _isHoveringInput, state(false));
    __publicField(this, "inputAttachment", attachRef(__privateGet(this, _inputRef)));
    __privateAdd(this, _isFocused3, simpleBox(false));
    __privateAdd(this, _mirrorSelectionStart, state(null));
    __privateAdd(this, _mirrorSelectionEnd, state(null));
    __privateAdd(this, _previousValue, new Previous(() => this.opts.value.current ?? ""));
    __privateAdd(this, _regexPattern, user_derived(() => {
      if (typeof this.opts.pattern.current === "string") {
        return new RegExp(this.opts.pattern.current);
      } else {
        return this.opts.pattern.current;
      }
    }));
    __privateAdd(this, _prevInputMetadata, state(proxy({
      prev: [null, null, "none"],
      willSyntheticBlur: false
    })));
    __privateAdd(this, _pwmb);
    __privateAdd(this, _initialLoad);
    __publicField(this, "domContext");
    __publicField(this, "onkeydown", (e) => {
      const key = e.key;
      if (KEYS_TO_IGNORE.includes(key)) return;
      if (e.ctrlKey || e.metaKey) return;
      if (key && get(__privateGet(this, _regexPattern)) && !get(__privateGet(this, _regexPattern)).test(key)) {
        e.preventDefault();
      }
    });
    __privateAdd(this, _rootStyles, user_derived(() => ({
      position: "relative",
      cursor: this.opts.disabled.current ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })));
    __privateAdd(this, _rootProps, user_derived(() => ({
      id: this.opts.id.current,
      [pinInputAttrs.root]: "",
      style: get(__privateGet(this, _rootStyles)),
      ...this.attachment
    })));
    __privateAdd(this, _inputWrapperProps, user_derived(() => ({
      style: {
        position: "absolute",
        inset: 0,
        pointerEvents: "none"
      }
    })));
    __privateAdd(this, _inputStyle, user_derived(() => ({
      position: "absolute",
      inset: 0,
      width: __privateGet(this, _pwmb).willPushPwmBadge ? `calc(100% + ${__privateGet(this, _pwmb).PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: __privateGet(this, _pwmb).willPushPwmBadge ? `inset(0 ${__privateGet(this, _pwmb).PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: this.opts.textAlign.current,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--bits-pin-input-root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })));
    __privateAdd(this, _onDocumentSelectionChange, () => {
      var _a;
      const input = __privateGet(this, _inputRef).current;
      const container = this.opts.ref.current;
      if (!input || !container) return;
      if (this.domContext.getActiveElement() !== input) {
        set(__privateGet(this, _mirrorSelectionStart), null);
        set(__privateGet(this, _mirrorSelectionEnd), null);
        return;
      }
      const selStart = input.selectionStart;
      const selEnd = input.selectionEnd;
      const selDir = input.selectionDirection ?? "none";
      const maxLength = input.maxLength;
      const val = input.value;
      const prev2 = get(__privateGet(this, _prevInputMetadata)).prev;
      let start = -1;
      let end = -1;
      let direction;
      if (val.length !== 0 && selStart !== null && selEnd !== null) {
        const isSingleCaret = selStart === selEnd;
        const isInsertMode = selStart === val.length && val.length < maxLength;
        if (isSingleCaret && !isInsertMode) {
          const c = selStart;
          if (c === 0) {
            start = 0;
            end = 1;
            direction = "forward";
          } else if (c === maxLength) {
            start = c - 1;
            end = c;
            direction = "backward";
          } else if (maxLength > 1 && val.length > 1) {
            let offset2 = 0;
            if (prev2[0] !== null && prev2[1] !== null) {
              direction = c < prev2[0] ? "backward" : "forward";
              const wasPreviouslyInserting = prev2[0] === prev2[1] && prev2[0] < maxLength;
              if (direction === "backward" && !wasPreviouslyInserting) {
                offset2 = -1;
              }
            }
            start = offset2 - c;
            end = offset2 + c + 1;
          }
        }
        if (start !== -1 && end !== -1 && start !== end) {
          (_a = __privateGet(this, _inputRef).current) == null ? void 0 : _a.setSelectionRange(start, end, direction);
        }
      }
      const s = start !== -1 ? start : selStart;
      const e = end !== -1 ? end : selEnd;
      const dir = direction ?? selDir;
      set(__privateGet(this, _mirrorSelectionStart), s, true);
      set(__privateGet(this, _mirrorSelectionEnd), e, true);
      get(__privateGet(this, _prevInputMetadata)).prev = [s, e, dir];
    });
    __publicField(this, "oninput", (e) => {
      const newValue = e.currentTarget.value.slice(0, this.opts.maxLength.current);
      if (newValue.length > 0 && get(__privateGet(this, _regexPattern)) && !get(__privateGet(this, _regexPattern)).test(newValue)) {
        e.preventDefault();
        return;
      }
      const maybeHasDeleted = typeof __privateGet(this, _previousValue).current === "string" && newValue.length < __privateGet(this, _previousValue).current.length;
      if (maybeHasDeleted) {
        this.domContext.getDocument().dispatchEvent(new Event("selectionchange"));
      }
      this.opts.value.current = newValue;
    });
    __publicField(this, "onfocus", (_) => {
      const input = __privateGet(this, _inputRef).current;
      if (input) {
        const start = Math.min(input.value.length, this.opts.maxLength.current - 1);
        const end = input.value.length;
        input.setSelectionRange(start, end);
        set(__privateGet(this, _mirrorSelectionStart), start, true);
        set(__privateGet(this, _mirrorSelectionEnd), end, true);
      }
      __privateGet(this, _isFocused3).current = true;
    });
    __publicField(this, "onpaste", (e) => {
      var _a, _b, _c, _d;
      const input = __privateGet(this, _inputRef).current;
      if (!input) return;
      const getNewValue = (finalContent) => {
        const start = input.selectionStart === null ? void 0 : input.selectionStart;
        const end = input.selectionEnd === null ? void 0 : input.selectionEnd;
        const isReplacing = start !== end;
        const initNewVal = this.opts.value.current;
        const newValueUncapped = isReplacing ? initNewVal.slice(0, start) + finalContent + initNewVal.slice(end) : initNewVal.slice(0, start) + finalContent + initNewVal.slice(start);
        return newValueUncapped.slice(0, this.opts.maxLength.current);
      };
      const isValueInvalid = (newValue2) => {
        return newValue2.length > 0 && get(__privateGet(this, _regexPattern)) && !get(__privateGet(this, _regexPattern)).test(newValue2);
      };
      if (!((_a = this.opts.pasteTransformer) == null ? void 0 : _a.current) && (!__privateGet(this, _initialLoad).isIOS || !e.clipboardData || !input)) {
        const newValue2 = getNewValue((_b = e.clipboardData) == null ? void 0 : _b.getData("text/plain"));
        if (isValueInvalid(newValue2)) {
          e.preventDefault();
        }
        return;
      }
      const _content = ((_c = e.clipboardData) == null ? void 0 : _c.getData("text/plain")) ?? "";
      const content = ((_d = this.opts.pasteTransformer) == null ? void 0 : _d.current) ? this.opts.pasteTransformer.current(_content) : _content;
      e.preventDefault();
      const newValue = getNewValue(content);
      if (isValueInvalid(newValue)) return;
      input.value = newValue;
      this.opts.value.current = newValue;
      const selStart = Math.min(newValue.length, this.opts.maxLength.current - 1);
      const selEnd = newValue.length;
      input.setSelectionRange(selStart, selEnd);
      set(__privateGet(this, _mirrorSelectionStart), selStart, true);
      set(__privateGet(this, _mirrorSelectionEnd), selEnd, true);
    });
    __publicField(this, "onmouseover", (_) => {
      set(__privateGet(this, _isHoveringInput), true);
    });
    __publicField(this, "onmouseleave", (_) => {
      set(__privateGet(this, _isHoveringInput), false);
    });
    __publicField(this, "onblur", (_) => {
      if (get(__privateGet(this, _prevInputMetadata)).willSyntheticBlur) {
        get(__privateGet(this, _prevInputMetadata)).willSyntheticBlur = false;
        return;
      }
      __privateGet(this, _isFocused3).current = false;
    });
    __privateAdd(this, _inputProps, user_derived(() => {
      var _a;
      return {
        id: this.opts.inputId.current,
        style: get(__privateGet(this, _inputStyle)),
        autocomplete: this.opts.autocomplete.current || "one-time-code",
        "data-pin-input-input": "",
        "data-pin-input-input-mss": get(__privateGet(this, _mirrorSelectionStart)),
        "data-pin-input-input-mse": get(__privateGet(this, _mirrorSelectionEnd)),
        inputmode: this.opts.inputmode.current,
        pattern: (_a = get(__privateGet(this, _regexPattern))) == null ? void 0 : _a.source,
        maxlength: this.opts.maxLength.current,
        value: this.opts.value.current,
        disabled: boolToTrueOrUndef(this.opts.disabled.current),
        //
        onpaste: this.onpaste,
        oninput: this.oninput,
        onkeydown: this.onkeydown,
        onmouseover: this.onmouseover,
        onmouseleave: this.onmouseleave,
        onfocus: this.onfocus,
        onblur: this.onblur,
        ...this.inputAttachment
      };
    }));
    __privateAdd(this, _cells, user_derived(() => Array.from({ length: this.opts.maxLength.current }).map((_, idx) => {
      const isActive = __privateGet(this, _isFocused3).current && get(__privateGet(this, _mirrorSelectionStart)) !== null && get(__privateGet(this, _mirrorSelectionEnd)) !== null && (get(__privateGet(this, _mirrorSelectionStart)) === get(__privateGet(this, _mirrorSelectionEnd)) && idx === get(__privateGet(this, _mirrorSelectionStart)) || idx >= get(__privateGet(this, _mirrorSelectionStart)) && idx < get(__privateGet(this, _mirrorSelectionEnd)));
      const char = this.opts.value.current[idx] !== void 0 ? this.opts.value.current[idx] : null;
      return {
        char,
        isActive,
        hasFakeCaret: isActive && char === null
      };
    })));
    __privateAdd(this, _snippetProps21, user_derived(() => ({
      cells: get(__privateGet(this, _cells)),
      isFocused: __privateGet(this, _isFocused3).current,
      isHovering: get(__privateGet(this, _isHoveringInput))
    })));
    var _a;
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.domContext = new DOMContext(opts.ref);
    __privateSet(this, _initialLoad, {
      value: this.opts.value,
      isIOS: typeof window !== "undefined" && ((_a = window == null ? void 0 : window.CSS) == null ? void 0 : _a.supports("-webkit-touch-callout", "none"))
    });
    __privateSet(this, _pwmb, usePasswordManagerBadge({
      containerRef: this.opts.ref,
      inputRef: __privateGet(this, _inputRef),
      isFocused: __privateGet(this, _isFocused3),
      pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
      domContext: this.domContext
    }));
    onMount(() => {
      const input = __privateGet(this, _inputRef).current;
      const container = this.opts.ref.current;
      if (!input || !container) return;
      if (__privateGet(this, _initialLoad).value.current !== input.value) {
        this.opts.value.current = input.value;
      }
      get(__privateGet(this, _prevInputMetadata)).prev = [
        input.selectionStart,
        input.selectionEnd,
        input.selectionDirection ?? "none"
      ];
      const unsub = on(this.domContext.getDocument(), "selectionchange", __privateGet(this, _onDocumentSelectionChange), { capture: true });
      __privateGet(this, _onDocumentSelectionChange).call(this);
      if (this.domContext.getActiveElement() === input) {
        __privateGet(this, _isFocused3).current = true;
      }
      if (!this.domContext.getElementById("pin-input-style")) {
        __privateMethod(this, _PinInputRootState_instances, applyStyles_fn).call(this);
      }
      const updateRootHeight = () => {
        if (container) {
          container.style.setProperty("--bits-pin-input-root-height", `${input.clientHeight}px`);
        }
      };
      updateRootHeight();
      const resizeObserver = new ResizeObserver(updateRootHeight);
      resizeObserver.observe(input);
      return () => {
        unsub();
        resizeObserver.disconnect();
      };
    });
    watch(
      [
        () => this.opts.value.current,
        () => __privateGet(this, _inputRef).current
      ],
      () => {
        syncTimeouts(
          () => {
            const input = __privateGet(this, _inputRef).current;
            if (!input) return;
            input.dispatchEvent(new Event("input"));
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const dir = input.selectionDirection ?? "none";
            if (start !== null && end !== null) {
              set(__privateGet(this, _mirrorSelectionStart), start, true);
              set(__privateGet(this, _mirrorSelectionEnd), end, true);
              get(__privateGet(this, _prevInputMetadata)).prev = [start, end, dir];
            }
          },
          this.domContext
        );
      }
    );
    user_effect(() => {
      const value = this.opts.value.current;
      const prevValue = __privateGet(this, _previousValue).current;
      const maxLength = this.opts.maxLength.current;
      const onComplete = this.opts.onComplete.current;
      if (prevValue === void 0) return;
      if (value !== prevValue && prevValue.length < maxLength && value.length === maxLength) {
        onComplete(value);
      }
    });
  }
  static create(opts) {
    return new _PinInputRootState(opts);
  }
  get rootProps() {
    return get(__privateGet(this, _rootProps));
  }
  set rootProps(value) {
    set(__privateGet(this, _rootProps), value);
  }
  get inputWrapperProps() {
    return get(__privateGet(this, _inputWrapperProps));
  }
  set inputWrapperProps(value) {
    set(__privateGet(this, _inputWrapperProps), value);
  }
  get inputProps() {
    return get(__privateGet(this, _inputProps));
  }
  set inputProps(value) {
    set(__privateGet(this, _inputProps), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps21));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps21), value);
  }
};
_inputRef = new WeakMap();
_isHoveringInput = new WeakMap();
_isFocused3 = new WeakMap();
_mirrorSelectionStart = new WeakMap();
_mirrorSelectionEnd = new WeakMap();
_previousValue = new WeakMap();
_regexPattern = new WeakMap();
_prevInputMetadata = new WeakMap();
_pwmb = new WeakMap();
_initialLoad = new WeakMap();
_rootStyles = new WeakMap();
_rootProps = new WeakMap();
_inputWrapperProps = new WeakMap();
_inputStyle = new WeakMap();
_PinInputRootState_instances = new WeakSet();
applyStyles_fn = function() {
  const doc = this.domContext.getDocument();
  const styleEl = doc.createElement("style");
  styleEl.id = "pin-input-style";
  doc.head.appendChild(styleEl);
  if (styleEl.sheet) {
    const autoFillStyles = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
    safeInsertRule(styleEl.sheet, "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }");
    safeInsertRule(styleEl.sheet, `[data-pin-input-input]:autofill { ${autoFillStyles} }`);
    safeInsertRule(styleEl.sheet, `[data-pin-input-input]:-webkit-autofill { ${autoFillStyles} }`);
    safeInsertRule(styleEl.sheet, `@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }`);
    safeInsertRule(styleEl.sheet, `[data-pin-input-input] + * { pointer-events: all !important; }`);
  }
};
_onDocumentSelectionChange = new WeakMap();
_inputProps = new WeakMap();
_cells = new WeakMap();
_snippetProps21 = new WeakMap();
var PinInputRootState = _PinInputRootState;
var _props103;
var _PinInputCellState = class _PinInputCellState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props103, user_derived(() => ({
      id: this.opts.id.current,
      [pinInputAttrs.cell]: "",
      "data-active": this.opts.cell.current.isActive ? "" : void 0,
      "data-inactive": !this.opts.cell.current.isActive ? "" : void 0,
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _PinInputCellState(opts);
  }
  get props() {
    return get(__privateGet(this, _props103));
  }
  set props(value) {
    set(__privateGet(this, _props103), value);
  }
};
_props103 = new WeakMap();
var PinInputCellState = _PinInputCellState;
function syncTimeouts(cb, domContext) {
  const t1 = domContext.setTimeout(cb, 0);
  const t2 = domContext.setTimeout(cb, 10);
  const t3 = domContext.setTimeout(cb, 50);
  return [t1, t2, t3];
}
function safeInsertRule(sheet, rule) {
  try {
    sheet.insertRule(rule);
  } catch {
    console.error("pin input could not insert CSS rule:", rule);
  }
}

// node_modules/bits-ui/dist/internal/use-arrow-navigation.js
var ignoredElement = ["INPUT", "TEXTAREA"];
function useArrowNavigation(e, currentElement, parentElement, options) {
  if (!currentElement || options.enableIgnoredElement && ignoredElement.includes(currentElement.nodeName)) {
    return null;
  }
  const { arrowKeyOptions = "both", candidateSelector: attributeName, itemsArray = [], loop = true, dir = "ltr", preventScroll = true, focus: focus2 = false } = options;
  const [right, left, up, down, home, end] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ];
  const goingVertical = up || down;
  const goingHorizontal = right || left;
  if (!home && !end && (!goingVertical && !goingHorizontal || arrowKeyOptions === "vertical" && goingHorizontal || arrowKeyOptions === "horizontal" && goingVertical))
    return null;
  const allCollectionItems = parentElement ? Array.from(parentElement.querySelectorAll(attributeName)) : itemsArray;
  if (!allCollectionItems.length)
    return null;
  if (preventScroll)
    e.preventDefault();
  let item = null;
  if (goingHorizontal || goingVertical) {
    const goForward = goingVertical ? down : dir === "ltr" ? right : left;
    item = findNextFocusableElement(allCollectionItems, currentElement, {
      goForward,
      loop
    });
  } else if (home) {
    item = allCollectionItems.at(0) || null;
  } else if (end) {
    item = allCollectionItems.at(-1) || null;
  }
  if (focus2)
    item == null ? void 0 : item.focus();
  return item;
}
function findNextFocusableElement(elements, currentElement, { goForward, loop }, iterations = elements.length) {
  if (--iterations === 0)
    return null;
  const index = elements.indexOf(currentElement);
  const newIndex = goForward ? index + 1 : index - 1;
  if (!loop && (newIndex < 0 || newIndex >= elements.length))
    return null;
  const adjustedNewIndex = (newIndex + elements.length) % elements.length;
  const candidate = elements[adjustedNewIndex];
  if (!candidate)
    return null;
  const isDisabled = candidate.hasAttribute("disabled") && candidate.getAttribute("disabled") !== "false";
  if (isDisabled) {
    return findNextFocusableElement(elements, candidate, { goForward, loop }, iterations);
  }
  return candidate;
}

// node_modules/bits-ui/dist/internal/svelte-resize-observer.svelte.js
var _node2, _onResize;
var SvelteResizeObserver = class {
  constructor(node, onResize) {
    __privateAdd(this, _node2);
    __privateAdd(this, _onResize);
    __privateSet(this, _node2, node);
    __privateSet(this, _onResize, onResize);
    this.handler = this.handler.bind(this);
    user_effect(this.handler);
  }
  handler() {
    let rAF = 0;
    const _node3 = __privateGet(this, _node2).call(this);
    if (!_node3) return;
    const resizeObserver = new ResizeObserver(() => {
      cancelAnimationFrame(rAF);
      rAF = window.requestAnimationFrame(__privateGet(this, _onResize));
    });
    resizeObserver.observe(_node3);
    return () => {
      window.cancelAnimationFrame(rAF);
      resizeObserver.unobserve(_node3);
    };
  }
};
_node2 = new WeakMap();
_onResize = new WeakMap();

// node_modules/bits-ui/dist/bits/navigation-menu/navigation-menu.svelte.js
var navigationMenuAttrs = createBitsAttrs({
  component: "navigation-menu",
  parts: [
    "root",
    "sub",
    "item",
    "list",
    "trigger",
    "content",
    "link",
    "viewport",
    "menu",
    "indicator"
  ]
});
var NavigationMenuProviderContext = new Context("NavigationMenu.Root");
var NavigationMenuItemContext = new Context("NavigationMenu.Item");
var NavigationMenuListContext = new Context("NavigationMenu.List");
var NavigationMenuContentContext = new Context("NavigationMenu.Content");
var NavigationMenuSubContext = new Context("NavigationMenu.Sub");
var NavigationMenuProviderState = class _NavigationMenuProviderState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "indicatorTrackRef", simpleBox(null));
    __publicField(this, "viewportRef", simpleBox(null));
    __publicField(this, "viewportContent", new SvelteMap());
    __publicField(this, "onTriggerEnter");
    __publicField(this, "onTriggerLeave", noop3);
    __publicField(this, "onContentEnter", noop3);
    __publicField(this, "onContentLeave", noop3);
    __publicField(this, "onItemSelect");
    __publicField(this, "onItemDismiss");
    __publicField(this, "activeItem", null);
    __publicField(this, "prevActiveItem", null);
    __publicField(this, "setActiveItem", (item) => {
      this.prevActiveItem = this.activeItem;
      this.activeItem = item;
    });
    this.opts = opts;
    this.onTriggerEnter = opts.onTriggerEnter;
    this.onTriggerLeave = opts.onTriggerLeave ?? noop3;
    this.onContentEnter = opts.onContentEnter ?? noop3;
    this.onContentLeave = opts.onContentLeave ?? noop3;
    this.onItemDismiss = opts.onItemDismiss;
    this.onItemSelect = opts.onItemSelect;
  }
  static create(opts) {
    return NavigationMenuProviderContext.set(new _NavigationMenuProviderState(opts));
  }
};
var _derivedDelay, _debouncedFn, _onTriggerEnter, _onTriggerLeave, _onContentEnter, _onContentLeave, _onItemSelect, _onItemDismiss, _props104;
var _NavigationMenuRootState = class _NavigationMenuRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __publicField(this, "provider");
    __publicField(this, "previousValue", simpleBox(""));
    __publicField(this, "isDelaySkipped");
    __privateAdd(this, _derivedDelay, user_derived(() => {
      var _a, _b;
      const isOpen = ((_b = (_a = this.opts) == null ? void 0 : _a.value) == null ? void 0 : _b.current) !== "";
      if (isOpen || this.isDelaySkipped.current) {
        return 100;
      } else {
        return this.opts.delayDuration.current;
      }
    }));
    __privateAdd(this, _debouncedFn, useDebounce(
      (val, itemState) => {
        if (typeof val === "string") {
          this.setValue(val, itemState);
        }
      },
      () => get(__privateGet(this, _derivedDelay))
    ));
    __privateAdd(this, _onTriggerEnter, (itemValue, itemState) => {
      __privateGet(this, _debouncedFn).call(this, itemValue, itemState);
    });
    __privateAdd(this, _onTriggerLeave, () => {
      this.isDelaySkipped.current = false;
      __privateGet(this, _debouncedFn).call(this, "", null);
    });
    __privateAdd(this, _onContentEnter, () => {
      __privateGet(this, _debouncedFn).call(this, void 0, null);
    });
    __privateAdd(this, _onContentLeave, () => {
      if (this.provider.activeItem && this.provider.activeItem.opts.openOnHover.current === false) {
        return;
      }
      __privateGet(this, _debouncedFn).call(this, "", null);
    });
    __privateAdd(this, _onItemSelect, (itemValue, itemState) => {
      this.setValue(itemValue, itemState);
    });
    __privateAdd(this, _onItemDismiss, () => {
      this.setValue("", null);
    });
    __publicField(this, "setValue", (newValue, itemState) => {
      this.previousValue.current = this.opts.value.current;
      this.opts.value.current = newValue;
      this.provider.setActiveItem(itemState);
      if (newValue === "") {
        this.previousValue.current = "";
      }
    });
    __privateAdd(this, _props104, user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": this.opts.orientation.current,
      dir: this.opts.dir.current,
      [navigationMenuAttrs.root]: "",
      [navigationMenuAttrs.menu]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.isDelaySkipped = boxAutoReset(false, {
      afterMs: this.opts.skipDelayDuration.current,
      getWindow: () => getWindow(opts.ref.current)
    });
    this.provider = NavigationMenuProviderState.create({
      value: this.opts.value,
      previousValue: this.previousValue,
      dir: this.opts.dir,
      orientation: this.opts.orientation,
      rootNavigationMenuRef: this.opts.ref,
      isRootMenu: true,
      onTriggerEnter: (itemValue, itemState) => {
        __privateGet(this, _onTriggerEnter).call(this, itemValue, itemState);
      },
      onTriggerLeave: __privateGet(this, _onTriggerLeave),
      onContentEnter: __privateGet(this, _onContentEnter),
      onContentLeave: __privateGet(this, _onContentLeave),
      onItemSelect: __privateGet(this, _onItemSelect),
      onItemDismiss: __privateGet(this, _onItemDismiss)
    });
  }
  static create(opts) {
    return new _NavigationMenuRootState(opts);
  }
  get props() {
    return get(__privateGet(this, _props104));
  }
  set props(value) {
    set(__privateGet(this, _props104), value);
  }
};
_derivedDelay = new WeakMap();
_debouncedFn = new WeakMap();
_onTriggerEnter = new WeakMap();
_onTriggerLeave = new WeakMap();
_onContentEnter = new WeakMap();
_onContentLeave = new WeakMap();
_onItemSelect = new WeakMap();
_onItemDismiss = new WeakMap();
_props104 = new WeakMap();
var NavigationMenuRootState = _NavigationMenuRootState;
var _props105;
var _NavigationMenuSubState = class _NavigationMenuSubState {
  constructor(opts, context) {
    __publicField(this, "opts");
    __publicField(this, "context");
    __publicField(this, "previousValue", simpleBox(""));
    __publicField(this, "subProvider");
    __publicField(this, "attachment");
    __publicField(this, "setValue", (newValue, itemState) => {
      this.previousValue.current = this.opts.value.current;
      this.opts.value.current = newValue;
      this.subProvider.setActiveItem(itemState);
      if (newValue === "") {
        this.previousValue.current = "";
      }
    });
    __privateAdd(this, _props105, user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": this.opts.orientation.current,
      [navigationMenuAttrs.sub]: "",
      [navigationMenuAttrs.menu]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.context = context;
    this.attachment = attachRef(this.opts.ref);
    this.subProvider = NavigationMenuProviderState.create({
      isRootMenu: false,
      value: this.opts.value,
      dir: this.context.opts.dir,
      orientation: this.opts.orientation,
      rootNavigationMenuRef: this.opts.ref,
      onTriggerEnter: this.setValue,
      onItemSelect: this.setValue,
      onItemDismiss: () => this.setValue("", null),
      previousValue: this.previousValue
    });
  }
  static create(opts) {
    return new _NavigationMenuSubState(opts, NavigationMenuProviderContext.get());
  }
  get props() {
    return get(__privateGet(this, _props105));
  }
  set props(value) {
    set(__privateGet(this, _props105), value);
  }
};
_props105 = new WeakMap();
var NavigationMenuSubState = _NavigationMenuSubState;
var _listTriggers, _wrapperMounted, _wrapperProps2, _props106;
var _NavigationMenuListState = class _NavigationMenuListState {
  constructor(opts, context) {
    __publicField(this, "wrapperId", simpleBox(useId()));
    __publicField(this, "wrapperRef", simpleBox(null));
    __publicField(this, "opts");
    __publicField(this, "context");
    __publicField(this, "attachment");
    __publicField(this, "wrapperAttachment", attachRef(this.wrapperRef, (v) => this.context.indicatorTrackRef.current = v));
    __privateAdd(this, _listTriggers, state([]));
    __publicField(this, "rovingFocusGroup");
    __privateAdd(this, _wrapperMounted, state(false));
    __privateAdd(this, _wrapperProps2, user_derived(() => ({
      id: this.wrapperId.current,
      ...this.wrapperAttachment
    })));
    __privateAdd(this, _props106, user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": this.context.opts.orientation.current,
      [navigationMenuAttrs.list]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.context = context;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: opts.ref,
      candidateSelector: `${navigationMenuAttrs.selector("trigger")}:not([data-disabled]), ${navigationMenuAttrs.selector("link")}:not([data-disabled])`,
      loop: boxWith(() => false),
      orientation: this.context.opts.orientation
    });
  }
  static create(opts) {
    return NavigationMenuListContext.set(new _NavigationMenuListState(opts, NavigationMenuProviderContext.get()));
  }
  get listTriggers() {
    return get(__privateGet(this, _listTriggers));
  }
  set listTriggers(value) {
    set(__privateGet(this, _listTriggers), value);
  }
  get wrapperMounted() {
    return get(__privateGet(this, _wrapperMounted));
  }
  set wrapperMounted(value) {
    set(__privateGet(this, _wrapperMounted), value, true);
  }
  registerTrigger(trigger) {
    if (trigger) this.listTriggers.push(trigger);
    return () => {
      this.listTriggers = this.listTriggers.filter((t) => t.id !== trigger.id);
    };
  }
  get wrapperProps() {
    return get(__privateGet(this, _wrapperProps2));
  }
  set wrapperProps(value) {
    set(__privateGet(this, _wrapperProps2), value);
  }
  get props() {
    return get(__privateGet(this, _props106));
  }
  set props(value) {
    set(__privateGet(this, _props106), value);
  }
};
_listTriggers = new WeakMap();
_wrapperMounted = new WeakMap();
_wrapperProps2 = new WeakMap();
_props106 = new WeakMap();
var NavigationMenuListState = _NavigationMenuListState;
var _contentNode9, _triggerNode7, _focusProxyNode, _contentId4, _triggerId3, _handleContentEntry, _handleContentExit, _props107;
var _NavigationMenuItemState = class _NavigationMenuItemState {
  constructor(opts, listContext) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __publicField(this, "listContext");
    __privateAdd(this, _contentNode9, state(null));
    __privateAdd(this, _triggerNode7, state(null));
    __privateAdd(this, _focusProxyNode, state(null));
    __publicField(this, "restoreContentTabOrder", noop3);
    __publicField(this, "wasEscapeClose", false);
    __privateAdd(this, _contentId4, user_derived(() => {
      var _a;
      return (_a = this.contentNode) == null ? void 0 : _a.id;
    }));
    __privateAdd(this, _triggerId3, user_derived(() => {
      var _a;
      return (_a = this.triggerNode) == null ? void 0 : _a.id;
    }));
    __publicField(this, "contentChildren", simpleBox(void 0));
    __publicField(this, "contentChild", simpleBox(void 0));
    __publicField(this, "contentProps", simpleBox({}));
    __publicField(this, "domContext");
    __privateAdd(this, _handleContentEntry, (side = "start") => {
      if (!this.contentNode) return;
      this.restoreContentTabOrder();
      const candidates = getTabbableCandidates(this.contentNode);
      if (candidates.length) focusFirst2(side === "start" ? candidates : candidates.reverse(), () => this.domContext.getActiveElement());
    });
    __privateAdd(this, _handleContentExit, () => {
      if (!this.contentNode) return;
      const candidates = getTabbableCandidates(this.contentNode);
      if (candidates.length) this.restoreContentTabOrder = removeFromTabOrder(candidates);
    });
    __publicField(this, "onEntryKeydown", __privateGet(this, _handleContentEntry));
    __publicField(this, "onFocusProxyEnter", __privateGet(this, _handleContentEntry));
    __publicField(this, "onRootContentClose", __privateGet(this, _handleContentExit));
    __publicField(this, "onContentFocusOutside", __privateGet(this, _handleContentExit));
    __privateAdd(this, _props107, user_derived(() => ({
      id: this.opts.id.current,
      [navigationMenuAttrs.item]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.listContext = listContext;
    this.domContext = new DOMContext(opts.ref);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return NavigationMenuItemContext.set(new _NavigationMenuItemState(opts, NavigationMenuListContext.get()));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode9));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode9), value, true);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode7));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode7), value, true);
  }
  get focusProxyNode() {
    return get(__privateGet(this, _focusProxyNode));
  }
  set focusProxyNode(value) {
    set(__privateGet(this, _focusProxyNode), value, true);
  }
  get contentId() {
    return get(__privateGet(this, _contentId4));
  }
  set contentId(value) {
    set(__privateGet(this, _contentId4), value);
  }
  get triggerId() {
    return get(__privateGet(this, _triggerId3));
  }
  set triggerId(value) {
    set(__privateGet(this, _triggerId3), value);
  }
  get props() {
    return get(__privateGet(this, _props107));
  }
  set props(value) {
    set(__privateGet(this, _props107), value);
  }
};
_contentNode9 = new WeakMap();
_triggerNode7 = new WeakMap();
_focusProxyNode = new WeakMap();
_contentId4 = new WeakMap();
_triggerId3 = new WeakMap();
_handleContentEntry = new WeakMap();
_handleContentExit = new WeakMap();
_props107 = new WeakMap();
var NavigationMenuItemState = _NavigationMenuItemState;
var _focusProxyMounted, _open3, _props108, _focusProxyProps;
var _NavigationMenuTriggerState = class _NavigationMenuTriggerState {
  constructor(opts, context) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __publicField(this, "focusProxyId", simpleBox(useId()));
    __publicField(this, "focusProxyRef", simpleBox(null));
    __publicField(this, "focusProxyAttachment", attachRef(this.focusProxyRef, (v) => this.itemContext.focusProxyNode = v));
    __publicField(this, "context");
    __publicField(this, "itemContext");
    __publicField(this, "listContext");
    __publicField(this, "hasPointerMoveOpened", simpleBox(false));
    __publicField(this, "wasClickClose", false);
    __privateAdd(this, _focusProxyMounted, state(false));
    __privateAdd(this, _open3, user_derived(() => this.itemContext.opts.value.current === this.context.opts.value.current));
    __publicField(this, "onpointerenter", (_) => {
      this.wasClickClose = false;
      this.itemContext.wasEscapeClose = false;
    });
    __publicField(this, "onpointermove", whenMouse(() => {
      if (this.opts.disabled.current || this.wasClickClose || this.itemContext.wasEscapeClose || this.hasPointerMoveOpened.current || !this.itemContext.opts.openOnHover.current) {
        return;
      }
      this.context.onTriggerEnter(this.itemContext.opts.value.current, this.itemContext);
      this.hasPointerMoveOpened.current = true;
    }));
    __publicField(this, "onpointerleave", whenMouse(() => {
      if (this.opts.disabled.current || !this.itemContext.opts.openOnHover.current) return;
      this.context.onTriggerLeave();
      this.hasPointerMoveOpened.current = false;
    }));
    __publicField(this, "onclick", () => {
      if (this.hasPointerMoveOpened.current) return;
      const shouldClose = this.open && (!this.itemContext.opts.openOnHover.current || this.context.opts.isRootMenu);
      if (shouldClose) {
        this.context.onItemSelect("", null);
      } else if (!this.open) {
        this.context.onItemSelect(this.itemContext.opts.value.current, this.itemContext);
      }
      this.wasClickClose = shouldClose;
    });
    __publicField(this, "onkeydown", (e) => {
      const verticalEntryKey = this.context.opts.dir.current === "rtl" ? kbd_constants_exports.ARROW_LEFT : kbd_constants_exports.ARROW_RIGHT;
      const entryKey = {
        horizontal: kbd_constants_exports.ARROW_DOWN,
        vertical: verticalEntryKey
      }[this.context.opts.orientation.current];
      if (this.open && e.key === entryKey) {
        this.itemContext.onEntryKeydown();
        e.preventDefault();
        return;
      }
      this.itemContext.listContext.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
    });
    __publicField(this, "focusProxyOnFocus", (e) => {
      const content = this.itemContext.contentNode;
      const prevFocusedElement = e.relatedTarget;
      const wasTriggerFocused = this.opts.ref.current && prevFocusedElement === this.opts.ref.current;
      const wasFocusFromContent = content == null ? void 0 : content.contains(prevFocusedElement);
      if (wasTriggerFocused || !wasFocusFromContent) {
        this.itemContext.onFocusProxyEnter(wasTriggerFocused ? "start" : "end");
      }
    });
    __privateAdd(this, _props108, user_derived(() => ({
      id: this.opts.id.current,
      disabled: this.opts.disabled.current,
      "data-disabled": boolToEmptyStrOrUndef(Boolean(this.opts.disabled.current)),
      "data-state": getDataOpenClosed(this.open),
      "data-value": this.itemContext.opts.value.current,
      "aria-expanded": boolToStr(this.open),
      "aria-controls": this.itemContext.contentId,
      [navigationMenuAttrs.trigger]: "",
      onpointermove: this.onpointermove,
      onpointerleave: this.onpointerleave,
      onpointerenter: this.onpointerenter,
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    __privateAdd(this, _focusProxyProps, user_derived(() => ({
      id: this.focusProxyId.current,
      tabindex: 0,
      onfocus: this.focusProxyOnFocus,
      ...this.focusProxyAttachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref, (v) => this.itemContext.triggerNode = v);
    this.hasPointerMoveOpened = boxAutoReset(false, {
      afterMs: 300,
      getWindow: () => getWindow(opts.ref.current)
    });
    this.context = context.provider;
    this.itemContext = context.item;
    this.listContext = context.list;
    watch(() => this.opts.ref.current, () => {
      const node = this.opts.ref.current;
      if (!node) return;
      return this.listContext.registerTrigger(node);
    });
  }
  static create(opts) {
    return new _NavigationMenuTriggerState(opts, {
      provider: NavigationMenuProviderContext.get(),
      item: NavigationMenuItemContext.get(),
      list: NavigationMenuListContext.get(),
      sub: NavigationMenuSubContext.getOr(null)
    });
  }
  get focusProxyMounted() {
    return get(__privateGet(this, _focusProxyMounted));
  }
  set focusProxyMounted(value) {
    set(__privateGet(this, _focusProxyMounted), value, true);
  }
  get open() {
    return get(__privateGet(this, _open3));
  }
  set open(value) {
    set(__privateGet(this, _open3), value);
  }
  get props() {
    return get(__privateGet(this, _props108));
  }
  set props(value) {
    set(__privateGet(this, _props108), value);
  }
  get focusProxyProps() {
    return get(__privateGet(this, _focusProxyProps));
  }
  set focusProxyProps(value) {
    set(__privateGet(this, _focusProxyProps), value);
  }
};
_focusProxyMounted = new WeakMap();
_open3 = new WeakMap();
_props108 = new WeakMap();
_focusProxyProps = new WeakMap();
var NavigationMenuTriggerState = _NavigationMenuTriggerState;
var LINK_SELECT_EVENT = new CustomEventDispatcher("bitsLinkSelect", { bubbles: true, cancelable: true });
var ROOT_CONTENT_DISMISS_EVENT = new CustomEventDispatcher("bitsRootContentDismiss", { cancelable: true, bubbles: true });
var _isFocused4, _handlePointerDismiss, _props109;
var _NavigationMenuLinkState = class _NavigationMenuLinkState {
  constructor(opts, context) {
    __publicField(this, "opts");
    __publicField(this, "context");
    __publicField(this, "attachment");
    __privateAdd(this, _isFocused4, state(false));
    __publicField(this, "onclick", (e) => {
      const currTarget = e.currentTarget;
      LINK_SELECT_EVENT.listen(currTarget, (e2) => this.opts.onSelect.current(e2), { once: true });
      const linkSelectEvent = LINK_SELECT_EVENT.dispatch(currTarget);
      if (!linkSelectEvent.defaultPrevented && !e.metaKey) {
        ROOT_CONTENT_DISMISS_EVENT.dispatch(currTarget);
      }
    });
    __publicField(this, "onkeydown", (e) => {
      if (this.context.item.contentNode) return;
      this.context.item.listContext.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
    });
    __publicField(this, "onfocus", (_) => {
      this.isFocused = true;
    });
    __publicField(this, "onblur", (_) => {
      this.isFocused = false;
    });
    __privateAdd(this, _handlePointerDismiss, () => {
      const currentlyOpenValue = this.context.provider.opts.value.current;
      const isInsideOpenSubmenu = this.context.item.opts.value.current === currentlyOpenValue;
      const activeItem = this.context.item.listContext.context.activeItem;
      if (activeItem && !activeItem.opts.openOnHover.current) return;
      if (currentlyOpenValue && !isInsideOpenSubmenu) {
        this.context.provider.onItemDismiss();
      }
    });
    __publicField(this, "onpointerenter", () => {
      __privateGet(this, _handlePointerDismiss).call(this);
    });
    __publicField(this, "onpointermove", whenMouse(() => {
      __privateGet(this, _handlePointerDismiss).call(this);
    }));
    __privateAdd(this, _props109, user_derived(() => ({
      id: this.opts.id.current,
      "data-active": this.opts.active.current ? "" : void 0,
      "aria-current": this.opts.active.current ? "page" : void 0,
      "data-focused": this.isFocused ? "" : void 0,
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      onfocus: this.onfocus,
      onblur: this.onblur,
      onpointerenter: this.onpointerenter,
      onpointermove: this.onpointermove,
      [navigationMenuAttrs.link]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.context = context;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _NavigationMenuLinkState(opts, {
      provider: NavigationMenuProviderContext.get(),
      item: NavigationMenuItemContext.get()
    });
  }
  get isFocused() {
    return get(__privateGet(this, _isFocused4));
  }
  set isFocused(value) {
    set(__privateGet(this, _isFocused4), value, true);
  }
  get props() {
    return get(__privateGet(this, _props109));
  }
  set props(value) {
    set(__privateGet(this, _props109), value);
  }
};
_isFocused4 = new WeakMap();
_handlePointerDismiss = new WeakMap();
_props109 = new WeakMap();
var NavigationMenuLinkState = _NavigationMenuLinkState;
var _isVisible;
var _NavigationMenuIndicatorState = class _NavigationMenuIndicatorState {
  constructor(context) {
    __publicField(this, "context");
    __privateAdd(this, _isVisible, user_derived(() => Boolean(this.context.opts.value.current)));
    this.context = context;
  }
  static create() {
    return new _NavigationMenuIndicatorState(NavigationMenuProviderContext.get());
  }
  get isVisible() {
    return get(__privateGet(this, _isVisible));
  }
  set isVisible(value) {
    set(__privateGet(this, _isVisible), value);
  }
};
_isVisible = new WeakMap();
var NavigationMenuIndicatorState = _NavigationMenuIndicatorState;
var _position, _isHorizontal, _isVisible2, _activeTrigger, _shouldRender9, _props110;
var _NavigationMenuIndicatorImplState = class _NavigationMenuIndicatorImplState {
  constructor(opts, context) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __publicField(this, "context");
    __publicField(this, "listContext");
    __privateAdd(this, _position, state(null));
    __privateAdd(this, _isHorizontal, user_derived(() => this.context.opts.orientation.current === "horizontal"));
    __privateAdd(this, _isVisible2, user_derived(() => !!this.context.opts.value.current));
    __privateAdd(this, _activeTrigger, user_derived(() => {
      const items = this.listContext.listTriggers;
      const triggerNode = items.find((item) => item.getAttribute("data-value") === this.context.opts.value.current);
      return triggerNode ?? null;
    }));
    __privateAdd(this, _shouldRender9, user_derived(() => this.position !== null));
    __publicField(this, "handlePositionChange", () => {
      if (!this.activeTrigger) return;
      this.position = {
        size: this.isHorizontal ? this.activeTrigger.offsetWidth : this.activeTrigger.offsetHeight,
        offset: this.isHorizontal ? this.activeTrigger.offsetLeft : this.activeTrigger.offsetTop
      };
    });
    __privateAdd(this, _props110, user_derived(() => {
      var _a, _b, _c, _d;
      return {
        id: this.opts.id.current,
        "data-state": this.isVisible ? "visible" : "hidden",
        "data-orientation": this.context.opts.orientation.current,
        style: {
          position: "absolute",
          ...this.isHorizontal ? {
            left: 0,
            width: `${(_a = this.position) == null ? void 0 : _a.size}px`,
            transform: `translateX(${(_b = this.position) == null ? void 0 : _b.offset}px)`
          } : {
            top: 0,
            height: `${(_c = this.position) == null ? void 0 : _c.size}px`,
            transform: `translateY(${(_d = this.position) == null ? void 0 : _d.offset}px)`
          }
        },
        [navigationMenuAttrs.indicator]: "",
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.context = context.provider;
    this.listContext = context.list;
    this.attachment = attachRef(this.opts.ref);
    new SvelteResizeObserver(() => this.activeTrigger, this.handlePositionChange);
    new SvelteResizeObserver(() => this.context.indicatorTrackRef.current, this.handlePositionChange);
  }
  static create(opts) {
    return new _NavigationMenuIndicatorImplState(opts, {
      provider: NavigationMenuProviderContext.get(),
      list: NavigationMenuListContext.get()
    });
  }
  get position() {
    return get(__privateGet(this, _position));
  }
  set position(value) {
    set(__privateGet(this, _position), value);
  }
  get isHorizontal() {
    return get(__privateGet(this, _isHorizontal));
  }
  set isHorizontal(value) {
    set(__privateGet(this, _isHorizontal), value);
  }
  get isVisible() {
    return get(__privateGet(this, _isVisible2));
  }
  set isVisible(value) {
    set(__privateGet(this, _isVisible2), value);
  }
  get activeTrigger() {
    return get(__privateGet(this, _activeTrigger));
  }
  set activeTrigger(value) {
    set(__privateGet(this, _activeTrigger), value);
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender9));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender9), value);
  }
  get props() {
    return get(__privateGet(this, _props110));
  }
  set props(value) {
    set(__privateGet(this, _props110), value);
  }
};
_position = new WeakMap();
_isHorizontal = new WeakMap();
_isVisible2 = new WeakMap();
_activeTrigger = new WeakMap();
_shouldRender9 = new WeakMap();
_props110 = new WeakMap();
var NavigationMenuIndicatorImplState = _NavigationMenuIndicatorImplState;
var _mounted4, _open4, _value2, _isLastActiveValue, _props111;
var _NavigationMenuContentState = class _NavigationMenuContentState {
  constructor(opts, context) {
    __publicField(this, "opts");
    __publicField(this, "context");
    __publicField(this, "itemContext");
    __publicField(this, "listContext");
    __publicField(this, "attachment");
    __privateAdd(this, _mounted4, state(false));
    __privateAdd(this, _open4, user_derived(() => this.itemContext.opts.value.current === this.context.opts.value.current));
    __privateAdd(this, _value2, user_derived(() => this.itemContext.opts.value.current));
    __privateAdd(this, _isLastActiveValue, user_derived(() => {
      if (this.context.viewportRef.current) {
        if (!this.context.opts.value.current && this.context.opts.previousValue.current) {
          return this.context.opts.previousValue.current === this.itemContext.opts.value.current;
        }
      }
      return false;
    }));
    __publicField(this, "onpointerenter", (_) => {
      this.context.onContentEnter();
    });
    __publicField(this, "onpointerleave", whenMouse(() => {
      if (!this.itemContext.opts.openOnHover.current) return;
      this.context.onContentLeave();
    }));
    __privateAdd(this, _props111, user_derived(() => ({
      id: this.opts.id.current,
      onpointerenter: this.onpointerenter,
      onpointerleave: this.onpointerleave,
      ...this.attachment
    })));
    this.opts = opts;
    this.context = context.provider;
    this.itemContext = context.item;
    this.listContext = context.list;
    this.attachment = attachRef(this.opts.ref, (v) => this.itemContext.contentNode = v);
  }
  static create(opts) {
    return NavigationMenuContentContext.set(new _NavigationMenuContentState(opts, {
      provider: NavigationMenuProviderContext.get(),
      item: NavigationMenuItemContext.get(),
      list: NavigationMenuListContext.get()
    }));
  }
  get mounted() {
    return get(__privateGet(this, _mounted4));
  }
  set mounted(value) {
    set(__privateGet(this, _mounted4), value, true);
  }
  get open() {
    return get(__privateGet(this, _open4));
  }
  set open(value) {
    set(__privateGet(this, _open4), value);
  }
  get value() {
    return get(__privateGet(this, _value2));
  }
  set value(value) {
    set(__privateGet(this, _value2), value);
  }
  get isLastActiveValue() {
    return get(__privateGet(this, _isLastActiveValue));
  }
  set isLastActiveValue(value) {
    set(__privateGet(this, _isLastActiveValue), value);
  }
  get props() {
    return get(__privateGet(this, _props111));
  }
  set props(value) {
    set(__privateGet(this, _props111), value);
  }
};
_mounted4 = new WeakMap();
_open4 = new WeakMap();
_value2 = new WeakMap();
_isLastActiveValue = new WeakMap();
_props111 = new WeakMap();
var NavigationMenuContentState = _NavigationMenuContentState;
var _prevMotionAttribute, _motionAttribute, _props112;
var _NavigationMenuContentImplState = class _NavigationMenuContentImplState {
  constructor(opts, itemContext) {
    __publicField(this, "opts");
    __publicField(this, "itemContext");
    __publicField(this, "context");
    __publicField(this, "listContext");
    __publicField(this, "attachment");
    __privateAdd(this, _prevMotionAttribute, state(null));
    __privateAdd(this, _motionAttribute, user_derived(() => {
      const items = this.listContext.listTriggers;
      const values = items.map((item) => item.getAttribute("data-value")).filter(Boolean);
      if (this.context.opts.dir.current === "rtl") values.reverse();
      const index = values.indexOf(this.context.opts.value.current);
      const prevIndex = values.indexOf(this.context.opts.previousValue.current);
      const isSelected = this.itemContext.opts.value.current === this.context.opts.value.current;
      const wasSelected = prevIndex === values.indexOf(this.itemContext.opts.value.current);
      if (!this.context.opts.value.current && !this.context.opts.previousValue.current) {
        untrack(() => this.prevMotionAttribute = null);
        return null;
      }
      if (!isSelected && !wasSelected) return untrack(() => this.prevMotionAttribute);
      const attribute = (() => {
        if (index !== prevIndex) {
          if (isSelected && prevIndex !== -1) return index > prevIndex ? "from-end" : "from-start";
          if (wasSelected && index !== -1) return index > prevIndex ? "to-start" : "to-end";
        }
        return null;
      })();
      untrack(() => this.prevMotionAttribute = attribute);
      return attribute;
    }));
    __publicField(this, "domContext");
    __publicField(this, "onFocusOutside", (e) => {
      var _a;
      this.itemContext.onContentFocusOutside();
      const target = e.target;
      if ((_a = this.context.opts.rootNavigationMenuRef.current) == null ? void 0 : _a.contains(target)) {
        e.preventDefault();
        return;
      }
      this.context.onItemDismiss();
    });
    __publicField(this, "onInteractOutside", (e) => {
      var _a;
      const target = e.target;
      const isTrigger = this.listContext.listTriggers.some((trigger) => trigger.contains(target));
      const isRootViewport = this.context.opts.isRootMenu && ((_a = this.context.viewportRef.current) == null ? void 0 : _a.contains(target));
      if (!this.context.opts.isRootMenu && !isTrigger) {
        this.context.onItemDismiss();
        return;
      }
      if (isTrigger || isRootViewport) {
        e.preventDefault();
        return;
      }
      if (!this.itemContext.opts.openOnHover.current) {
        this.context.onItemSelect("", null);
      }
    });
    __publicField(this, "onkeydown", (e) => {
      const target = e.target;
      if (!isElement2(target)) return;
      if (target.closest(navigationMenuAttrs.selector("menu")) !== this.context.opts.rootNavigationMenuRef.current) return;
      const isMetaKey = e.altKey || e.ctrlKey || e.metaKey;
      const isTabKey = e.key === kbd_constants_exports.TAB && !isMetaKey;
      const candidates = getTabbableCandidates(e.currentTarget);
      if (isTabKey) {
        const focusedElement = this.domContext.getActiveElement();
        const index = candidates.findIndex((candidate) => candidate === focusedElement);
        const isMovingBackwards = e.shiftKey;
        const nextCandidates = isMovingBackwards ? candidates.slice(0, index).reverse() : candidates.slice(index + 1, candidates.length);
        if (focusFirst2(nextCandidates, () => this.domContext.getActiveElement())) {
          e.preventDefault();
          return;
        } else {
          handleProxyFocus(this.itemContext.focusProxyNode);
          return;
        }
      }
      let activeEl = this.domContext.getActiveElement();
      if (this.itemContext.contentNode) {
        const focusedNode = this.itemContext.contentNode.querySelector("[data-focused]");
        if (focusedNode) {
          activeEl = focusedNode;
        }
      }
      if (activeEl === this.itemContext.triggerNode) return;
      const newSelectedElement = useArrowNavigation(e, activeEl, void 0, {
        itemsArray: candidates,
        candidateSelector: navigationMenuAttrs.selector("link"),
        loop: false,
        enableIgnoredElement: true
      });
      newSelectedElement == null ? void 0 : newSelectedElement.focus();
    });
    __publicField(this, "onEscapeKeydown", (_) => {
      var _a;
      this.context.onItemDismiss();
      (_a = this.itemContext.triggerNode) == null ? void 0 : _a.focus();
      this.itemContext.wasEscapeClose = true;
    });
    __privateAdd(this, _props112, user_derived(() => ({
      id: this.opts.id.current,
      "aria-labelledby": this.itemContext.triggerId,
      "data-motion": this.motionAttribute ?? void 0,
      "data-orientation": this.context.opts.orientation.current,
      "data-state": getDataOpenClosed(this.context.opts.value.current === this.itemContext.opts.value.current),
      onkeydown: this.onkeydown,
      [navigationMenuAttrs.content]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.itemContext = itemContext;
    this.listContext = itemContext.listContext;
    this.context = itemContext.listContext.context;
    this.domContext = new DOMContext(opts.ref);
    watch(
      [
        () => this.itemContext.opts.value.current,
        () => this.itemContext.triggerNode,
        () => this.opts.ref.current
      ],
      () => {
        const content = this.opts.ref.current;
        if (!(content && this.context.opts.isRootMenu)) return;
        const handleClose = () => {
          var _a;
          this.context.onItemDismiss();
          this.itemContext.onRootContentClose();
          if (content.contains(this.domContext.getActiveElement())) {
            (_a = this.itemContext.triggerNode) == null ? void 0 : _a.focus();
          }
        };
        const removeListener = ROOT_CONTENT_DISMISS_EVENT.listen(content, handleClose);
        return () => {
          removeListener();
        };
      }
    );
  }
  static create(opts, itemState) {
    return new _NavigationMenuContentImplState(opts, itemState ?? NavigationMenuItemContext.get());
  }
  get prevMotionAttribute() {
    return get(__privateGet(this, _prevMotionAttribute));
  }
  set prevMotionAttribute(value) {
    set(__privateGet(this, _prevMotionAttribute), value, true);
  }
  get motionAttribute() {
    return get(__privateGet(this, _motionAttribute));
  }
  set motionAttribute(value) {
    set(__privateGet(this, _motionAttribute), value);
  }
  get props() {
    return get(__privateGet(this, _props112));
  }
  set props(value) {
    set(__privateGet(this, _props112), value);
  }
};
_prevMotionAttribute = new WeakMap();
_motionAttribute = new WeakMap();
_props112 = new WeakMap();
var NavigationMenuContentImplState = _NavigationMenuContentImplState;
var _open5, _viewportWidth, _viewportHeight, _activeContentValue, _size2, _contentNode10, _mounted5, _props113;
var _NavigationMenuViewportState = class _NavigationMenuViewportState {
  constructor(opts, context) {
    __publicField(this, "opts");
    __publicField(this, "context");
    __publicField(this, "attachment");
    __privateAdd(this, _open5, user_derived(() => !!this.context.opts.value.current));
    __privateAdd(this, _viewportWidth, user_derived(() => this.size ? `${this.size.width}px` : void 0));
    __privateAdd(this, _viewportHeight, user_derived(() => this.size ? `${this.size.height}px` : void 0));
    __privateAdd(this, _activeContentValue, user_derived(() => this.context.opts.value.current));
    __privateAdd(this, _size2, state(null));
    __privateAdd(this, _contentNode10, state(null));
    __privateAdd(this, _mounted5, state(false));
    __privateAdd(this, _props113, user_derived(() => ({
      id: this.opts.id.current,
      "data-state": getDataOpenClosed(this.open),
      "data-orientation": this.context.opts.orientation.current,
      style: {
        pointerEvents: !this.open && this.context.opts.isRootMenu ? "none" : void 0,
        "--bits-navigation-menu-viewport-width": this.viewportWidth,
        "--bits-navigation-menu-viewport-height": this.viewportHeight
      },
      [navigationMenuAttrs.viewport]: "",
      onpointerenter: this.context.onContentEnter,
      onpointerleave: this.context.onContentLeave,
      ...this.attachment
    })));
    this.opts = opts;
    this.context = context;
    this.attachment = attachRef(this.opts.ref, (v) => this.context.viewportRef.current = v);
    watch(
      [
        () => this.activeContentValue,
        () => this.open
      ],
      () => {
        afterTick(() => {
          var _a, _b;
          const currNode = this.context.viewportRef.current;
          if (!currNode) return;
          const el = ((_b = (_a = currNode.querySelector("[data-state=open]")) == null ? void 0 : _a.children) == null ? void 0 : _b[0]) ?? null;
          this.contentNode = el;
        });
      }
    );
    new SvelteResizeObserver(() => this.contentNode, () => {
      if (this.contentNode) {
        this.size = {
          width: this.contentNode.offsetWidth,
          height: this.contentNode.offsetHeight
        };
      }
    });
    watch(() => this.mounted, () => {
      if (!this.mounted && this.size) {
        this.size = null;
      }
    });
  }
  static create(opts) {
    return new _NavigationMenuViewportState(opts, NavigationMenuProviderContext.get());
  }
  get open() {
    return get(__privateGet(this, _open5));
  }
  set open(value) {
    set(__privateGet(this, _open5), value);
  }
  get viewportWidth() {
    return get(__privateGet(this, _viewportWidth));
  }
  set viewportWidth(value) {
    set(__privateGet(this, _viewportWidth), value);
  }
  get viewportHeight() {
    return get(__privateGet(this, _viewportHeight));
  }
  set viewportHeight(value) {
    set(__privateGet(this, _viewportHeight), value);
  }
  get activeContentValue() {
    return get(__privateGet(this, _activeContentValue));
  }
  set activeContentValue(value) {
    set(__privateGet(this, _activeContentValue), value);
  }
  get size() {
    return get(__privateGet(this, _size2));
  }
  set size(value) {
    set(__privateGet(this, _size2), value, true);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode10));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode10), value, true);
  }
  get mounted() {
    return get(__privateGet(this, _mounted5));
  }
  set mounted(value) {
    set(__privateGet(this, _mounted5), value, true);
  }
  get props() {
    return get(__privateGet(this, _props113));
  }
  set props(value) {
    set(__privateGet(this, _props113), value);
  }
};
_open5 = new WeakMap();
_viewportWidth = new WeakMap();
_viewportHeight = new WeakMap();
_activeContentValue = new WeakMap();
_size2 = new WeakMap();
_contentNode10 = new WeakMap();
_mounted5 = new WeakMap();
_props113 = new WeakMap();
var NavigationMenuViewportState = _NavigationMenuViewportState;
function focusFirst2(candidates, getActiveElement3) {
  const previouslyFocusedElement = getActiveElement3();
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return getActiveElement3() !== previouslyFocusedElement;
  });
}
function removeFromTabOrder(candidates) {
  candidates.forEach((candidate) => {
    candidate.dataset.tabindex = candidate.getAttribute("tabindex") || "";
    candidate.setAttribute("tabindex", "-1");
  });
  return () => {
    candidates.forEach((candidate) => {
      const prevTabIndex = candidate.dataset.tabindex;
      candidate.setAttribute("tabindex", prevTabIndex);
    });
  };
}
function whenMouse(handler) {
  return (e) => e.pointerType === "mouse" ? handler(e) : void 0;
}
function handleProxyFocus(guard, focusOptions) {
  if (!guard) return;
  const ariaHidden = guard.getAttribute("aria-hidden");
  guard.removeAttribute("aria-hidden");
  guard.focus(focusOptions);
  afterSleep(0, () => {
    if (ariaHidden === null) {
      guard.setAttribute("aria-hidden", "");
    } else {
      guard.setAttribute("aria-hidden", ariaHidden);
    }
  });
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu.svelte
var root_274 = from_html(`<nav><!></nav>`);
function Navigation_menu($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), delayDuration = prop($$props, "delayDuration", 3, 200), skipDelayDuration = prop($$props, "skipDelayDuration", 3, 300), dir = prop($$props, "dir", 3, "ltr"), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "id",
    "ref",
    "value",
    "onValueChange",
    "delayDuration",
    "skipDelayDuration",
    "dir",
    "orientation"
  ]);
  const rootState = NavigationMenuRootState.create({
    id: boxWith(() => id()),
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    delayDuration: boxWith(() => delayDuration()),
    skipDelayDuration: boxWith(() => skipDelayDuration()),
    dir: boxWith(() => dir()),
    orientation: boxWith(() => orientation()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps({ "aria-label": "main" }, restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var nav = root_274();
      attribute_effect(nav, () => ({ ...get(mergedProps) }));
      var node_2 = child(nav);
      snippet(node_2, () => $$props.children ?? noop);
      reset(nav);
      append($$anchor2, nav);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-content-impl.svelte
var root_419 = from_html(`<div><!></div>`);
function Navigation_menu_content_impl($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "close"), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "child",
    "children",
    "onInteractOutside",
    "onFocusOutside",
    "onEscapeKeydown",
    "escapeKeydownBehavior",
    "interactOutsideBehavior",
    "itemState",
    "onRefChange"
  ]);
  const contentImplState = NavigationMenuContentImplState.create(
    {
      id: boxWith(() => id()),
      ref: boxWith(() => ref(), (v) => {
        ref(v);
        untrack(() => {
          var _a;
          return (_a = $$props.onRefChange) == null ? void 0 : _a.call($$props, v);
        });
      })
    },
    $$props.itemState
  );
  if ($$props.itemState) {
    NavigationMenuItemContext.set($$props.itemState);
  }
  const mergedProps = user_derived(() => mergeProps(restProps, contentImplState.props));
  {
    const children = ($$anchor2, $$arg0) => {
      let dismissibleProps = () => $$arg0 == null ? void 0 : $$arg0().props;
      Escape_layer($$anchor2, {
        enabled: true,
        get ref() {
          return contentImplState.opts.ref;
        },
        onEscapeKeydown: (e) => {
          onEscapeKeydown()(e);
          if (e.defaultPrevented) return;
          contentImplState.onEscapeKeydown(e);
        },
        get escapeKeydownBehavior() {
          return escapeKeydownBehavior();
        },
        children: ($$anchor3, $$slotProps) => {
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(get(mergedProps), dismissibleProps()));
          var node = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_1 = first_child(fragment_3);
              snippet(node_1, () => $$props.child, () => ({ props: get(finalProps) }));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_419();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_2 = child(div);
              snippet(node_2, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        },
        $$slots: { default: true }
      });
    };
    Dismissible_layer($$anchor, {
      get id() {
        return id();
      },
      get ref() {
        return contentImplState.opts.ref;
      },
      enabled: true,
      onInteractOutside: (e) => {
        onInteractOutside()(e);
        if (e.defaultPrevented) return;
        contentImplState.onInteractOutside(e);
      },
      onFocusOutside: (e) => {
        onFocusOutside()(e);
        if (e.defaultPrevented) return;
        contentImplState.onFocusOutside(e);
      },
      get interactOutsideBehavior() {
        return interactOutsideBehavior();
      },
      children,
      $$slots: { default: true }
    });
  }
  pop();
}

// node_modules/bits-ui/dist/internal/state-machine.js
var _machine, _StateMachine_instances, reducer_fn;
var StateMachine = class {
  constructor(initialState, machine) {
    __privateAdd(this, _StateMachine_instances);
    __publicField(this, "state");
    __privateAdd(this, _machine);
    this.state = simpleBox(initialState);
    __privateSet(this, _machine, machine);
    this.dispatch = this.dispatch.bind(this);
  }
  dispatch(event) {
    this.state.current = __privateMethod(this, _StateMachine_instances, reducer_fn).call(this, event);
  }
};
_machine = new WeakMap();
_StateMachine_instances = new WeakSet();
reducer_fn = function(event) {
  const nextState = __privateGet(this, _machine)[this.state.current][event];
  return nextState ?? this.state.current;
};

// node_modules/bits-ui/dist/bits/utilities/presence-layer/presence.svelte.js
var presenceMachine = {
  mounted: {
    UNMOUNT: "unmounted",
    ANIMATION_OUT: "unmountSuspended"
  },
  unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
  unmounted: { MOUNT: "mounted" }
};
var _prevAnimationNameState, _styles2, _isPresent;
var Presence = class {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _prevAnimationNameState, state("none"));
    __privateAdd(this, _styles2, state(proxy({})));
    __publicField(this, "initialStatus");
    __publicField(this, "previousPresent");
    __publicField(this, "machine");
    __publicField(this, "present");
    __privateAdd(this, _isPresent, user_derived(() => {
      return ["mounted", "unmountSuspended"].includes(this.machine.state.current);
    }));
    this.opts = opts;
    this.present = this.opts.open;
    this.initialStatus = opts.open.current ? "mounted" : "unmounted";
    this.previousPresent = new Previous(() => this.present.current);
    this.machine = new StateMachine(this.initialStatus, presenceMachine);
    this.handleAnimationEnd = this.handleAnimationEnd.bind(this);
    this.handleAnimationStart = this.handleAnimationStart.bind(this);
    watchPresenceChange(this);
    watchStatusChange(this);
    watchRefChange(this);
  }
  get prevAnimationNameState() {
    return get(__privateGet(this, _prevAnimationNameState));
  }
  set prevAnimationNameState(value) {
    set(__privateGet(this, _prevAnimationNameState), value, true);
  }
  get styles() {
    return get(__privateGet(this, _styles2));
  }
  set styles(value) {
    set(__privateGet(this, _styles2), value, true);
  }
  /**
   * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`
   * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we
   * make sure we only trigger ANIMATION_END for the currently active animation.
   */
  handleAnimationEnd(event) {
    if (!this.opts.ref.current) return;
    const currAnimationName = getAnimationName(this.opts.ref.current);
    const isCurrentAnimation = currAnimationName.includes(event.animationName) || currAnimationName === "none";
    if (event.target === this.opts.ref.current && isCurrentAnimation) {
      this.machine.dispatch("ANIMATION_END");
    }
  }
  handleAnimationStart(event) {
    if (!this.opts.ref.current) return;
    if (event.target === this.opts.ref.current) {
      this.prevAnimationNameState = getAnimationName(this.opts.ref.current);
    }
  }
  get isPresent() {
    return get(__privateGet(this, _isPresent));
  }
  set isPresent(value) {
    set(__privateGet(this, _isPresent), value);
  }
};
_prevAnimationNameState = new WeakMap();
_styles2 = new WeakMap();
_isPresent = new WeakMap();
function watchPresenceChange(state2) {
  watch(() => state2.present.current, () => {
    if (!state2.opts.ref.current) return;
    const hasPresentChanged = state2.present.current !== state2.previousPresent.current;
    if (!hasPresentChanged) return;
    const prevAnimationName = state2.prevAnimationNameState;
    const currAnimationName = getAnimationName(state2.opts.ref.current);
    if (state2.present.current) {
      state2.machine.dispatch("MOUNT");
    } else if (currAnimationName === "none" || state2.styles.display === "none") {
      state2.machine.dispatch("UNMOUNT");
    } else {
      const isAnimating = prevAnimationName !== currAnimationName;
      if (state2.previousPresent.current && isAnimating) {
        state2.machine.dispatch("ANIMATION_OUT");
      } else {
        state2.machine.dispatch("UNMOUNT");
      }
    }
  });
}
function watchStatusChange(state2) {
  watch(() => state2.machine.state.current, () => {
    if (!state2.opts.ref.current) return;
    const currAnimationName = getAnimationName(state2.opts.ref.current);
    state2.prevAnimationNameState = state2.machine.state.current === "mounted" ? currAnimationName : "none";
  });
}
function watchRefChange(state2) {
  watch(() => state2.opts.ref.current, () => {
    if (!state2.opts.ref.current) return;
    state2.styles = getComputedStyle(state2.opts.ref.current);
    return executeCallbacks(on(state2.opts.ref.current, "animationstart", state2.handleAnimationStart), on(state2.opts.ref.current, "animationcancel", state2.handleAnimationEnd), on(state2.opts.ref.current, "animationend", state2.handleAnimationEnd));
  });
}
function getAnimationName(node) {
  return node ? getComputedStyle(node).animationName || "none" : "none";
}

// node_modules/bits-ui/dist/bits/utilities/presence-layer/presence-layer.svelte
function Presence_layer($$anchor, $$props) {
  push($$props, true);
  const presenceState = new Presence({
    open: boxWith(() => $$props.open),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.presence ?? noop, () => ({ present: presenceState.isPresent }));
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if ($$props.forceMount || $$props.open || presenceState.isPresent) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-content.svelte
var root_275 = from_html(`<!> <!>`, 1);
function Navigation_menu_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "children",
    "child",
    "forceMount"
  ]);
  const contentState = NavigationMenuContentState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  const expression = user_derived(() => contentState.context.viewportRef.current || void 0);
  const expression_1 = user_derived(() => !contentState.context.viewportRef.current);
  Portal($$anchor, {
    get to() {
      return get(expression);
    },
    get disabled() {
      return get(expression_1);
    },
    children: ($$anchor2, $$slotProps) => {
      const expression_2 = user_derived(() => forceMount() || contentState.open || contentState.isLastActiveValue);
      {
        const presence = ($$anchor3) => {
          var fragment_2 = root_275();
          var node = first_child(fragment_2);
          Navigation_menu_content_impl(node, spread_props(() => get(mergedProps), {
            get children() {
              return $$props.children;
            },
            get child() {
              return $$props.child;
            }
          }));
          var node_1 = sibling(node, 2);
          Mounted(node_1, {
            get mounted() {
              return contentState.mounted;
            },
            set mounted($$value) {
              contentState.mounted = $$value;
            }
          });
          append($$anchor3, fragment_2);
        };
        Presence_layer($$anchor2, {
          get open() {
            return get(expression_2);
          },
          get ref() {
            return contentState.opts.ref;
          },
          presence,
          $$slots: { presence: true }
        });
      }
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-indicator-impl.svelte
var root_276 = from_html(`<div><!></div>`);
function Navigation_menu_indicator_impl($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const indicatorState = NavigationMenuIndicatorImplState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, indicatorState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_276();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-indicator.svelte
function Navigation_menu_indicator($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child",
    "forceMount"
  ]);
  const indicatorState = NavigationMenuIndicatorState.create();
  const mergedProps = user_derived(() => mergeProps(restProps));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Portal($$anchor2, {
        get to() {
          return indicatorState.context.indicatorTrackRef.current;
        },
        children: ($$anchor3, $$slotProps) => {
          const expression = user_derived(() => forceMount() || indicatorState.isVisible);
          const expression_1 = user_derived(() => boxWith(() => ref()));
          {
            const presence = ($$anchor4) => {
              Navigation_menu_indicator_impl($$anchor4, spread_props(() => get(mergedProps), {
                get children() {
                  return $$props.children;
                },
                get child() {
                  return $$props.child;
                },
                get id() {
                  return id();
                },
                get ref() {
                  return ref();
                },
                set ref($$value) {
                  ref($$value);
                }
              }));
            };
            Presence_layer($$anchor3, {
              get open() {
                return get(expression);
              },
              get ref() {
                return get(expression_1);
              },
              presence,
              $$slots: { presence: true }
            });
          }
        },
        $$slots: { default: true }
      });
    };
    if_block(node, ($$render) => {
      if (indicatorState.context.indicatorTrackRef.current) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-item.svelte
var root_277 = from_html(`<li><!></li>`);
function Navigation_menu_item($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  const defaultId = createId(uid);
  let id = prop($$props, "id", 3, defaultId), value = prop($$props, "value", 3, defaultId), ref = prop($$props, "ref", 15, null), openOnHover = prop($$props, "openOnHover", 3, true), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "value",
    "ref",
    "child",
    "children",
    "openOnHover"
  ]);
  const itemState = NavigationMenuItemState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    value: boxWith(() => value()),
    openOnHover: boxWith(() => openOnHover())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var li = root_277();
      attribute_effect(li, () => ({ ...get(mergedProps) }));
      var node_2 = child(li);
      snippet(node_2, () => $$props.children ?? noop);
      reset(li);
      append($$anchor2, li);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-link.svelte
var root_278 = from_html(`<a><!></a>`);
function Navigation_menu_link($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), active = prop($$props, "active", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "child",
    "children",
    "active",
    "onSelect",
    "tabindex"
  ]);
  const linkState = NavigationMenuLinkState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    active: boxWith(() => active()),
    onSelect: boxWith(() => onSelect())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, linkState.props, { tabindex: tabindex() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var a2 = root_278();
      attribute_effect(a2, () => ({ ...get(mergedProps) }));
      var node_2 = child(a2);
      snippet(node_2, () => $$props.children ?? noop);
      reset(a2);
      append($$anchor2, a2);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-list.svelte
var root_17 = from_html(`<!> <!>`, 1);
var root_279 = from_html(`<div><ul><!></ul></div> <!>`, 1);
function Navigation_menu_list($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "children",
    "child",
    "ref"
  ]);
  const listState = NavigationMenuListState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, listState.props));
  const wrapperProps = user_derived(() => mergeProps(listState.wrapperProps));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = root_17();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        wrapperProps: get(wrapperProps)
      }));
      var node_2 = sibling(node_1, 2);
      Mounted(node_2, {
        get mounted() {
          return listState.wrapperMounted;
        },
        set mounted($$value) {
          listState.wrapperMounted = $$value;
        }
      });
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = root_279();
      var div = first_child(fragment_2);
      attribute_effect(div, () => ({ ...get(wrapperProps) }));
      var ul = child(div);
      attribute_effect(ul, () => ({ ...get(mergedProps) }));
      var node_3 = child(ul);
      snippet(node_3, () => $$props.children ?? noop);
      reset(ul);
      reset(div);
      var node_4 = sibling(div, 2);
      Mounted(node_4, {
        get mounted() {
          return listState.wrapperMounted;
        },
        set mounted($$value) {
          listState.wrapperMounted = $$value;
        }
      });
      append($$anchor2, fragment_2);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/visually-hidden/visually-hidden.svelte
var root_280 = from_html(`<span><!></span>`);
function Visually_hidden($$anchor, $$props) {
  push($$props, true);
  let restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child"
  ]);
  const style = {
    position: "absolute",
    border: 0,
    width: "1px",
    display: "inline-block",
    height: "1px",
    padding: 0,
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0 0 0 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  };
  const mergedProps = user_derived(() => mergeProps(restProps, { style }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_280();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-trigger.svelte
var root_281 = from_html(`<button><!></button>`);
var root_420 = from_html(`<span></span>`);
var root_316 = from_html(`<!> <!> <!>`, 1);
var root9 = from_html(`<!> <!>`, 1);
function Navigation_menu_trigger($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "disabled",
    "children",
    "child",
    "ref",
    "tabindex"
  ]);
  const triggerState = NavigationMenuTriggerState.create({
    id: boxWith(() => id()),
    disabled: boxWith(() => disabled() ?? false),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props, { tabindex: tabindex() }));
  var fragment = root9();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_281();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  {
    var consequent_2 = ($$anchor2) => {
      var fragment_2 = root_316();
      var node_4 = first_child(fragment_2);
      Visually_hidden(node_4, spread_props(() => triggerState.focusProxyProps));
      var node_5 = sibling(node_4, 2);
      Mounted(node_5, {
        get mounted() {
          return triggerState.focusProxyMounted;
        },
        set mounted($$value) {
          triggerState.focusProxyMounted = $$value;
        }
      });
      var node_6 = sibling(node_5, 2);
      {
        var consequent_1 = ($$anchor3) => {
          var span = root_420();
          template_effect(() => set_attribute(span, "aria-owns", triggerState.itemContext.contentId ?? void 0));
          append($$anchor3, span);
        };
        if_block(node_6, ($$render) => {
          if (triggerState.context.viewportRef.current) $$render(consequent_1);
        });
      }
      append($$anchor2, fragment_2);
    };
    if_block(node_3, ($$render) => {
      if (triggerState.open) $$render(consequent_2);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-viewport.svelte
var root_317 = from_html(`<div><!></div>`);
var root_18 = from_html(`<!> <!>`, 1);
function Navigation_menu_viewport($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "forceMount",
    "child",
    "children"
  ]);
  const viewportState = NavigationMenuViewportState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, viewportState.props));
  const expression = user_derived(() => forceMount() || viewportState.open);
  {
    const presence = ($$anchor2) => {
      var fragment_1 = root_18();
      var node = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_1 = first_child(fragment_2);
          snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_317();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_2 = child(div);
          snippet(node_2, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      var node_3 = sibling(node, 2);
      Mounted(node_3, {
        get mounted() {
          return viewportState.mounted;
        },
        set mounted($$value) {
          viewportState.mounted = $$value;
        }
      });
      append($$anchor2, fragment_1);
    };
    Presence_layer($$anchor, {
      get open() {
        return get(expression);
      },
      get ref() {
        return viewportState.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  pop();
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-sub.svelte
var root_282 = from_html(`<div><!></div>`);
function Navigation_menu_sub($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "id",
    "ref",
    "value",
    "onValueChange",
    "orientation"
  ]);
  const rootState = NavigationMenuSubState.create({
    id: boxWith(() => id()),
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    orientation: boxWith(() => orientation()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_282();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/pagination/exports.js
var exports_exports23 = {};
__export(exports_exports23, {
  NextButton: () => Pagination_next_button,
  Page: () => Pagination_page,
  PrevButton: () => Pagination_prev_button,
  Root: () => Pagination
});

// node_modules/bits-ui/dist/bits/pagination/pagination.svelte.js
var paginationAttrs = createBitsAttrs({
  component: "pagination",
  parts: ["root", "page", "prev", "next"]
});
var PaginationRootContext = new Context("Pagination.Root");
var _totalPages, _range, _pages, _hasPrevPage, _hasNextPage, _snippetProps22, _props114;
var _PaginationRootState = class _PaginationRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _totalPages, user_derived(() => {
      if (this.opts.count.current === 0) return 1;
      return Math.ceil(this.opts.count.current / this.opts.perPage.current);
    }));
    __privateAdd(this, _range, user_derived(() => {
      const start = (this.opts.page.current - 1) * this.opts.perPage.current;
      const end = Math.min(start + this.opts.perPage.current, this.opts.count.current);
      return { start: start + 1, end };
    }));
    __privateAdd(this, _pages, user_derived(() => getPageItems({
      page: this.opts.page.current,
      totalPages: this.totalPages,
      siblingCount: this.opts.siblingCount.current
    })));
    __privateAdd(this, _hasPrevPage, user_derived(() => this.opts.page.current > 1));
    __privateAdd(this, _hasNextPage, user_derived(() => this.opts.page.current < this.totalPages));
    __privateAdd(this, _snippetProps22, user_derived(() => ({
      pages: this.pages,
      range: this.range,
      currentPage: this.opts.page.current
    })));
    __privateAdd(this, _props114, user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": this.opts.orientation.current,
      [paginationAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return PaginationRootContext.set(new _PaginationRootState(opts));
  }
  get totalPages() {
    return get(__privateGet(this, _totalPages));
  }
  set totalPages(value) {
    set(__privateGet(this, _totalPages), value);
  }
  get range() {
    return get(__privateGet(this, _range));
  }
  set range(value) {
    set(__privateGet(this, _range), value);
  }
  get pages() {
    return get(__privateGet(this, _pages));
  }
  set pages(value) {
    set(__privateGet(this, _pages), value);
  }
  get hasPrevPage() {
    return get(__privateGet(this, _hasPrevPage));
  }
  set hasPrevPage(value) {
    set(__privateGet(this, _hasPrevPage), value);
  }
  get hasNextPage() {
    return get(__privateGet(this, _hasNextPage));
  }
  set hasNextPage(value) {
    set(__privateGet(this, _hasNextPage), value);
  }
  setPage(page) {
    this.opts.page.current = page;
  }
  getPageTriggerNodes() {
    const node = this.opts.ref.current;
    if (!node) return [];
    return Array.from(node.querySelectorAll("[data-pagination-page]"));
  }
  getButtonNode(type) {
    const node = this.opts.ref.current;
    if (!node) return;
    return node.querySelector(paginationAttrs.selector(type));
  }
  prevPage() {
    this.opts.page.current = Math.max(this.opts.page.current - 1, 1);
  }
  nextPage() {
    this.opts.page.current = Math.min(this.opts.page.current + 1, this.totalPages);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps22));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps22), value);
  }
  get props() {
    return get(__privateGet(this, _props114));
  }
  set props(value) {
    set(__privateGet(this, _props114), value);
  }
};
_totalPages = new WeakMap();
_range = new WeakMap();
_pages = new WeakMap();
_hasPrevPage = new WeakMap();
_hasNextPage = new WeakMap();
_snippetProps22 = new WeakMap();
_props114 = new WeakMap();
var PaginationRootState = _PaginationRootState;
var _isSelected3, _props115;
var _PaginationPageState = class _PaginationPageState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isSelected3, user_derived(() => this.opts.page.current.value === this.root.opts.page.current));
    __privateAdd(this, _props115, user_derived(() => ({
      id: this.opts.id.current,
      "aria-label": `Page ${this.opts.page.current.value}`,
      "data-value": `${this.opts.page.current.value}`,
      "data-selected": get(__privateGet(this, _isSelected3)) ? "" : void 0,
      [paginationAttrs.page]: "",
      //
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _PaginationPageState(opts, PaginationRootContext.get());
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (e.button !== 0) return;
    this.root.setPage(this.opts.page.current.value);
  }
  onkeydown(e) {
    if (e.key === kbd_constants_exports.SPACE || e.key === kbd_constants_exports.ENTER) {
      e.preventDefault();
      this.root.setPage(this.opts.page.current.value);
    } else {
      handleTriggerKeydown(e, this.opts.ref.current, this.root);
    }
  }
  get props() {
    return get(__privateGet(this, _props115));
  }
  set props(value) {
    set(__privateGet(this, _props115), value);
  }
};
_isSelected3 = new WeakMap();
_props115 = new WeakMap();
var PaginationPageState = _PaginationPageState;
var _PaginationButtonState_instances, action_fn, _isDisabled10, _props116;
var _PaginationButtonState = class _PaginationButtonState {
  constructor(opts, root18) {
    __privateAdd(this, _PaginationButtonState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled10, user_derived(() => {
      if (this.opts.disabled.current) return true;
      if (this.opts.type === "prev") return !this.root.hasPrevPage;
      if (this.opts.type === "next") return !this.root.hasNextPage;
      return false;
    }));
    __privateAdd(this, _props116, user_derived(() => ({
      id: this.opts.id.current,
      [paginationAttrs[this.opts.type]]: "",
      disabled: get(__privateGet(this, _isDisabled10)),
      //
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _PaginationButtonState(opts, PaginationRootContext.get());
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (e.button !== 0) return;
    __privateMethod(this, _PaginationButtonState_instances, action_fn).call(this);
  }
  onkeydown(e) {
    if (e.key === kbd_constants_exports.SPACE || e.key === kbd_constants_exports.ENTER) {
      e.preventDefault();
      __privateMethod(this, _PaginationButtonState_instances, action_fn).call(this);
    } else {
      handleTriggerKeydown(e, this.opts.ref.current, this.root);
    }
  }
  get props() {
    return get(__privateGet(this, _props116));
  }
  set props(value) {
    set(__privateGet(this, _props116), value);
  }
};
_PaginationButtonState_instances = new WeakSet();
action_fn = function() {
  this.opts.type === "prev" ? this.root.prevPage() : this.root.nextPage();
};
_isDisabled10 = new WeakMap();
_props116 = new WeakMap();
var PaginationButtonState = _PaginationButtonState;
function handleTriggerKeydown(e, node, root18) {
  if (!node || !root18.opts.ref.current) return;
  const items = root18.getPageTriggerNodes();
  const nextButton = root18.getButtonNode("next");
  const prevButton = root18.getButtonNode("prev");
  if (prevButton) {
    items.unshift(prevButton);
  }
  if (nextButton) {
    items.push(nextButton);
  }
  const currentIndex = items.indexOf(node);
  const dir = getElemDirection(root18.opts.ref.current);
  const { nextKey, prevKey } = getDirectionalKeys(dir, root18.opts.orientation.current);
  const loop = root18.opts.loop.current;
  const keyToIndex = {
    [nextKey]: currentIndex + 1,
    [prevKey]: currentIndex - 1,
    [kbd_constants_exports.HOME]: 0,
    [kbd_constants_exports.END]: items.length - 1
  };
  let itemIndex = keyToIndex[e.key];
  if (itemIndex === void 0) return;
  e.preventDefault();
  if (itemIndex < 0 && loop) {
    itemIndex = items.length - 1;
  } else if (itemIndex === items.length && loop) {
    itemIndex = 0;
  }
  const itemToFocus = items[itemIndex];
  if (!itemToFocus) return;
  itemToFocus.focus();
}
function getPageItems({ page = 1, totalPages, siblingCount = 1 }) {
  const pageItems = [];
  const pagesToShow = /* @__PURE__ */ new Set([1, totalPages]);
  const firstItemWithSiblings = 3 + siblingCount;
  const lastItemWithSiblings = totalPages - 2 - siblingCount;
  if (firstItemWithSiblings > lastItemWithSiblings) {
    for (let i = 2; i <= totalPages - 1; i++) {
      pagesToShow.add(i);
    }
  } else if (page < firstItemWithSiblings) {
    for (let i = 2; i <= Math.min(firstItemWithSiblings, totalPages); i++) {
      pagesToShow.add(i);
    }
  } else if (page > lastItemWithSiblings) {
    for (let i = totalPages - 1; i >= Math.max(lastItemWithSiblings, 2); i--) {
      pagesToShow.add(i);
    }
  } else {
    for (let i = Math.max(page - siblingCount, 2); i <= Math.min(page + siblingCount, totalPages); i++) {
      pagesToShow.add(i);
    }
  }
  function addPage(value) {
    pageItems.push({ type: "page", value, key: `page-${value}` });
  }
  function addEllipsis() {
    const id = useId();
    pageItems.push({ type: "ellipsis", key: `ellipsis-${id}` });
  }
  let lastNumber = 0;
  for (const p2 of Array.from(pagesToShow).sort((a2, b) => a2 - b)) {
    if (p2 - lastNumber > 1) {
      addEllipsis();
    }
    addPage(p2);
    lastNumber = p2;
  }
  return pageItems;
}

// node_modules/bits-ui/dist/bits/pagination/components/pagination.svelte
var root_283 = from_html(`<div><!></div>`);
function Pagination($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), perPage = prop($$props, "perPage", 3, 1), page = prop($$props, "page", 15, 1), ref = prop($$props, "ref", 15, null), siblingCount = prop($$props, "siblingCount", 3, 1), onPageChange = prop($$props, "onPageChange", 3, noop3), loop = prop($$props, "loop", 3, false), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "count",
    "perPage",
    "page",
    "ref",
    "siblingCount",
    "onPageChange",
    "loop",
    "orientation",
    "child",
    "children"
  ]);
  const rootState = PaginationRootState.create({
    id: boxWith(() => id()),
    count: boxWith(() => $$props.count),
    perPage: boxWith(() => perPage()),
    page: boxWith(() => page(), (v) => {
      var _a;
      page(v);
      (_a = onPageChange()) == null ? void 0 : _a(v);
    }),
    loop: boxWith(() => loop()),
    siblingCount: boxWith(() => siblingCount()),
    orientation: boxWith(() => orientation()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_283();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/pagination/components/pagination-prev-button.svelte
var root_284 = from_html(`<button><!></button>`);
function Pagination_prev_button($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "child",
    "children",
    "ref",
    "type",
    "disabled"
  ]);
  const prevButtonState = PaginationButtonState.create({
    type: "prev",
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    disabled: boxWith(() => Boolean(disabled()))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, prevButtonState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_284();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/pagination/components/pagination-next-button.svelte
var root_285 = from_html(`<button><!></button>`);
function Pagination_next_button($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "child",
    "children",
    "ref",
    "type",
    "disabled"
  ]);
  const nextButtonState = PaginationButtonState.create({
    type: "next",
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    disabled: boxWith(() => Boolean(disabled()))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, nextButtonState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_285();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/pagination/components/pagination-page.svelte
var root_286 = from_html(`<button><!></button>`);
function Pagination_page($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), type = prop($$props, "type", 3, "button"), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "page",
    "child",
    "children",
    "type",
    "ref",
    "disabled"
  ]);
  const pageState = PaginationPageState.create({
    id: boxWith(() => id()),
    page: boxWith(() => $$props.page),
    ref: boxWith(() => ref(), (v) => ref(v)),
    disabled: boxWith(() => Boolean(disabled()))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, pageState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_286();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop);
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, $$props.page.value));
          append($$anchor3, text2);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/pin-input/exports.js
var exports_exports24 = {};
__export(exports_exports24, {
  Cell: () => Pin_input_cell,
  Root: () => Pin_input
});

// node_modules/bits-ui/dist/bits/pin-input/components/pin-input.svelte
var root10 = from_html(`<div><!> <div><input/></div></div>`);
function Pin_input($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), inputId = prop($$props, "inputId", 19, () => `${createId(uid)}-input`), ref = prop($$props, "ref", 15, null), maxlength = prop($$props, "maxlength", 3, 6), textalign = prop($$props, "textalign", 3, "left"), inputmode = prop($$props, "inputmode", 3, "numeric"), onComplete = prop($$props, "onComplete", 3, noop3), pushPasswordManagerStrategy = prop($$props, "pushPasswordManagerStrategy", 3, "increase-width"), containerClass = prop($$props, "class", 3, ""), autocomplete = prop($$props, "autocomplete", 3, "one-time-code"), disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "inputId",
    "ref",
    "maxlength",
    "textalign",
    "pattern",
    "inputmode",
    "onComplete",
    "pushPasswordManagerStrategy",
    "class",
    "children",
    "autocomplete",
    "disabled",
    "value",
    "onValueChange",
    "pasteTransformer"
  ]);
  const rootState = PinInputRootState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    inputId: boxWith(() => inputId()),
    autocomplete: boxWith(() => autocomplete()),
    maxLength: boxWith(() => maxlength()),
    textAlign: boxWith(() => textalign()),
    disabled: boxWith(() => disabled()),
    inputmode: boxWith(() => inputmode()),
    pattern: boxWith(() => $$props.pattern),
    onComplete: boxWith(() => onComplete()),
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    pushPasswordManagerStrategy: boxWith(() => pushPasswordManagerStrategy()),
    pasteTransformer: boxWith(() => $$props.pasteTransformer)
  });
  const mergedInputProps = user_derived(() => mergeProps(restProps, rootState.inputProps));
  const mergedRootProps = user_derived(() => mergeProps(rootState.rootProps, { class: containerClass() }));
  const mergedInputWrapperProps = user_derived(() => mergeProps(rootState.inputWrapperProps, {}));
  var div = root10();
  attribute_effect(div, () => ({ ...get(mergedRootProps) }));
  var node = child(div);
  snippet(node, () => $$props.children ?? noop, () => rootState.snippetProps);
  var div_1 = sibling(node, 2);
  attribute_effect(div_1, () => ({ ...get(mergedInputWrapperProps) }));
  var input = child(div_1);
  remove_input_defaults(input);
  attribute_effect(input, () => ({ ...get(mergedInputProps) }));
  reset(div_1);
  reset(div);
  append($$anchor, div);
  pop();
}

// node_modules/bits-ui/dist/bits/pin-input/components/pin-input-cell.svelte
var root_287 = from_html(`<div><!></div>`);
function Pin_input_cell($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "cell",
    "child",
    "children"
  ]);
  const cellState = PinInputCellState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    cell: boxWith(() => $$props.cell)
  });
  const mergedProps = user_derived(() => mergeProps(restProps, cellState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_287();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/popover/exports.js
var exports_exports25 = {};
__export(exports_exports25, {
  Arrow: () => Popover_arrow,
  Close: () => Popover_close,
  Content: () => Popover_content,
  ContentStatic: () => Popover_content_static,
  Overlay: () => Popover_overlay,
  Portal: () => Portal,
  Root: () => Popover,
  Trigger: () => Popover_trigger
});

// node_modules/bits-ui/dist/bits/popover/components/popover.svelte
function Popover($$anchor, $$props) {
  push($$props, true);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  PopoverRootState.create({
    open: boxWith(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
  });
  Floating_layer($$anchor, {
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      snippet(node, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/bits-ui/dist/bits/popover/components/popover-overlay.svelte
var root_318 = from_html(`<div><!></div>`);
function Popover_overlay($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "forceMount",
    "child",
    "children",
    "ref"
  ]);
  const overlayState = PopoverOverlayState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, overlayState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          var render_arg = derived_safe_equal(() => ({
            props: mergeProps(get(mergedProps)),
            ...overlayState.snippetProps
          }));
          snippet(node_2, () => $$props.child, () => get(render_arg));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_318();
          attribute_effect(div, ($0) => ({ ...$0 }), [() => mergeProps(get(mergedProps))]);
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop, () => overlayState.snippetProps);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (overlayState.shouldRender || forceMount()) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/progress/exports.js
var exports_exports26 = {};
__export(exports_exports26, {
  Root: () => Progress
});

// node_modules/bits-ui/dist/bits/progress/progress.svelte.js
var progressAttrs = createBitsAttrs({ component: "progress", parts: ["root"] });
var _props117;
var _ProgressRootState = class _ProgressRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props117, user_derived(() => ({
      role: "progressbar",
      value: this.opts.value.current,
      "aria-valuemin": this.opts.min.current,
      "aria-valuemax": this.opts.max.current,
      "aria-valuenow": this.opts.value.current === null ? void 0 : this.opts.value.current,
      "data-value": this.opts.value.current === null ? void 0 : this.opts.value.current,
      "data-state": getProgressDataState(this.opts.value.current, this.opts.max.current),
      "data-max": this.opts.max.current,
      "data-min": this.opts.min.current,
      "data-indeterminate": this.opts.value.current === null ? "" : void 0,
      [progressAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _ProgressRootState(opts);
  }
  get props() {
    return get(__privateGet(this, _props117));
  }
  set props(value) {
    set(__privateGet(this, _props117), value);
  }
};
_props117 = new WeakMap();
var ProgressRootState = _ProgressRootState;
function getProgressDataState(value, max) {
  if (value === null) return "indeterminate";
  return value === max ? "loaded" : "loading";
}

// node_modules/bits-ui/dist/bits/progress/components/progress.svelte
var root_288 = from_html(`<div><!></div>`);
function Progress($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let value = prop($$props, "value", 3, 0), max = prop($$props, "max", 3, 100), min = prop($$props, "min", 3, 0), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "value",
    "max",
    "min",
    "id",
    "ref"
  ]);
  const rootState = ProgressRootState.create({
    value: boxWith(() => value()),
    max: boxWith(() => max()),
    min: boxWith(() => min()),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_288();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/radio-group/exports.js
var exports_exports27 = {};
__export(exports_exports27, {
  Item: () => Radio_group_item,
  Root: () => Radio_group
});

// node_modules/bits-ui/dist/bits/radio-group/radio-group.svelte.js
var radioGroupAttrs = createBitsAttrs({
  component: "radio-group",
  parts: ["root", "item"]
});
var RadioGroupRootContext = new Context("RadioGroup.Root");
var _hasValue3, _props118;
var _RadioGroupRootState = class _RadioGroupRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _hasValue3, user_derived(() => this.opts.value.current !== ""));
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "attachment");
    __privateAdd(this, _props118, user_derived(() => ({
      id: this.opts.id.current,
      role: "radiogroup",
      "aria-required": boolToStr(this.opts.required.current),
      "aria-disabled": boolToStr(this.opts.disabled.current),
      "aria-readonly": this.opts.readonly.current ? "true" : void 0,
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      "data-readonly": boolToEmptyStrOrUndef(this.opts.readonly.current),
      "data-orientation": this.opts.orientation.current,
      [radioGroupAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: this.opts.ref,
      candidateAttr: radioGroupAttrs.item,
      loop: this.opts.loop,
      orientation: this.opts.orientation
    });
  }
  static create(opts) {
    return RadioGroupRootContext.set(new _RadioGroupRootState(opts));
  }
  get hasValue() {
    return get(__privateGet(this, _hasValue3));
  }
  set hasValue(value) {
    set(__privateGet(this, _hasValue3), value);
  }
  isChecked(value) {
    return this.opts.value.current === value;
  }
  setValue(value) {
    this.opts.value.current = value;
  }
  get props() {
    return get(__privateGet(this, _props118));
  }
  set props(value) {
    set(__privateGet(this, _props118), value);
  }
};
_hasValue3 = new WeakMap();
_props118 = new WeakMap();
var RadioGroupRootState = _RadioGroupRootState;
var _checked, _isDisabled11, _isReadonly, _isChecked2, _tabIndex2, _snippetProps23, _props119;
var _RadioGroupItemState = class _RadioGroupItemState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _checked, user_derived(() => this.root.opts.value.current === this.opts.value.current));
    __privateAdd(this, _isDisabled11, user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current));
    __privateAdd(this, _isReadonly, user_derived(() => this.root.opts.readonly.current));
    __privateAdd(this, _isChecked2, user_derived(() => this.root.isChecked(this.opts.value.current)));
    __privateAdd(this, _tabIndex2, state(-1));
    __privateAdd(this, _snippetProps23, user_derived(() => ({ checked: get(__privateGet(this, _isChecked2)) })));
    __privateAdd(this, _props119, user_derived(() => ({
      id: this.opts.id.current,
      disabled: get(__privateGet(this, _isDisabled11)) ? true : void 0,
      "data-value": this.opts.value.current,
      "data-orientation": this.root.opts.orientation.current,
      "data-disabled": boolToEmptyStrOrUndef(get(__privateGet(this, _isDisabled11))),
      "data-readonly": boolToEmptyStrOrUndef(get(__privateGet(this, _isReadonly))),
      "data-state": get(__privateGet(this, _isChecked2)) ? "checked" : "unchecked",
      "aria-checked": getAriaChecked(get(__privateGet(this, _isChecked2)), false),
      [radioGroupAttrs.item]: "",
      type: "button",
      role: "radio",
      tabindex: get(__privateGet(this, _tabIndex2)),
      //
      onkeydown: this.onkeydown,
      onfocus: this.onfocus,
      onclick: this.onclick,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    if (this.opts.value.current === this.root.opts.value.current) {
      this.root.rovingFocusGroup.setCurrentTabStopId(this.opts.id.current);
      set(__privateGet(this, _tabIndex2), 0);
    } else if (!this.root.opts.value.current) {
      set(__privateGet(this, _tabIndex2), 0);
    }
    user_effect(() => {
      set(__privateGet(this, _tabIndex2), this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
    });
    watch(
      [
        () => this.opts.value.current,
        () => this.root.opts.value.current
      ],
      () => {
        if (this.opts.value.current === this.root.opts.value.current) {
          this.root.rovingFocusGroup.setCurrentTabStopId(this.opts.id.current);
          set(__privateGet(this, _tabIndex2), 0);
        }
      }
    );
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.onfocus = this.onfocus.bind(this);
  }
  static create(opts) {
    return new _RadioGroupItemState(opts, RadioGroupRootContext.get());
  }
  get checked() {
    return get(__privateGet(this, _checked));
  }
  set checked(value) {
    set(__privateGet(this, _checked), value);
  }
  onclick(_) {
    if (this.opts.disabled.current || get(__privateGet(this, _isReadonly))) return;
    this.root.setValue(this.opts.value.current);
  }
  onfocus(_) {
    if (!this.root.hasValue || get(__privateGet(this, _isReadonly))) return;
    this.root.setValue(this.opts.value.current);
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled11))) return;
    if (e.key === kbd_constants_exports.SPACE) {
      e.preventDefault();
      if (!get(__privateGet(this, _isReadonly))) {
        this.root.setValue(this.opts.value.current);
      }
      return;
    }
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e, true);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps23));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps23), value);
  }
  get props() {
    return get(__privateGet(this, _props119));
  }
  set props(value) {
    set(__privateGet(this, _props119), value);
  }
};
_checked = new WeakMap();
_isDisabled11 = new WeakMap();
_isReadonly = new WeakMap();
_isChecked2 = new WeakMap();
_tabIndex2 = new WeakMap();
_snippetProps23 = new WeakMap();
_props119 = new WeakMap();
var RadioGroupItemState = _RadioGroupItemState;
var _shouldRender10, _props120;
var _RadioGroupInputState = class _RadioGroupInputState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _shouldRender10, user_derived(() => this.root.opts.name.current !== void 0));
    __privateAdd(this, _props120, user_derived(() => ({
      name: this.root.opts.name.current,
      value: this.root.opts.value.current,
      required: this.root.opts.required.current,
      disabled: this.root.opts.disabled.current,
      onfocus: this.onfocus
    })));
    this.root = root18;
    this.onfocus = this.onfocus.bind(this);
  }
  static create() {
    return new _RadioGroupInputState(RadioGroupRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender10));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender10), value);
  }
  onfocus(_) {
    this.root.rovingFocusGroup.focusCurrentTabStop();
  }
  get props() {
    return get(__privateGet(this, _props120));
  }
  set props(value) {
    set(__privateGet(this, _props120), value);
  }
};
_shouldRender10 = new WeakMap();
_props120 = new WeakMap();
var RadioGroupInputState = _RadioGroupInputState;

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group-input.svelte
function Radio_group_input($$anchor, $$props) {
  push($$props, false);
  const inputState = RadioGroupInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Hidden_input($$anchor2, spread_props(() => inputState.props));
    };
    if_block(node, ($$render) => {
      if (inputState.shouldRender) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group.svelte
var root_289 = from_html(`<div><!></div>`);
var root11 = from_html(`<!> <!>`, 1);
function Radio_group($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15, ""), ref = prop($$props, "ref", 15, null), orientation = prop($$props, "orientation", 3, "vertical"), loop = prop($$props, "loop", 3, true), name = prop($$props, "name", 3, void 0), required = prop($$props, "required", 3, false), readonly = prop($$props, "readonly", 3, false), id = prop($$props, "id", 19, () => createId(uid)), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "disabled",
    "children",
    "child",
    "value",
    "ref",
    "orientation",
    "loop",
    "name",
    "required",
    "readonly",
    "id",
    "onValueChange"
  ]);
  const rootState = RadioGroupRootState.create({
    orientation: boxWith(() => orientation()),
    disabled: boxWith(() => disabled()),
    loop: boxWith(() => loop()),
    name: boxWith(() => name()),
    required: boxWith(() => required()),
    readonly: boxWith(() => readonly()),
    id: boxWith(() => id()),
    value: boxWith(() => value(), (v) => {
      var _a;
      if (v === value()) return;
      value(v);
      (_a = onValueChange()) == null ? void 0 : _a(v);
    }),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = root11();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_289();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  Radio_group_input(node_3, {});
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group-item.svelte
var root_290 = from_html(`<button><!></button>`);
function Radio_group_item($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "children",
    "child",
    "value",
    "disabled",
    "ref"
  ]);
  const itemState = RadioGroupItemState.create({
    value: boxWith(() => $$props.value),
    disabled: boxWith(() => disabled() ?? false),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...itemState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_290();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/range-calendar/exports.js
var exports_exports28 = {};
__export(exports_exports28, {
  Cell: () => Range_calendar_cell,
  Day: () => Range_calendar_day,
  Grid: () => Calendar_grid,
  GridBody: () => Calendar_grid_body,
  GridHead: () => Calendar_grid_head,
  GridRow: () => Calendar_grid_row,
  HeadCell: () => Calendar_head_cell,
  Header: () => Calendar_header,
  Heading: () => Calendar_heading,
  MonthSelect: () => Calendar_month_select,
  NextButton: () => Calendar_next_button,
  PrevButton: () => Calendar_prev_button,
  Root: () => Range_calendar,
  YearSelect: () => Calendar_year_select
});

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar.svelte
var root_291 = from_html(`<div><!></div>`);
function Range_calendar($$anchor, $$props) {
  var _a, _b, _c;
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), pagedNavigation = prop($$props, "pagedNavigation", 3, false), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), minValue = prop($$props, "minValue", 3, void 0), maxValue = prop($$props, "maxValue", 3, void 0), preventDeselect = prop($$props, "preventDeselect", 3, false), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), onStartValueChange = prop($$props, "onStartValueChange", 3, noop3), onEndValueChange = prop($$props, "onEndValueChange", 3, noop3), excludeDisabled = prop($$props, "excludeDisabled", 3, false), monthFormat = prop($$props, "monthFormat", 3, "long"), yearFormat = prop($$props, "yearFormat", 3, "numeric"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "value",
    "onValueChange",
    "placeholder",
    "onPlaceholderChange",
    "weekdayFormat",
    "weekStartsOn",
    "pagedNavigation",
    "isDateDisabled",
    "isDateUnavailable",
    "fixedWeeks",
    "numberOfMonths",
    "locale",
    "calendarLabel",
    "disabled",
    "readonly",
    "minValue",
    "maxValue",
    "preventDeselect",
    "disableDaysOutsideMonth",
    "minDays",
    "maxDays",
    "onStartValueChange",
    "onEndValueChange",
    "excludeDisabled",
    "monthFormat",
    "yearFormat"
  ]);
  let startValue = state(proxy((_a = value()) == null ? void 0 : _a.start));
  let endValue = state(proxy((_b = value()) == null ? void 0 : _b.end));
  const defaultPlaceholder = getDefaultDate({ defaultValue: (_c = value()) == null ? void 0 : _c.start });
  function handleDefaultPlaceholder() {
    if (placeholder() !== void 0) return;
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function handleDefaultValue() {
    if (value() !== void 0) return;
    value({ start: void 0, end: void 0 });
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = RangeCalendarRootState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: boxWith(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    disabled: boxWith(() => disabled()),
    readonly: boxWith(() => readonly()),
    preventDeselect: boxWith(() => preventDeselect()),
    minValue: boxWith(() => minValue()),
    maxValue: boxWith(() => maxValue()),
    isDateUnavailable: boxWith(() => isDateUnavailable()),
    isDateDisabled: boxWith(() => isDateDisabled()),
    pagedNavigation: boxWith(() => pagedNavigation()),
    weekStartsOn: boxWith(() => $$props.weekStartsOn),
    weekdayFormat: boxWith(() => weekdayFormat()),
    numberOfMonths: boxWith(() => numberOfMonths()),
    locale: resolveLocaleProp(() => $$props.locale),
    calendarLabel: boxWith(() => calendarLabel()),
    fixedWeeks: boxWith(() => fixedWeeks()),
    disableDaysOutsideMonth: boxWith(() => disableDaysOutsideMonth()),
    minDays: boxWith(() => $$props.minDays),
    maxDays: boxWith(() => $$props.maxDays),
    excludeDisabled: boxWith(() => excludeDisabled()),
    startValue: boxWith(() => get(startValue), (v) => {
      set(startValue, v, true);
      onStartValueChange()(v);
    }),
    endValue: boxWith(() => get(endValue), (v) => {
      set(endValue, v, true);
      onEndValueChange()(v);
    }),
    monthFormat: boxWith(() => monthFormat()),
    yearFormat: boxWith(() => yearFormat()),
    defaultPlaceholder
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_291();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/rating-group/exports.js
var exports_exports29 = {};
__export(exports_exports29, {
  Item: () => Rating_group_item,
  Root: () => Rating_group
});

// node_modules/bits-ui/dist/bits/rating-group/rating-group.svelte.js
var ratingGroupAttrs = createBitsAttrs({
  component: "rating-group",
  parts: ["root", "item"]
});
var RatingGroupRootContext = new Context("RatingGroup.Root");
var _hoverValue, _keySequence, _keySequenceTimeout, _hasValue4, _valueToUse, _isRTL, _ariaValuetext, _items, _RatingGroupRootState_instances, adjustValue_fn, handleDecimalInput_fn, startDecimalListening_fn, clearKeySequence_fn, _snippetProps24, _props121;
var _RatingGroupRootState = class _RatingGroupRootState {
  constructor(opts) {
    __privateAdd(this, _RatingGroupRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _hoverValue, state(null));
    __privateAdd(this, _keySequence, state(""));
    __privateAdd(this, _keySequenceTimeout, null);
    __publicField(this, "domContext");
    __privateAdd(this, _hasValue4, user_derived(() => this.opts.value.current > 0));
    __privateAdd(this, _valueToUse, user_derived(() => get(__privateGet(this, _hoverValue)) ?? this.opts.value.current));
    __privateAdd(this, _isRTL, user_derived(() => {
      const element2 = this.opts.ref.current;
      if (!element2) return false;
      const style = getComputedStyle(element2);
      return style.direction === "rtl";
    }));
    __privateAdd(this, _ariaValuetext, user_derived(() => {
      return typeof this.opts.ariaValuetext.current === "function" ? this.opts.ariaValuetext.current(this.opts.value.current, this.opts.max.current) : this.opts.ariaValuetext.current;
    }));
    __privateAdd(this, _items, user_derived(() => {
      const value = this.valueToUse;
      return Array.from({ length: this.opts.max.current }, (_, i) => {
        const itemValue = i + 1;
        const halfValue = itemValue - 0.5;
        const state2 = value >= itemValue ? "active" : this.opts.allowHalf.current && value >= halfValue ? "partial" : "inactive";
        return { index: i, state: state2 };
      });
    }));
    __publicField(this, "handlers", {
      [kbd_constants_exports.ARROW_UP]: () => {
        this.setHoverValue(null);
        __privateMethod(this, _RatingGroupRootState_instances, adjustValue_fn).call(this, this.opts.allowHalf.current ? 0.5 : 1);
      },
      [kbd_constants_exports.ARROW_RIGHT]: () => {
        this.setHoverValue(null);
        const increment = this.opts.allowHalf.current ? 0.5 : 1;
        __privateMethod(this, _RatingGroupRootState_instances, adjustValue_fn).call(this, this.isRTL ? -increment : increment);
      },
      [kbd_constants_exports.ARROW_DOWN]: () => {
        this.setHoverValue(null);
        __privateMethod(this, _RatingGroupRootState_instances, adjustValue_fn).call(this, this.opts.allowHalf.current ? -0.5 : -1);
      },
      [kbd_constants_exports.ARROW_LEFT]: () => {
        this.setHoverValue(null);
        const increment = this.opts.allowHalf.current ? 0.5 : 1;
        __privateMethod(this, _RatingGroupRootState_instances, adjustValue_fn).call(this, this.isRTL ? increment : -increment);
      },
      [kbd_constants_exports.HOME]: () => {
        this.setHoverValue(null);
        this.setValue(this.opts.min.current);
      },
      [kbd_constants_exports.END]: () => {
        this.setHoverValue(null);
        this.setValue(this.opts.max.current);
      },
      [kbd_constants_exports.PAGE_UP]: () => {
        this.setHoverValue(null);
        __privateMethod(this, _RatingGroupRootState_instances, adjustValue_fn).call(this, 1);
      },
      [kbd_constants_exports.PAGE_DOWN]: () => {
        this.setHoverValue(null);
        __privateMethod(this, _RatingGroupRootState_instances, adjustValue_fn).call(this, -1);
      }
    });
    __privateAdd(this, _snippetProps24, user_derived(() => ({
      items: this.items,
      value: this.opts.value.current,
      max: this.opts.max.current
    })));
    __privateAdd(this, _props121, user_derived(() => {
      return {
        id: this.opts.id.current,
        role: "slider",
        "aria-valuenow": this.opts.value.current,
        "aria-valuemin": this.opts.min.current,
        "aria-valuemax": this.opts.max.current,
        "aria-valuetext": this.ariaValuetext,
        "aria-orientation": this.opts.orientation.current,
        "aria-required": boolToStr(this.opts.required.current),
        "aria-disabled": this.opts.disabled.current ? "true" : void 0,
        "aria-label": "Rating",
        "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
        "data-readonly": this.opts.readonly.current ? "" : void 0,
        "data-orientation": this.opts.orientation.current,
        tabindex: this.opts.disabled.current ? -1 : 0,
        [ratingGroupAttrs.root]: "",
        onkeydown: this.onkeydown,
        onpointerleave: this.onpointerleave,
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
    this.domContext = new DOMContext(this.opts.ref);
  }
  static create(opts) {
    return RatingGroupRootContext.set(new _RatingGroupRootState(opts));
  }
  get hasValue() {
    return get(__privateGet(this, _hasValue4));
  }
  set hasValue(value) {
    set(__privateGet(this, _hasValue4), value);
  }
  get valueToUse() {
    return get(__privateGet(this, _valueToUse));
  }
  set valueToUse(value) {
    set(__privateGet(this, _valueToUse), value);
  }
  get isRTL() {
    return get(__privateGet(this, _isRTL));
  }
  set isRTL(value) {
    set(__privateGet(this, _isRTL), value);
  }
  get ariaValuetext() {
    return get(__privateGet(this, _ariaValuetext));
  }
  set ariaValuetext(value) {
    set(__privateGet(this, _ariaValuetext), value);
  }
  get items() {
    return get(__privateGet(this, _items));
  }
  set items(value) {
    set(__privateGet(this, _items), value);
  }
  isActive(itemIndex) {
    return this.valueToUse >= itemIndex + 1;
  }
  isPartial(itemIndex) {
    if (!this.opts.allowHalf.current) return false;
    const itemValue = itemIndex + 1;
    return this.valueToUse >= itemValue - 0.5 && this.valueToUse < itemValue;
  }
  setHoverValue(value) {
    if (this.opts.readonly.current || this.opts.disabled.current || !this.opts.hoverPreview.current) return;
    set(__privateGet(this, _hoverValue), value === null ? null : Math.max(this.opts.min.current, Math.min(this.opts.max.current, value)), true);
  }
  setValue(value) {
    if (this.opts.readonly.current || this.opts.disabled.current) return;
    this.opts.value.current = Math.max(this.opts.min.current, Math.min(this.opts.max.current, value));
  }
  calculateRatingFromPointer(itemIndex, event) {
    const ratingValue = itemIndex + 1;
    if (!this.opts.allowHalf.current) return ratingValue;
    const rect = event.currentTarget.getBoundingClientRect();
    const style = getComputedStyle(event.currentTarget);
    const isHorizontal = this.opts.orientation.current === "horizontal";
    const position = isHorizontal ? (event.clientX - rect.left) / rect.width : (event.clientY - rect.top) / rect.height;
    const normalizedPosition = style.direction === "rtl" ? 1 - position : position;
    return normalizedPosition < 0.5 ? ratingValue - 0.5 : ratingValue;
  }
  onpointerleave() {
    this.setHoverValue(null);
  }
  onkeydown(e) {
    var _a, _b;
    if (this.opts.disabled.current || this.opts.readonly.current) return;
    if (this.handlers[e.key]) {
      e.preventDefault();
      __privateMethod(this, _RatingGroupRootState_instances, clearKeySequence_fn).call(this);
      (_b = (_a = this.handlers)[e.key]) == null ? void 0 : _b.call(_a);
      return;
    }
    if (this.opts.allowHalf.current && __privateMethod(this, _RatingGroupRootState_instances, handleDecimalInput_fn).call(this, e)) return;
    const num = parseInt(e.key || "");
    if (!isNaN(num) && e.key) {
      e.preventDefault();
      if (num >= this.opts.min.current && num <= this.opts.max.current) {
        this.setValue(num);
        if (this.opts.allowHalf.current) {
          __privateMethod(this, _RatingGroupRootState_instances, startDecimalListening_fn).call(this, num);
        }
      }
      return;
    }
    __privateMethod(this, _RatingGroupRootState_instances, clearKeySequence_fn).call(this);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps24));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps24), value);
  }
  get props() {
    return get(__privateGet(this, _props121));
  }
  set props(value) {
    set(__privateGet(this, _props121), value);
  }
};
_hoverValue = new WeakMap();
_keySequence = new WeakMap();
_keySequenceTimeout = new WeakMap();
_hasValue4 = new WeakMap();
_valueToUse = new WeakMap();
_isRTL = new WeakMap();
_ariaValuetext = new WeakMap();
_items = new WeakMap();
_RatingGroupRootState_instances = new WeakSet();
adjustValue_fn = function(delta) {
  this.setValue(this.opts.value.current + delta);
};
handleDecimalInput_fn = function(e) {
  if (!e.key) return false;
  if (e.key === ".") {
    e.preventDefault();
    set(__privateGet(this, _keySequence), get(__privateGet(this, _keySequence)) + e.key);
    return true;
  }
  if (e.key === "5" && get(__privateGet(this, _keySequence)).match(/^\d+\.$/)) {
    e.preventDefault();
    set(__privateGet(this, _keySequence), get(__privateGet(this, _keySequence)) + e.key);
    const match = get(__privateGet(this, _keySequence)).match(/^(\d+)\.5$/);
    if (match == null ? void 0 : match[1]) {
      const value = parseFloat(get(__privateGet(this, _keySequence)));
      if (value >= this.opts.min.current && value <= this.opts.max.current) {
        this.setValue(value);
        __privateMethod(this, _RatingGroupRootState_instances, clearKeySequence_fn).call(this);
      }
    }
    return true;
  }
  return false;
};
startDecimalListening_fn = function(baseValue) {
  set(__privateGet(this, _keySequence), baseValue.toString(), true);
  if (__privateGet(this, _keySequenceTimeout)) {
    this.domContext.clearTimeout(__privateGet(this, _keySequenceTimeout));
  }
  __privateSet(this, _keySequenceTimeout, this.domContext.setTimeout(() => __privateMethod(this, _RatingGroupRootState_instances, clearKeySequence_fn).call(this), 1e3));
};
clearKeySequence_fn = function() {
  set(__privateGet(this, _keySequence), "");
  if (__privateGet(this, _keySequenceTimeout)) {
    this.domContext.clearTimeout(__privateGet(this, _keySequenceTimeout));
    __privateSet(this, _keySequenceTimeout, null);
  }
};
_snippetProps24 = new WeakMap();
_props121 = new WeakMap();
var RatingGroupRootState = _RatingGroupRootState;
var _isDisabled12, _isActive2, _isPartial, _state2, _snippetProps25, _props122;
var _RatingGroupItemState = class _RatingGroupItemState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled12, user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current));
    __privateAdd(this, _isActive2, user_derived(() => this.root.isActive(this.opts.index.current)));
    __privateAdd(this, _isPartial, user_derived(() => this.root.isPartial(this.opts.index.current)));
    __privateAdd(this, _state2, user_derived(() => {
      if (get(__privateGet(this, _isActive2))) return "active";
      if (get(__privateGet(this, _isPartial))) return "partial";
      return "inactive";
    }));
    __privateAdd(this, _snippetProps25, user_derived(() => {
      return { state: get(__privateGet(this, _state2)) };
    }));
    __privateAdd(this, _props122, user_derived(() => ({
      id: this.opts.id.current,
      role: "presentation",
      "data-value": this.opts.index.current + 1,
      "data-orientation": this.root.opts.orientation.current,
      "data-disabled": boolToEmptyStrOrUndef(get(__privateGet(this, _isDisabled12))),
      "data-readonly": this.root.opts.readonly.current ? "" : void 0,
      "data-state": get(__privateGet(this, _state2)),
      [ratingGroupAttrs.item]: "",
      //
      onclick: this.onclick,
      onpointermove: this.onpointermove,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
  }
  static create(opts) {
    return new _RatingGroupItemState(opts, RatingGroupRootContext.get());
  }
  onclick(e) {
    if (get(__privateGet(this, _isDisabled12)) || this.root.opts.readonly.current) return;
    if (this.opts.index.current === 0 && this.root.opts.min.current === 0 && this.root.opts.value.current > 0) {
      const newValue2 = this.root.calculateRatingFromPointer(this.opts.index.current, e);
      const currentValue = this.root.opts.value.current;
      if (newValue2 === currentValue) {
        this.root.setValue(0);
        if (this.root.opts.ref.current) {
          this.root.opts.ref.current.focus();
        }
        return;
      }
    }
    const newValue = this.root.calculateRatingFromPointer(this.opts.index.current, e);
    this.root.setValue(newValue);
    if (this.root.opts.ref.current) {
      this.root.opts.ref.current.focus();
    }
  }
  onpointermove(e) {
    if (get(__privateGet(this, _isDisabled12)) || this.root.opts.readonly.current || !this.root.opts.hoverPreview.current) return;
    if (e.pointerType === "touch") return;
    const hoverValue = this.root.calculateRatingFromPointer(this.opts.index.current, e);
    this.root.setHoverValue(hoverValue);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps25));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps25), value);
  }
  get props() {
    return get(__privateGet(this, _props122));
  }
  set props(value) {
    set(__privateGet(this, _props122), value);
  }
};
_isDisabled12 = new WeakMap();
_isActive2 = new WeakMap();
_isPartial = new WeakMap();
_state2 = new WeakMap();
_snippetProps25 = new WeakMap();
_props122 = new WeakMap();
var RatingGroupItemState = _RatingGroupItemState;
var _shouldRender11, _props123;
var _RatingGroupHiddenInputState = class _RatingGroupHiddenInputState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _shouldRender11, user_derived(() => this.root.opts.name.current !== void 0));
    __privateAdd(this, _props123, user_derived(() => ({
      name: this.root.opts.name.current,
      value: this.root.opts.value.current,
      required: this.root.opts.required.current,
      disabled: this.root.opts.disabled.current
    })));
    this.root = root18;
  }
  static create() {
    return new _RatingGroupHiddenInputState(RatingGroupRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender11));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender11), value);
  }
  get props() {
    return get(__privateGet(this, _props123));
  }
  set props(value) {
    set(__privateGet(this, _props123), value);
  }
};
_shouldRender11 = new WeakMap();
_props123 = new WeakMap();
var RatingGroupHiddenInputState = _RatingGroupHiddenInputState;

// node_modules/bits-ui/dist/bits/rating-group/components/rating-group-input.svelte
function Rating_group_input($$anchor, $$props) {
  push($$props, false);
  const inputState = RatingGroupHiddenInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Hidden_input($$anchor2, spread_props(() => inputState.props));
    };
    if_block(node, ($$render) => {
      if (inputState.shouldRender) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/rating-group/components/rating-group.svelte
var root_292 = from_html(`<div><!></div>`);
var root12 = from_html(`<!> <!>`, 1);
function Rating_group($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15, 0), ref = prop($$props, "ref", 15, null), orientation = prop($$props, "orientation", 3, "horizontal"), name = prop($$props, "name", 3, void 0), required = prop($$props, "required", 3, false), min = prop($$props, "min", 3, 0), max = prop($$props, "max", 3, 5), allowHalf = prop($$props, "allowHalf", 3, false), readonly = prop($$props, "readonly", 3, false), id = prop($$props, "id", 19, () => createId(uid)), onValueChange = prop($$props, "onValueChange", 3, noop3), hoverPreview = prop($$props, "hoverPreview", 3, true), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "disabled",
    "children",
    "child",
    "value",
    "ref",
    "orientation",
    "name",
    "required",
    "min",
    "max",
    "allowHalf",
    "readonly",
    "id",
    "onValueChange",
    "aria-label",
    "aria-valuetext",
    "hoverPreview"
  ]);
  if (value() < min() || value() > max()) {
    value(Math.max(min(), Math.min(max(), value())));
  }
  const ariaValuetext = user_derived(() => {
    if ($$props["aria-valuetext"]) return $$props["aria-valuetext"];
    return (value2, max2) => `${value2} out of ${max2}`;
  });
  const rootState = RatingGroupRootState.create({
    orientation: boxWith(() => orientation()),
    disabled: boxWith(() => disabled()),
    name: boxWith(() => name()),
    required: boxWith(() => required()),
    min: boxWith(() => min()),
    max: boxWith(() => max()),
    allowHalf: boxWith(() => allowHalf()),
    readonly: boxWith(() => readonly()),
    id: boxWith(() => id()),
    value: boxWith(() => value(), (v) => {
      var _a;
      if (v === value()) return;
      value(v);
      (_a = onValueChange()) == null ? void 0 : _a(v);
    }),
    ref: boxWith(() => ref(), (v) => ref(v)),
    ariaValuetext: boxWith(() => get(ariaValuetext)),
    hoverPreview: boxWith(() => hoverPreview())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props, { "aria-label": $$props["aria-label"] }));
  var fragment = root12();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_292();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  Rating_group_input(node_3, {});
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/rating-group/components/rating-group-item.svelte
var root_293 = from_html(`<div><!></div>`);
function Rating_group_item($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "disabled",
    "index",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const itemState = RatingGroupItemState.create({
    disabled: boxWith(() => Boolean(disabled())),
    index: boxWith(() => $$props.index),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, itemState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...itemState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_293();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/exports.js
var exports_exports30 = {};
__export(exports_exports30, {
  Corner: () => Scroll_area_corner,
  Root: () => Scroll_area,
  Scrollbar: () => Scroll_area_scrollbar,
  Thumb: () => Scroll_area_thumb,
  Viewport: () => Scroll_area_viewport
});

// node_modules/bits-ui/dist/internal/clamp.js
function clamp(n2, min, max) {
  return Math.min(max, Math.max(min, n2));
}

// node_modules/bits-ui/dist/bits/scroll-area/scroll-area.svelte.js
var scrollAreaAttrs = createBitsAttrs({
  component: "scroll-area",
  parts: [
    "root",
    "viewport",
    "corner",
    "thumb",
    "scrollbar"
  ]
});
var ScrollAreaRootContext = new Context("ScrollArea.Root");
var ScrollAreaScrollbarContext = new Context("ScrollArea.Scrollbar");
var ScrollAreaScrollbarVisibleContext = new Context("ScrollArea.ScrollbarVisible");
var ScrollAreaScrollbarAxisContext = new Context("ScrollArea.ScrollbarAxis");
var ScrollAreaScrollbarSharedContext = new Context("ScrollArea.ScrollbarShared");
var _scrollAreaNode, _viewportNode3, _contentNode11, _scrollbarXNode, _scrollbarYNode, _cornerWidth, _cornerHeight, _scrollbarXEnabled, _scrollbarYEnabled, _props124;
var _ScrollAreaRootState = class _ScrollAreaRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _scrollAreaNode, state(null));
    __privateAdd(this, _viewportNode3, state(null));
    __privateAdd(this, _contentNode11, state(null));
    __privateAdd(this, _scrollbarXNode, state(null));
    __privateAdd(this, _scrollbarYNode, state(null));
    __privateAdd(this, _cornerWidth, state(0));
    __privateAdd(this, _cornerHeight, state(0));
    __privateAdd(this, _scrollbarXEnabled, state(false));
    __privateAdd(this, _scrollbarYEnabled, state(false));
    __publicField(this, "domContext");
    __privateAdd(this, _props124, user_derived(() => ({
      id: this.opts.id.current,
      dir: this.opts.dir.current,
      style: {
        position: "relative",
        "--bits-scroll-area-corner-height": `${this.cornerHeight}px`,
        "--bits-scroll-area-corner-width": `${this.cornerWidth}px`
      },
      [scrollAreaAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(opts.ref, (v) => this.scrollAreaNode = v);
    this.domContext = new DOMContext(opts.ref);
  }
  static create(opts) {
    return ScrollAreaRootContext.set(new _ScrollAreaRootState(opts));
  }
  get scrollAreaNode() {
    return get(__privateGet(this, _scrollAreaNode));
  }
  set scrollAreaNode(value) {
    set(__privateGet(this, _scrollAreaNode), value, true);
  }
  get viewportNode() {
    return get(__privateGet(this, _viewportNode3));
  }
  set viewportNode(value) {
    set(__privateGet(this, _viewportNode3), value, true);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode11));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode11), value, true);
  }
  get scrollbarXNode() {
    return get(__privateGet(this, _scrollbarXNode));
  }
  set scrollbarXNode(value) {
    set(__privateGet(this, _scrollbarXNode), value, true);
  }
  get scrollbarYNode() {
    return get(__privateGet(this, _scrollbarYNode));
  }
  set scrollbarYNode(value) {
    set(__privateGet(this, _scrollbarYNode), value, true);
  }
  get cornerWidth() {
    return get(__privateGet(this, _cornerWidth));
  }
  set cornerWidth(value) {
    set(__privateGet(this, _cornerWidth), value, true);
  }
  get cornerHeight() {
    return get(__privateGet(this, _cornerHeight));
  }
  set cornerHeight(value) {
    set(__privateGet(this, _cornerHeight), value, true);
  }
  get scrollbarXEnabled() {
    return get(__privateGet(this, _scrollbarXEnabled));
  }
  set scrollbarXEnabled(value) {
    set(__privateGet(this, _scrollbarXEnabled), value, true);
  }
  get scrollbarYEnabled() {
    return get(__privateGet(this, _scrollbarYEnabled));
  }
  set scrollbarYEnabled(value) {
    set(__privateGet(this, _scrollbarYEnabled), value, true);
  }
  get props() {
    return get(__privateGet(this, _props124));
  }
  set props(value) {
    set(__privateGet(this, _props124), value);
  }
};
_scrollAreaNode = new WeakMap();
_viewportNode3 = new WeakMap();
_contentNode11 = new WeakMap();
_scrollbarXNode = new WeakMap();
_scrollbarYNode = new WeakMap();
_cornerWidth = new WeakMap();
_cornerHeight = new WeakMap();
_scrollbarXEnabled = new WeakMap();
_scrollbarYEnabled = new WeakMap();
_props124 = new WeakMap();
var ScrollAreaRootState = _ScrollAreaRootState;
var _contentId5, _contentRef, _props125, _contentProps;
var _ScrollAreaViewportState = class _ScrollAreaViewportState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _contentId5, simpleBox(useId()));
    __privateAdd(this, _contentRef, simpleBox(null));
    __publicField(this, "contentAttachment", attachRef(__privateGet(this, _contentRef), (v) => this.root.contentNode = v));
    __privateAdd(this, _props125, user_derived(() => ({
      id: this.opts.id.current,
      style: {
        overflowX: this.root.scrollbarXEnabled ? "scroll" : "hidden",
        overflowY: this.root.scrollbarYEnabled ? "scroll" : "hidden"
      },
      [scrollAreaAttrs.viewport]: "",
      ...this.attachment
    })));
    __privateAdd(this, _contentProps, user_derived(() => ({
      id: __privateGet(this, _contentId5).current,
      "data-scroll-area-content": "",
      /**
       * When horizontal scrollbar is visible: this element should be at least
       * as wide as its children for size calculations to work correctly.
       *
       * When horizontal scrollbar is NOT visible: this element's width should
       * be constrained by the parent container to enable `text-overflow: ellipsis`
       */
      style: {
        minWidth: this.root.scrollbarXEnabled ? "fit-content" : void 0
      },
      ...this.contentAttachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.viewportNode = v);
  }
  static create(opts) {
    return new _ScrollAreaViewportState(opts, ScrollAreaRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props125));
  }
  set props(value) {
    set(__privateGet(this, _props125), value);
  }
  get contentProps() {
    return get(__privateGet(this, _contentProps));
  }
  set contentProps(value) {
    set(__privateGet(this, _contentProps), value);
  }
};
_contentId5 = new WeakMap();
_contentRef = new WeakMap();
_props125 = new WeakMap();
_contentProps = new WeakMap();
var ScrollAreaViewportState = _ScrollAreaViewportState;
var _isHorizontal2, _hasThumb;
var _ScrollAreaScrollbarState = class _ScrollAreaScrollbarState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _isHorizontal2, user_derived(() => this.opts.orientation.current === "horizontal"));
    __privateAdd(this, _hasThumb, state(false));
    this.opts = opts;
    this.root = root18;
    watch(() => this.isHorizontal, (isHorizontal) => {
      if (isHorizontal) {
        this.root.scrollbarXEnabled = true;
        return () => {
          this.root.scrollbarXEnabled = false;
        };
      } else {
        this.root.scrollbarYEnabled = true;
        return () => {
          this.root.scrollbarYEnabled = false;
        };
      }
    });
  }
  static create(opts) {
    return ScrollAreaScrollbarContext.set(new _ScrollAreaScrollbarState(opts, ScrollAreaRootContext.get()));
  }
  get isHorizontal() {
    return get(__privateGet(this, _isHorizontal2));
  }
  set isHorizontal(value) {
    set(__privateGet(this, _isHorizontal2), value);
  }
  get hasThumb() {
    return get(__privateGet(this, _hasThumb));
  }
  set hasThumb(value) {
    set(__privateGet(this, _hasThumb), value, true);
  }
};
_isHorizontal2 = new WeakMap();
_hasThumb = new WeakMap();
var ScrollAreaScrollbarState = _ScrollAreaScrollbarState;
var _isVisible3, _props126;
var _ScrollAreaScrollbarHoverState = class _ScrollAreaScrollbarHoverState {
  constructor(scrollbar) {
    __publicField(this, "scrollbar");
    __publicField(this, "root");
    __privateAdd(this, _isVisible3, state(false));
    __privateAdd(this, _props126, user_derived(() => ({
      "data-state": this.isVisible ? "visible" : "hidden"
    })));
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    user_effect(() => {
      const scrollAreaNode = this.root.scrollAreaNode;
      const hideDelay = this.root.opts.scrollHideDelay.current;
      let hideTimer = 0;
      if (!scrollAreaNode) return;
      const handlePointerEnter = () => {
        this.root.domContext.clearTimeout(hideTimer);
        untrack(() => this.isVisible = true);
      };
      const handlePointerLeave = () => {
        if (hideTimer) this.root.domContext.clearTimeout(hideTimer);
        hideTimer = this.root.domContext.setTimeout(
          () => {
            untrack(() => {
              this.scrollbar.hasThumb = false;
              this.isVisible = false;
            });
          },
          hideDelay
        );
      };
      const unsubListeners = executeCallbacks(on(scrollAreaNode, "pointerenter", handlePointerEnter), on(scrollAreaNode, "pointerleave", handlePointerLeave));
      return () => {
        this.root.domContext.getWindow().clearTimeout(hideTimer);
        unsubListeners();
      };
    });
  }
  static create() {
    return new _ScrollAreaScrollbarHoverState(ScrollAreaScrollbarContext.get());
  }
  get isVisible() {
    return get(__privateGet(this, _isVisible3));
  }
  set isVisible(value) {
    set(__privateGet(this, _isVisible3), value, true);
  }
  get props() {
    return get(__privateGet(this, _props126));
  }
  set props(value) {
    set(__privateGet(this, _props126), value);
  }
};
_isVisible3 = new WeakMap();
_props126 = new WeakMap();
var ScrollAreaScrollbarHoverState = _ScrollAreaScrollbarHoverState;
var _isHidden, _props127;
var _ScrollAreaScrollbarScrollState = class _ScrollAreaScrollbarScrollState {
  constructor(scrollbar) {
    __publicField(this, "scrollbar");
    __publicField(this, "root");
    __publicField(this, "machine", new StateMachine("hidden", {
      hidden: { SCROLL: "scrolling" },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: { SCROLL: "interacting", POINTER_LEAVE: "idle" },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    }));
    __privateAdd(this, _isHidden, user_derived(() => this.machine.state.current === "hidden"));
    __privateAdd(this, _props127, user_derived(() => ({
      "data-state": this.machine.state.current === "hidden" ? "hidden" : "visible",
      onpointerenter: this.onpointerenter,
      onpointerleave: this.onpointerleave
    })));
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    const debounceScrollend = useDebounce(() => this.machine.dispatch("SCROLL_END"), 100);
    user_effect(() => {
      const _state3 = this.machine.state.current;
      const scrollHideDelay = this.root.opts.scrollHideDelay.current;
      if (_state3 === "idle") {
        const hideTimer = this.root.domContext.setTimeout(() => this.machine.dispatch("HIDE"), scrollHideDelay);
        return () => this.root.domContext.clearTimeout(hideTimer);
      }
    });
    user_effect(() => {
      const viewportNode = this.root.viewportNode;
      if (!viewportNode) return;
      const scrollDirection = this.scrollbar.isHorizontal ? "scrollLeft" : "scrollTop";
      let prevScrollPos = viewportNode[scrollDirection];
      const handleScroll = () => {
        const scrollPos = viewportNode[scrollDirection];
        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
        if (hasScrollInDirectionChanged) {
          this.machine.dispatch("SCROLL");
          debounceScrollend();
        }
        prevScrollPos = scrollPos;
      };
      const unsubListener = on(viewportNode, "scroll", handleScroll);
      return unsubListener;
    });
    this.onpointerenter = this.onpointerenter.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
  }
  static create() {
    return new _ScrollAreaScrollbarScrollState(ScrollAreaScrollbarContext.get());
  }
  get isHidden() {
    return get(__privateGet(this, _isHidden));
  }
  set isHidden(value) {
    set(__privateGet(this, _isHidden), value);
  }
  onpointerenter(_) {
    this.machine.dispatch("POINTER_ENTER");
  }
  onpointerleave(_) {
    this.machine.dispatch("POINTER_LEAVE");
  }
  get props() {
    return get(__privateGet(this, _props127));
  }
  set props(value) {
    set(__privateGet(this, _props127), value);
  }
};
_isHidden = new WeakMap();
_props127 = new WeakMap();
var ScrollAreaScrollbarScrollState = _ScrollAreaScrollbarScrollState;
var _isVisible4, _props128;
var _ScrollAreaScrollbarAutoState = class _ScrollAreaScrollbarAutoState {
  constructor(scrollbar) {
    __publicField(this, "scrollbar");
    __publicField(this, "root");
    __privateAdd(this, _isVisible4, state(false));
    __privateAdd(this, _props128, user_derived(() => ({
      "data-state": this.isVisible ? "visible" : "hidden"
    })));
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    const handleResize = useDebounce(
      () => {
        const viewportNode = this.root.viewportNode;
        if (!viewportNode) return;
        const isOverflowX = viewportNode.offsetWidth < viewportNode.scrollWidth;
        const isOverflowY = viewportNode.offsetHeight < viewportNode.scrollHeight;
        this.isVisible = this.scrollbar.isHorizontal ? isOverflowX : isOverflowY;
      },
      10
    );
    new SvelteResizeObserver(() => this.root.viewportNode, handleResize);
    new SvelteResizeObserver(() => this.root.contentNode, handleResize);
  }
  static create() {
    return new _ScrollAreaScrollbarAutoState(ScrollAreaScrollbarContext.get());
  }
  get isVisible() {
    return get(__privateGet(this, _isVisible4));
  }
  set isVisible(value) {
    set(__privateGet(this, _isVisible4), value, true);
  }
  get props() {
    return get(__privateGet(this, _props128));
  }
  set props(value) {
    set(__privateGet(this, _props128), value);
  }
};
_isVisible4 = new WeakMap();
_props128 = new WeakMap();
var ScrollAreaScrollbarAutoState = _ScrollAreaScrollbarAutoState;
var _thumbNode, _pointerOffset, _sizes, _thumbRatio, _hasThumb2, _prevTransformStyle;
var _ScrollAreaScrollbarVisibleState = class _ScrollAreaScrollbarVisibleState {
  constructor(scrollbar) {
    __publicField(this, "scrollbar");
    __publicField(this, "root");
    __privateAdd(this, _thumbNode, state(null));
    __privateAdd(this, _pointerOffset, state(0));
    __privateAdd(this, _sizes, state({
      content: 0,
      viewport: 0,
      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
    }));
    __privateAdd(this, _thumbRatio, user_derived(() => getThumbRatio(this.sizes.viewport, this.sizes.content)));
    __privateAdd(this, _hasThumb2, user_derived(() => Boolean(this.thumbRatio > 0 && this.thumbRatio < 1)));
    __privateAdd(this, _prevTransformStyle, state(""));
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    user_effect(() => {
      this.scrollbar.hasThumb = this.hasThumb;
    });
    user_effect(() => {
      if (!this.scrollbar.hasThumb && this.thumbNode) {
        this.prevTransformStyle = this.thumbNode.style.transform;
      }
    });
  }
  static create() {
    return ScrollAreaScrollbarVisibleContext.set(new _ScrollAreaScrollbarVisibleState(ScrollAreaScrollbarContext.get()));
  }
  get thumbNode() {
    return get(__privateGet(this, _thumbNode));
  }
  set thumbNode(value) {
    set(__privateGet(this, _thumbNode), value, true);
  }
  get pointerOffset() {
    return get(__privateGet(this, _pointerOffset));
  }
  set pointerOffset(value) {
    set(__privateGet(this, _pointerOffset), value, true);
  }
  get sizes() {
    return get(__privateGet(this, _sizes));
  }
  set sizes(value) {
    set(__privateGet(this, _sizes), value);
  }
  get thumbRatio() {
    return get(__privateGet(this, _thumbRatio));
  }
  set thumbRatio(value) {
    set(__privateGet(this, _thumbRatio), value);
  }
  get hasThumb() {
    return get(__privateGet(this, _hasThumb2));
  }
  set hasThumb(value) {
    set(__privateGet(this, _hasThumb2), value);
  }
  get prevTransformStyle() {
    return get(__privateGet(this, _prevTransformStyle));
  }
  set prevTransformStyle(value) {
    set(__privateGet(this, _prevTransformStyle), value, true);
  }
  setSizes(sizes) {
    this.sizes = sizes;
  }
  getScrollPosition(pointerPos, dir) {
    return getScrollPositionFromPointer({
      pointerPos,
      pointerOffset: this.pointerOffset,
      sizes: this.sizes,
      dir
    });
  }
  onThumbPointerUp() {
    this.pointerOffset = 0;
  }
  onThumbPointerDown(pointerPos) {
    this.pointerOffset = pointerPos;
  }
  xOnThumbPositionChange() {
    if (!(this.root.viewportNode && this.thumbNode)) return;
    const scrollPos = this.root.viewportNode.scrollLeft;
    const offset2 = getThumbOffsetFromScroll({
      scrollPos,
      sizes: this.sizes,
      dir: this.root.opts.dir.current
    });
    const transformStyle = `translate3d(${offset2}px, 0, 0)`;
    this.thumbNode.style.transform = transformStyle;
    this.prevTransformStyle = transformStyle;
  }
  xOnWheelScroll(scrollPos) {
    if (!this.root.viewportNode) return;
    this.root.viewportNode.scrollLeft = scrollPos;
  }
  xOnDragScroll(pointerPos) {
    if (!this.root.viewportNode) return;
    this.root.viewportNode.scrollLeft = this.getScrollPosition(pointerPos, this.root.opts.dir.current);
  }
  yOnThumbPositionChange() {
    if (!(this.root.viewportNode && this.thumbNode)) return;
    const scrollPos = this.root.viewportNode.scrollTop;
    const offset2 = getThumbOffsetFromScroll({ scrollPos, sizes: this.sizes });
    const transformStyle = `translate3d(0, ${offset2}px, 0)`;
    this.thumbNode.style.transform = transformStyle;
    this.prevTransformStyle = transformStyle;
  }
  yOnWheelScroll(scrollPos) {
    if (!this.root.viewportNode) return;
    this.root.viewportNode.scrollTop = scrollPos;
  }
  yOnDragScroll(pointerPos) {
    if (!this.root.viewportNode) return;
    this.root.viewportNode.scrollTop = this.getScrollPosition(pointerPos, this.root.opts.dir.current);
  }
};
_thumbNode = new WeakMap();
_pointerOffset = new WeakMap();
_sizes = new WeakMap();
_thumbRatio = new WeakMap();
_hasThumb2 = new WeakMap();
_prevTransformStyle = new WeakMap();
var ScrollAreaScrollbarVisibleState = _ScrollAreaScrollbarVisibleState;
var _computedStyle, _thumbSize, _props129;
var _ScrollAreaScrollbarXState = class _ScrollAreaScrollbarXState {
  constructor(opts, scrollbarVis) {
    __publicField(this, "opts");
    __publicField(this, "scrollbarVis");
    __publicField(this, "root");
    __publicField(this, "scrollbar");
    __publicField(this, "attachment");
    __privateAdd(this, _computedStyle, state());
    __publicField(this, "onThumbPointerDown", (pointerPos) => {
      this.scrollbarVis.onThumbPointerDown(pointerPos.x);
    });
    __publicField(this, "onDragScroll", (pointerPos) => {
      this.scrollbarVis.xOnDragScroll(pointerPos.x);
    });
    __publicField(this, "onThumbPointerUp", () => {
      this.scrollbarVis.onThumbPointerUp();
    });
    __publicField(this, "onThumbPositionChange", () => {
      this.scrollbarVis.xOnThumbPositionChange();
    });
    __publicField(this, "onWheelScroll", (e, maxScrollPos) => {
      if (!this.root.viewportNode) return;
      const scrollPos = this.root.viewportNode.scrollLeft + e.deltaX;
      this.scrollbarVis.xOnWheelScroll(scrollPos);
      if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
        e.preventDefault();
      }
    });
    __publicField(this, "onResize", () => {
      if (!(this.scrollbar.opts.ref.current && this.root.viewportNode && this.computedStyle)) return;
      this.scrollbarVis.setSizes({
        content: this.root.viewportNode.scrollWidth,
        viewport: this.root.viewportNode.offsetWidth,
        scrollbar: {
          size: this.scrollbar.opts.ref.current.clientWidth,
          paddingStart: toInt(this.computedStyle.paddingLeft),
          paddingEnd: toInt(this.computedStyle.paddingRight)
        }
      });
    });
    __privateAdd(this, _thumbSize, user_derived(() => {
      return getThumbSize(this.scrollbarVis.sizes);
    }));
    __privateAdd(this, _props129, user_derived(() => ({
      id: this.scrollbar.opts.id.current,
      "data-orientation": "horizontal",
      style: {
        bottom: 0,
        left: this.root.opts.dir.current === "rtl" ? "var(--bits-scroll-area-corner-width)" : 0,
        right: this.root.opts.dir.current === "ltr" ? "var(--bits-scroll-area-corner-width)" : 0,
        "--bits-scroll-area-thumb-width": `${this.thumbSize}px`
      },
      ...this.attachment
    })));
    this.opts = opts;
    this.scrollbarVis = scrollbarVis;
    this.root = scrollbarVis.root;
    this.scrollbar = scrollbarVis.scrollbar;
    this.attachment = attachRef(this.scrollbar.opts.ref, (v) => this.root.scrollbarXNode = v);
    user_effect(() => {
      if (!this.scrollbar.opts.ref.current) return;
      if (this.opts.mounted.current) {
        this.computedStyle = getComputedStyle(this.scrollbar.opts.ref.current);
      }
    });
    user_effect(() => {
      this.onResize();
    });
  }
  static create(opts) {
    return ScrollAreaScrollbarAxisContext.set(new _ScrollAreaScrollbarXState(opts, ScrollAreaScrollbarVisibleContext.get()));
  }
  get computedStyle() {
    return get(__privateGet(this, _computedStyle));
  }
  set computedStyle(value) {
    set(__privateGet(this, _computedStyle), value, true);
  }
  get thumbSize() {
    return get(__privateGet(this, _thumbSize));
  }
  set thumbSize(value) {
    set(__privateGet(this, _thumbSize), value);
  }
  get props() {
    return get(__privateGet(this, _props129));
  }
  set props(value) {
    set(__privateGet(this, _props129), value);
  }
};
_computedStyle = new WeakMap();
_thumbSize = new WeakMap();
_props129 = new WeakMap();
var ScrollAreaScrollbarXState = _ScrollAreaScrollbarXState;
var _computedStyle2, _thumbSize2, _props130;
var _ScrollAreaScrollbarYState = class _ScrollAreaScrollbarYState {
  constructor(opts, scrollbarVis) {
    __publicField(this, "opts");
    __publicField(this, "scrollbarVis");
    __publicField(this, "root");
    __publicField(this, "scrollbar");
    __publicField(this, "attachment");
    __privateAdd(this, _computedStyle2, state());
    __privateAdd(this, _thumbSize2, user_derived(() => {
      return getThumbSize(this.scrollbarVis.sizes);
    }));
    __privateAdd(this, _props130, user_derived(() => ({
      id: this.scrollbar.opts.id.current,
      "data-orientation": "vertical",
      style: {
        top: 0,
        right: this.root.opts.dir.current === "ltr" ? 0 : void 0,
        left: this.root.opts.dir.current === "rtl" ? 0 : void 0,
        bottom: "var(--bits-scroll-area-corner-height)",
        "--bits-scroll-area-thumb-height": `${this.thumbSize}px`
      },
      ...this.attachment
    })));
    this.opts = opts;
    this.scrollbarVis = scrollbarVis;
    this.root = scrollbarVis.root;
    this.scrollbar = scrollbarVis.scrollbar;
    this.attachment = attachRef(this.scrollbar.opts.ref, (v) => this.root.scrollbarYNode = v);
    user_effect(() => {
      if (!this.scrollbar.opts.ref.current) return;
      if (this.opts.mounted.current) {
        this.computedStyle = getComputedStyle(this.scrollbar.opts.ref.current);
      }
    });
    user_effect(() => {
      this.onResize();
    });
    this.onThumbPointerDown = this.onThumbPointerDown.bind(this);
    this.onDragScroll = this.onDragScroll.bind(this);
    this.onThumbPointerUp = this.onThumbPointerUp.bind(this);
    this.onThumbPositionChange = this.onThumbPositionChange.bind(this);
    this.onWheelScroll = this.onWheelScroll.bind(this);
    this.onResize = this.onResize.bind(this);
  }
  static create(opts) {
    return ScrollAreaScrollbarAxisContext.set(new _ScrollAreaScrollbarYState(opts, ScrollAreaScrollbarVisibleContext.get()));
  }
  get computedStyle() {
    return get(__privateGet(this, _computedStyle2));
  }
  set computedStyle(value) {
    set(__privateGet(this, _computedStyle2), value, true);
  }
  onThumbPointerDown(pointerPos) {
    this.scrollbarVis.onThumbPointerDown(pointerPos.y);
  }
  onDragScroll(pointerPos) {
    this.scrollbarVis.yOnDragScroll(pointerPos.y);
  }
  onThumbPointerUp() {
    this.scrollbarVis.onThumbPointerUp();
  }
  onThumbPositionChange() {
    this.scrollbarVis.yOnThumbPositionChange();
  }
  onWheelScroll(e, maxScrollPos) {
    if (!this.root.viewportNode) return;
    const scrollPos = this.root.viewportNode.scrollTop + e.deltaY;
    this.scrollbarVis.yOnWheelScroll(scrollPos);
    if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
      e.preventDefault();
    }
  }
  onResize() {
    if (!(this.scrollbar.opts.ref.current && this.root.viewportNode && this.computedStyle)) return;
    this.scrollbarVis.setSizes({
      content: this.root.viewportNode.scrollHeight,
      viewport: this.root.viewportNode.offsetHeight,
      scrollbar: {
        size: this.scrollbar.opts.ref.current.clientHeight,
        paddingStart: toInt(this.computedStyle.paddingTop),
        paddingEnd: toInt(this.computedStyle.paddingBottom)
      }
    });
  }
  get thumbSize() {
    return get(__privateGet(this, _thumbSize2));
  }
  set thumbSize(value) {
    set(__privateGet(this, _thumbSize2), value);
  }
  get props() {
    return get(__privateGet(this, _props130));
  }
  set props(value) {
    set(__privateGet(this, _props130), value);
  }
};
_computedStyle2 = new WeakMap();
_thumbSize2 = new WeakMap();
_props130 = new WeakMap();
var ScrollAreaScrollbarYState = _ScrollAreaScrollbarYState;
var _rect, _prevWebkitUserSelect, _maxScrollPos, _props131;
var _ScrollAreaScrollbarSharedState = class _ScrollAreaScrollbarSharedState {
  constructor(scrollbarState) {
    __publicField(this, "scrollbarState");
    __publicField(this, "root");
    __publicField(this, "scrollbarVis");
    __publicField(this, "scrollbar");
    __privateAdd(this, _rect, state(null));
    __privateAdd(this, _prevWebkitUserSelect, state(""));
    __publicField(this, "handleResize");
    __publicField(this, "handleThumbPositionChange");
    __publicField(this, "handleWheelScroll");
    __publicField(this, "handleThumbPointerDown");
    __publicField(this, "handleThumbPointerUp");
    __privateAdd(this, _maxScrollPos, user_derived(() => this.scrollbarVis.sizes.content - this.scrollbarVis.sizes.viewport));
    __privateAdd(this, _props131, user_derived(() => mergeProps({
      ...this.scrollbarState.props,
      style: {
        position: "absolute",
        ...this.scrollbarState.props.style
      },
      [scrollAreaAttrs.scrollbar]: "",
      onpointerdown: this.onpointerdown,
      onpointermove: this.onpointermove,
      onpointerup: this.onpointerup
    })));
    this.scrollbarState = scrollbarState;
    this.root = scrollbarState.root;
    this.scrollbarVis = scrollbarState.scrollbarVis;
    this.scrollbar = scrollbarState.scrollbarVis.scrollbar;
    this.handleResize = useDebounce(() => this.scrollbarState.onResize(), 10);
    this.handleThumbPositionChange = this.scrollbarState.onThumbPositionChange;
    this.handleWheelScroll = this.scrollbarState.onWheelScroll;
    this.handleThumbPointerDown = this.scrollbarState.onThumbPointerDown;
    this.handleThumbPointerUp = this.scrollbarState.onThumbPointerUp;
    user_effect(() => {
      const maxScrollPos = this.maxScrollPos;
      const scrollbarNode = this.scrollbar.opts.ref.current;
      this.root.viewportNode;
      const handleWheel = (e) => {
        const node = e.target;
        const isScrollbarWheel = scrollbarNode == null ? void 0 : scrollbarNode.contains(node);
        if (isScrollbarWheel) this.handleWheelScroll(e, maxScrollPos);
      };
      const unsubListener = on(this.root.domContext.getDocument(), "wheel", handleWheel, { passive: false });
      return unsubListener;
    });
    user_pre_effect(() => {
      this.scrollbarVis.sizes;
      untrack(() => this.handleThumbPositionChange());
    });
    new SvelteResizeObserver(() => this.scrollbar.opts.ref.current, this.handleResize);
    new SvelteResizeObserver(() => this.root.contentNode, this.handleResize);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
  }
  static create() {
    return ScrollAreaScrollbarSharedContext.set(new _ScrollAreaScrollbarSharedState(ScrollAreaScrollbarAxisContext.get()));
  }
  get rect() {
    return get(__privateGet(this, _rect));
  }
  set rect(value) {
    set(__privateGet(this, _rect), value);
  }
  get prevWebkitUserSelect() {
    return get(__privateGet(this, _prevWebkitUserSelect));
  }
  set prevWebkitUserSelect(value) {
    set(__privateGet(this, _prevWebkitUserSelect), value, true);
  }
  get maxScrollPos() {
    return get(__privateGet(this, _maxScrollPos));
  }
  set maxScrollPos(value) {
    set(__privateGet(this, _maxScrollPos), value);
  }
  handleDragScroll(e) {
    if (!this.rect) return;
    const x = e.clientX - this.rect.left;
    const y = e.clientY - this.rect.top;
    this.scrollbarState.onDragScroll({ x, y });
  }
  onpointerdown(e) {
    var _a;
    if (e.button !== 0) return;
    const target = e.target;
    target.setPointerCapture(e.pointerId);
    this.rect = ((_a = this.scrollbar.opts.ref.current) == null ? void 0 : _a.getBoundingClientRect()) ?? null;
    this.prevWebkitUserSelect = this.root.domContext.getDocument().body.style.webkitUserSelect;
    this.root.domContext.getDocument().body.style.webkitUserSelect = "none";
    if (this.root.viewportNode) this.root.viewportNode.style.scrollBehavior = "auto";
    this.handleDragScroll(e);
  }
  onpointermove(e) {
    this.handleDragScroll(e);
  }
  onpointerup(e) {
    const target = e.target;
    if (target.hasPointerCapture(e.pointerId)) {
      target.releasePointerCapture(e.pointerId);
    }
    this.root.domContext.getDocument().body.style.webkitUserSelect = this.prevWebkitUserSelect;
    if (this.root.viewportNode) this.root.viewportNode.style.scrollBehavior = "";
    this.rect = null;
  }
  get props() {
    return get(__privateGet(this, _props131));
  }
  set props(value) {
    set(__privateGet(this, _props131), value);
  }
};
_rect = new WeakMap();
_prevWebkitUserSelect = new WeakMap();
_maxScrollPos = new WeakMap();
_props131 = new WeakMap();
var ScrollAreaScrollbarSharedState = _ScrollAreaScrollbarSharedState;
var _root3, _removeUnlinkedScrollListener, _debounceScrollEnd, _props132;
var _ScrollAreaThumbImplState = class _ScrollAreaThumbImplState {
  constructor(opts, scrollbarState) {
    __publicField(this, "opts");
    __publicField(this, "scrollbarState");
    __publicField(this, "attachment");
    __privateAdd(this, _root3);
    __privateAdd(this, _removeUnlinkedScrollListener, state());
    __privateAdd(this, _debounceScrollEnd, useDebounce(
      () => {
        if (get(__privateGet(this, _removeUnlinkedScrollListener))) {
          get(__privateGet(this, _removeUnlinkedScrollListener))();
          set(__privateGet(this, _removeUnlinkedScrollListener), void 0);
        }
      },
      100
    ));
    __privateAdd(this, _props132, user_derived(() => ({
      id: this.opts.id.current,
      "data-state": this.scrollbarState.scrollbarVis.hasThumb ? "visible" : "hidden",
      style: {
        width: "var(--bits-scroll-area-thumb-width)",
        height: "var(--bits-scroll-area-thumb-height)",
        transform: this.scrollbarState.scrollbarVis.prevTransformStyle
      },
      onpointerdowncapture: this.onpointerdowncapture,
      onpointerup: this.onpointerup,
      [scrollAreaAttrs.thumb]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.scrollbarState = scrollbarState;
    __privateSet(this, _root3, scrollbarState.root);
    this.attachment = attachRef(this.opts.ref, (v) => this.scrollbarState.scrollbarVis.thumbNode = v);
    user_effect(() => {
      const viewportNode = __privateGet(this, _root3).viewportNode;
      if (!viewportNode) return;
      const handleScroll = () => {
        __privateGet(this, _debounceScrollEnd).call(this);
        if (!get(__privateGet(this, _removeUnlinkedScrollListener))) {
          const listener = addUnlinkedScrollListener(viewportNode, this.scrollbarState.handleThumbPositionChange);
          set(__privateGet(this, _removeUnlinkedScrollListener), listener, true);
          this.scrollbarState.handleThumbPositionChange();
        }
      };
      untrack(() => this.scrollbarState.handleThumbPositionChange());
      const unsubListener = on(viewportNode, "scroll", handleScroll);
      return unsubListener;
    });
    this.onpointerdowncapture = this.onpointerdowncapture.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
  }
  static create(opts) {
    return new _ScrollAreaThumbImplState(opts, ScrollAreaScrollbarSharedContext.get());
  }
  onpointerdowncapture(e) {
    const thumb = e.target;
    if (!thumb) return;
    const thumbRect = thumb.getBoundingClientRect();
    const x = e.clientX - thumbRect.left;
    const y = e.clientY - thumbRect.top;
    this.scrollbarState.handleThumbPointerDown({ x, y });
  }
  onpointerup(_) {
    this.scrollbarState.handleThumbPointerUp();
  }
  get props() {
    return get(__privateGet(this, _props132));
  }
  set props(value) {
    set(__privateGet(this, _props132), value);
  }
};
_root3 = new WeakMap();
_removeUnlinkedScrollListener = new WeakMap();
_debounceScrollEnd = new WeakMap();
_props132 = new WeakMap();
var ScrollAreaThumbImplState = _ScrollAreaThumbImplState;
var _width3, _height3, _hasSize, _props133;
var _ScrollAreaCornerImplState = class _ScrollAreaCornerImplState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _width3, state(0));
    __privateAdd(this, _height3, state(0));
    __privateAdd(this, _hasSize, user_derived(() => Boolean(get(__privateGet(this, _width3)) && get(__privateGet(this, _height3)))));
    __privateAdd(this, _props133, user_derived(() => ({
      id: this.opts.id.current,
      style: {
        width: get(__privateGet(this, _width3)),
        height: get(__privateGet(this, _height3)),
        position: "absolute",
        right: this.root.opts.dir.current === "ltr" ? 0 : void 0,
        left: this.root.opts.dir.current === "rtl" ? 0 : void 0,
        bottom: 0
      },
      [scrollAreaAttrs.corner]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    new SvelteResizeObserver(() => this.root.scrollbarXNode, () => {
      var _a;
      const height = ((_a = this.root.scrollbarXNode) == null ? void 0 : _a.offsetHeight) || 0;
      this.root.cornerHeight = height;
      set(__privateGet(this, _height3), height, true);
    });
    new SvelteResizeObserver(() => this.root.scrollbarYNode, () => {
      var _a;
      const width = ((_a = this.root.scrollbarYNode) == null ? void 0 : _a.offsetWidth) || 0;
      this.root.cornerWidth = width;
      set(__privateGet(this, _width3), width, true);
    });
  }
  static create(opts) {
    return new _ScrollAreaCornerImplState(opts, ScrollAreaRootContext.get());
  }
  get hasSize() {
    return get(__privateGet(this, _hasSize));
  }
  set hasSize(value) {
    set(__privateGet(this, _hasSize), value);
  }
  get props() {
    return get(__privateGet(this, _props133));
  }
  set props(value) {
    set(__privateGet(this, _props133), value);
  }
};
_width3 = new WeakMap();
_height3 = new WeakMap();
_hasSize = new WeakMap();
_props133 = new WeakMap();
var ScrollAreaCornerImplState = _ScrollAreaCornerImplState;
function toInt(value) {
  return value ? Number.parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer({
  pointerPos,
  pointerOffset,
  sizes,
  dir = "ltr"
}) {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset2 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset2;
  const minPointerPos = sizes.scrollbar.paddingStart + offset2;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll({ scrollPos, sizes, dir = "ltr" }) {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange[0], scrollClampRange[1]);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
function addUnlinkedScrollListener(node, handler) {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  const win = getWindow(node);
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position.left;
    const isVerticalScroll = prevPosition.top !== position.top;
    if (isHorizontalScroll || isVerticalScroll) handler();
    prevPosition = position;
    rAF = win.requestAnimationFrame(loop);
  })();
  return () => win.cancelAnimationFrame(rAF);
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area.svelte
var root_294 = from_html(`<div><!></div>`);
function Scroll_area($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), type = prop($$props, "type", 3, "hover"), dir = prop($$props, "dir", 3, "ltr"), scrollHideDelay = prop($$props, "scrollHideDelay", 3, 600), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "type",
    "dir",
    "scrollHideDelay",
    "children",
    "child"
  ]);
  const rootState = ScrollAreaRootState.create({
    type: boxWith(() => type()),
    dir: boxWith(() => dir()),
    scrollHideDelay: boxWith(() => scrollHideDelay()),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_294();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-viewport.svelte
var root13 = from_html(`<div><div><!></div></div>`);
var $$css2 = {
  hash: "svelte-w8xgs5",
  code: "\n	/* Hide scrollbars cross browser and enable momentum scroll for touch devices */[data-scroll-area-viewport] {scrollbar-width:none !important;-ms-overflow-style:none !important;-webkit-overflow-scrolling:touch !important;}[data-scroll-area-viewport]::-webkit-scrollbar {display:none !important;}:where([data-scroll-area-viewport]) {display:flex;flex-direction:column;align-items:stretch;}:where([data-scroll-area-content]) {flex-grow:1;}"
};
function Scroll_area_viewport($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  append_styles($$anchor, $$css2);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "children"
  ]);
  const viewportState = ScrollAreaViewportState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, viewportState.props));
  const mergedContentProps = user_derived(() => mergeProps({}, viewportState.contentProps));
  var div = root13();
  attribute_effect(div, () => ({ ...get(mergedProps) }));
  var div_1 = child(div);
  attribute_effect(div_1, () => ({ ...get(mergedContentProps) }));
  var node = child(div_1);
  snippet(node, () => $$props.children ?? noop);
  reset(div_1);
  reset(div);
  append($$anchor, div);
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-shared.svelte
var root_295 = from_html(`<div><!></div>`);
function Scroll_area_scrollbar_shared($$anchor, $$props) {
  push($$props, true);
  let restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children"
  ]);
  const scrollbarSharedState = ScrollAreaScrollbarSharedState.create();
  const mergedProps = user_derived(() => mergeProps(restProps, scrollbarSharedState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_295();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-x.svelte
function Scroll_area_scrollbar_x($$anchor, $$props) {
  push($$props, true);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"]);
  const isMounted = new IsMounted();
  const scrollbarXState = ScrollAreaScrollbarXState.create({ mounted: boxWith(() => isMounted.current) });
  const mergedProps = user_derived(() => mergeProps(restProps, scrollbarXState.props));
  Scroll_area_scrollbar_shared($$anchor, spread_props(() => get(mergedProps)));
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-y.svelte
function Scroll_area_scrollbar_y($$anchor, $$props) {
  push($$props, true);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"]);
  const isMounted = new IsMounted();
  const scrollbarYState = ScrollAreaScrollbarYState.create({ mounted: boxWith(() => isMounted.current) });
  const mergedProps = user_derived(() => mergeProps(restProps, scrollbarYState.props));
  Scroll_area_scrollbar_shared($$anchor, spread_props(() => get(mergedProps)));
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-visible.svelte
function Scroll_area_scrollbar_visible($$anchor, $$props) {
  push($$props, true);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"]);
  const scrollbarVisibleState = ScrollAreaScrollbarVisibleState.create();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Scroll_area_scrollbar_x($$anchor2, spread_props(() => restProps));
    };
    var alternate = ($$anchor2) => {
      Scroll_area_scrollbar_y($$anchor2, spread_props(() => restProps));
    };
    if_block(node, ($$render) => {
      if (scrollbarVisibleState.scrollbar.opts.orientation.current === "horizontal") $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-auto.svelte
function Scroll_area_scrollbar_auto($$anchor, $$props) {
  push($$props, true);
  let forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "forceMount"
  ]);
  const scrollbarAutoState = ScrollAreaScrollbarAutoState.create();
  const mergedProps = user_derived(() => mergeProps(restProps, scrollbarAutoState.props));
  const expression = user_derived(() => forceMount() || scrollbarAutoState.isVisible);
  {
    const presence = ($$anchor2) => {
      Scroll_area_scrollbar_visible($$anchor2, spread_props(() => get(mergedProps)));
    };
    Presence_layer($$anchor, {
      get open() {
        return get(expression);
      },
      get ref() {
        return scrollbarAutoState.scrollbar.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-scroll.svelte
function Scroll_area_scrollbar_scroll($$anchor, $$props) {
  push($$props, true);
  let forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "forceMount"
  ]);
  const scrollbarScrollState = ScrollAreaScrollbarScrollState.create();
  const mergedProps = user_derived(() => mergeProps(restProps, scrollbarScrollState.props));
  const expression = user_derived(() => forceMount() || !scrollbarScrollState.isHidden);
  {
    const presence = ($$anchor2) => {
      Scroll_area_scrollbar_visible($$anchor2, spread_props(() => get(mergedProps)));
    };
    Presence_layer($$anchor, spread_props(() => get(mergedProps), {
      get open() {
        return get(expression);
      },
      get ref() {
        return scrollbarScrollState.scrollbar.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    }));
  }
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-hover.svelte
function Scroll_area_scrollbar_hover($$anchor, $$props) {
  push($$props, true);
  let forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "forceMount"
  ]);
  const scrollbarHoverState = ScrollAreaScrollbarHoverState.create();
  const scrollbarAutoState = ScrollAreaScrollbarAutoState.create();
  const mergedProps = user_derived(() => mergeProps(restProps, scrollbarHoverState.props, scrollbarAutoState.props, {
    "data-state": scrollbarHoverState.isVisible ? "visible" : "hidden"
  }));
  const open = user_derived(() => forceMount() || scrollbarHoverState.isVisible && scrollbarAutoState.isVisible);
  {
    const presence = ($$anchor2) => {
      Scroll_area_scrollbar_visible($$anchor2, spread_props(() => get(mergedProps)));
    };
    Presence_layer($$anchor, {
      get open() {
        return get(open);
      },
      get ref() {
        return scrollbarAutoState.scrollbar.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar.svelte
function Scroll_area_scrollbar($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "orientation"
  ]);
  const scrollbarState = ScrollAreaScrollbarState.create({
    orientation: boxWith(() => $$props.orientation),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const type = user_derived(() => scrollbarState.root.opts.type.current);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Scroll_area_scrollbar_hover($$anchor2, spread_props(() => restProps, {
        get id() {
          return id();
        }
      }));
    };
    var alternate = ($$anchor2, $$elseif) => {
      {
        var consequent_1 = ($$anchor3) => {
          Scroll_area_scrollbar_scroll($$anchor3, spread_props(() => restProps, {
            get id() {
              return id();
            }
          }));
        };
        var alternate_1 = ($$anchor3, $$elseif2) => {
          {
            var consequent_2 = ($$anchor4) => {
              Scroll_area_scrollbar_auto($$anchor4, spread_props(() => restProps, {
                get id() {
                  return id();
                }
              }));
            };
            var alternate_2 = ($$anchor4, $$elseif3) => {
              {
                var consequent_3 = ($$anchor5) => {
                  Scroll_area_scrollbar_visible($$anchor5, spread_props(() => restProps, {
                    get id() {
                      return id();
                    }
                  }));
                };
                if_block(
                  $$anchor4,
                  ($$render) => {
                    if (get(type) === "always") $$render(consequent_3);
                  },
                  $$elseif3
                );
              }
            };
            if_block(
              $$anchor3,
              ($$render) => {
                if (get(type) === "auto") $$render(consequent_2);
                else $$render(alternate_2, false);
              },
              $$elseif2
            );
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (get(type) === "scroll") $$render(consequent_1);
            else $$render(alternate_1, false);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (get(type) === "hover") $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb-impl.svelte
var root_296 = from_html(`<div><!></div>`);
function Scroll_area_thumb_impl($$anchor, $$props) {
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "child",
    "children",
    "present"
  ]);
  const isMounted = new IsMounted();
  const thumbState = ScrollAreaThumbImplState.create({
    id: boxWith(() => $$props.id),
    ref: boxWith(() => ref(), (v) => ref(v)),
    mounted: boxWith(() => isMounted.current)
  });
  const mergedProps = user_derived(() => mergeProps(restProps, thumbState.props, { style: { hidden: !$$props.present } }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_296();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb.svelte
function Scroll_area_thumb($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "forceMount"
  ]);
  const scrollbarState = ScrollAreaScrollbarVisibleContext.get();
  const expression = user_derived(() => forceMount() || scrollbarState.hasThumb);
  {
    const presence = ($$anchor2, $$arg0) => {
      let present = () => $$arg0 == null ? void 0 : $$arg0().present;
      Scroll_area_thumb_impl($$anchor2, spread_props(() => restProps, {
        get id() {
          return id();
        },
        get present() {
          return present();
        },
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      }));
    };
    Presence_layer($$anchor, {
      get open() {
        return get(expression);
      },
      get ref() {
        return scrollbarState.scrollbar.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner-impl.svelte
var root_297 = from_html(`<div><!></div>`);
function Scroll_area_corner_impl($$anchor, $$props) {
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "children",
    "child"
  ]);
  const cornerState = ScrollAreaCornerImplState.create({
    id: boxWith(() => $$props.id),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, cornerState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_297();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner.svelte
function Scroll_area_corner($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id"
  ]);
  const scrollAreaState = ScrollAreaRootContext.get();
  const hasBothScrollbarsVisible = user_derived(() => Boolean(scrollAreaState.scrollbarXNode && scrollAreaState.scrollbarYNode));
  const hasCorner = user_derived(() => scrollAreaState.opts.type.current !== "scroll" && get(hasBothScrollbarsVisible));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Scroll_area_corner_impl($$anchor2, spread_props(() => restProps, {
        get id() {
          return id();
        },
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      }));
    };
    if_block(node, ($$render) => {
      if (get(hasCorner)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/select/exports.js
var exports_exports31 = {};
__export(exports_exports31, {
  Content: () => Select_content,
  ContentStatic: () => Select_content_static,
  Group: () => Select_group,
  GroupHeading: () => Select_group_heading,
  Item: () => Select_item,
  Portal: () => Portal,
  Root: () => Select,
  ScrollDownButton: () => Select_scroll_down_button,
  ScrollUpButton: () => Select_scroll_up_button,
  Trigger: () => Select_trigger,
  Viewport: () => Select_viewport
});

// node_modules/bits-ui/dist/bits/select/components/select.svelte
var root14 = from_html(`<!> <!>`, 1);
function Select($$anchor, $$props) {
  push($$props, true);
  let value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), name = prop($$props, "name", 3, ""), disabled = prop($$props, "disabled", 3, false), open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), loop = prop($$props, "loop", 3, false), scrollAlignment = prop($$props, "scrollAlignment", 3, "nearest"), required = prop($$props, "required", 3, false), items = prop($$props, "items", 19, () => []), allowDeselect = prop($$props, "allowDeselect", 3, false);
  function handleDefaultValue() {
    if (value() !== void 0) return;
    value($$props.type === "single" ? "" : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  let inputValue = state("");
  const rootState = SelectRootState.create({
    type: $$props.type,
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    disabled: boxWith(() => disabled()),
    required: boxWith(() => required()),
    open: boxWith(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    loop: boxWith(() => loop()),
    scrollAlignment: boxWith(() => scrollAlignment()),
    name: boxWith(() => name()),
    isCombobox: false,
    items: boxWith(() => items()),
    allowDeselect: boxWith(() => allowDeselect()),
    inputValue: boxWith(() => get(inputValue), (v) => set(inputValue, v, true)),
    onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
  });
  var fragment = root14();
  var node = first_child(fragment);
  Floating_layer(node, {
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      {
        var consequent = ($$anchor3) => {
          Select_hidden_input($$anchor3, {
            get autocomplete() {
              return $$props.autocomplete;
            }
          });
        };
        var alternate = ($$anchor3) => {
          var fragment_4 = comment();
          var node_4 = first_child(fragment_4);
          each(node_4, 16, () => rootState.opts.value.current, (item) => item, ($$anchor4, item) => {
            Select_hidden_input($$anchor4, {
              get value() {
                return item;
              },
              get autocomplete() {
                return $$props.autocomplete;
              }
            });
          });
          append($$anchor3, fragment_4);
        };
        if_block(node_3, ($$render) => {
          if (rootState.opts.value.current.length === 0) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_2);
    };
    var alternate_1 = ($$anchor2) => {
      Select_hidden_input($$anchor2, {
        get autocomplete() {
          return $$props.autocomplete;
        },
        get value() {
          return rootState.opts.value.current;
        },
        set value($$value) {
          rootState.opts.value.current = $$value;
        }
      });
    };
    if_block(node_2, ($$render) => {
      if (Array.isArray(rootState.opts.value.current)) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/select/components/select-trigger.svelte
var root_319 = from_html(`<button><!></button>`);
function Select_trigger($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "child",
    "children",
    "type"
  ]);
  const triggerState = SelectTriggerState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Anchor, ($$anchor2, $$component) => {
    $$component($$anchor2, {
      get id() {
        return id();
      },
      get ref() {
        return triggerState.opts.ref;
      },
      children: ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          };
          var alternate = ($$anchor4) => {
            var button = root_319();
            attribute_effect(button, () => ({ ...get(mergedProps) }));
            var node_3 = child(button);
            snippet(node_3, () => $$props.children ?? noop);
            reset(button);
            append($$anchor4, button);
          };
          if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_1);
      },
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/separator/exports.js
var exports_exports32 = {};
__export(exports_exports32, {
  Root: () => Separator
});

// node_modules/bits-ui/dist/bits/slider/exports.js
var exports_exports33 = {};
__export(exports_exports33, {
  Range: () => Slider_range,
  Root: () => Slider,
  Thumb: () => Slider_thumb,
  ThumbLabel: () => Slider_thumb_label,
  Tick: () => Slider_tick,
  TickLabel: () => Slider_tick_label
});

// node_modules/bits-ui/dist/bits/slider/helpers.js
function getRangeStyles(direction, min, max) {
  const styles = {
    position: "absolute"
  };
  if (direction === "lr") {
    styles.left = `${min}%`;
    styles.right = `${max}%`;
  } else if (direction === "rl") {
    styles.right = `${min}%`;
    styles.left = `${max}%`;
  } else if (direction === "bt") {
    styles.bottom = `${min}%`;
    styles.top = `${max}%`;
  } else {
    styles.top = `${min}%`;
    styles.bottom = `${max}%`;
  }
  return styles;
}
function getThumbStyles(direction, thumbPos) {
  const styles = {
    position: "absolute"
  };
  if (direction === "lr") {
    styles.left = `${thumbPos}%`;
    styles.translate = "-50% 0";
  } else if (direction === "rl") {
    styles.right = `${thumbPos}%`;
    styles.translate = "50% 0";
  } else if (direction === "bt") {
    styles.bottom = `${thumbPos}%`;
    styles.translate = "0 50%";
  } else {
    styles.top = `${thumbPos}%`;
    styles.translate = "0 -50%";
  }
  return styles;
}
function getTickStyles(direction, tickPosition, offsetPercentage) {
  const style = {
    position: "absolute"
  };
  if (direction === "lr") {
    style.left = `${tickPosition}%`;
    style.translate = `${offsetPercentage}% 0`;
  } else if (direction === "rl") {
    style.right = `${tickPosition}%`;
    style.translate = `${-offsetPercentage}% 0`;
  } else if (direction === "bt") {
    style.bottom = `${tickPosition}%`;
    style.translate = `0 ${-offsetPercentage}%`;
  } else {
    style.top = `${tickPosition}%`;
    style.translate = `0 ${offsetPercentage}%`;
  }
  return style;
}
function getTickLabelStyles(direction, tickPosition, labelPosition = "top") {
  const style = {
    position: "absolute"
  };
  if (direction === "lr" || direction === "rl") {
    style.left = direction === "lr" ? `${tickPosition}%` : void 0;
    style.right = direction === "rl" ? `${tickPosition}%` : void 0;
    style.translate = "-50% 0";
    if (labelPosition === "top") {
      style.bottom = "100%";
    } else if (labelPosition === "bottom") {
      style.top = "100%";
    }
  } else {
    if (direction === "tb") {
      style.top = `${tickPosition}%`;
    } else {
      style.bottom = `${tickPosition}%`;
    }
    style.translate = "0 50%";
    if (labelPosition === "left") {
      style.right = "100%";
    } else if (labelPosition === "right") {
      style.left = "100%";
    }
  }
  return style;
}
function getThumbLabelStyles(direction, thumbPosition, labelPosition = "top") {
  const style = {
    position: "absolute"
  };
  if (direction === "lr" || direction === "rl") {
    style.left = direction === "lr" ? `${thumbPosition}%` : void 0;
    style.right = direction === "rl" ? `${thumbPosition}%` : void 0;
    style.translate = "-50% 0";
    if (labelPosition === "top") {
      style.bottom = "100%";
    } else if (labelPosition === "bottom") {
      style.top = "100%";
    }
  } else {
    if (direction === "tb") {
      style.top = `${thumbPosition}%`;
    } else {
      style.bottom = `${thumbPosition}%`;
    }
    style.translate = "0 -50%";
    if (labelPosition === "left") {
      style.right = "100%";
    } else if (labelPosition === "right") {
      style.left = "100%";
    }
  }
  return style;
}
function getDecimalPlaces(num) {
  if (Math.floor(num) === num)
    return 0;
  const str = num.toString();
  if (str.indexOf(".") !== -1 && str.indexOf("e-") === -1) {
    return str.split(".")[1].length;
  } else if (str.indexOf("e-") !== -1) {
    const parts = str.split("e-");
    return parseInt(parts[1], 10);
  }
  return 0;
}
function roundToPrecision(num, precision) {
  const factor = Math.pow(10, precision);
  return Math.round(num * factor) / factor;
}
function normalizeSteps(step, min, max) {
  if (typeof step === "number") {
    const difference = max - min;
    let count = Math.ceil(difference / step);
    const precision = getDecimalPlaces(step);
    const factor = Math.pow(10, precision);
    const intDifference = Math.round(difference * factor);
    const intStep = Math.round(step * factor);
    if (intDifference % intStep === 0) {
      count++;
    }
    const steps = [];
    for (let i = 0; i < count; i++) {
      const value = min + i * step;
      const roundedValue = roundToPrecision(value, precision);
      steps.push(roundedValue);
    }
    return steps;
  }
  return [...new Set(step)].filter((value) => value >= min && value <= max).sort((a2, b) => a2 - b);
}
function snapValueToCustomSteps(value, steps) {
  if (steps.length === 0)
    return value;
  let closest = steps[0];
  let minDistance = Math.abs(value - closest);
  for (const step of steps) {
    const distance = Math.abs(value - step);
    if (distance < minDistance) {
      minDistance = distance;
      closest = step;
    }
  }
  return closest;
}
function getAdjacentStepValue(currentValue, steps, direction) {
  const currentIndex = steps.indexOf(currentValue);
  if (currentIndex === -1) {
    return snapValueToCustomSteps(currentValue, steps);
  }
  if (direction === "next") {
    return currentIndex < steps.length - 1 ? steps[currentIndex + 1] : currentValue;
  } else {
    return currentIndex > 0 ? steps[currentIndex - 1] : currentValue;
  }
}

// node_modules/bits-ui/dist/internal/math.js
function linearScale2(domain, range, clamp2 = true) {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  const slope = (r1 - r0) / (d1 - d0);
  return (x) => {
    const result = r0 + slope * (x - d0);
    if (!clamp2)
      return result;
    if (result > Math.max(r0, r1))
      return Math.max(r0, r1);
    if (result < Math.min(r0, r1))
      return Math.min(r0, r1);
    return result;
  };
}

// node_modules/bits-ui/dist/bits/slider/slider.svelte.js
var sliderAttrs = createBitsAttrs({
  component: "slider",
  parts: [
    "root",
    "thumb",
    "range",
    "tick",
    "tick-label",
    "thumb-label"
  ]
});
var SliderRootContext = new Context("Slider.Root");
var _isActive3, _direction, _normalizedSteps, _touchAction, _props134;
var SliderBaseRootState = class {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _isActive3, state(false));
    __privateAdd(this, _direction, user_derived(() => {
      if (this.opts.orientation.current === "horizontal") {
        return this.opts.dir.current === "rtl" ? "rl" : "lr";
      } else {
        return this.opts.dir.current === "rtl" ? "tb" : "bt";
      }
    }));
    __privateAdd(this, _normalizedSteps, user_derived(() => {
      return normalizeSteps(this.opts.step.current, this.opts.min.current, this.opts.max.current);
    }));
    __publicField(this, "domContext");
    __privateAdd(this, _touchAction, user_derived(() => {
      if (this.opts.disabled.current) return void 0;
      return this.opts.orientation.current === "horizontal" ? "pan-y" : "pan-x";
    }));
    __publicField(this, "getAllThumbs", () => {
      const node = this.opts.ref.current;
      if (!node) return [];
      return Array.from(node.querySelectorAll(sliderAttrs.selector("thumb")));
    });
    __publicField(this, "getThumbScale", () => {
      var _a, _b, _c;
      const trackPadding = (_a = this.opts.trackPadding) == null ? void 0 : _a.current;
      if (trackPadding !== void 0 && trackPadding > 0) {
        return [trackPadding, 100 - trackPadding];
      }
      if (this.opts.thumbPositioning.current === "exact") {
        return [0, 100];
      }
      const isVertical = this.opts.orientation.current === "vertical";
      const activeThumb = this.getAllThumbs()[0];
      const thumbSize = isVertical ? activeThumb == null ? void 0 : activeThumb.offsetHeight : activeThumb == null ? void 0 : activeThumb.offsetWidth;
      if (thumbSize === void 0 || Number.isNaN(thumbSize) || thumbSize === 0) return [0, 100];
      const trackSize = isVertical ? (_b = this.opts.ref.current) == null ? void 0 : _b.offsetHeight : (_c = this.opts.ref.current) == null ? void 0 : _c.offsetWidth;
      if (trackSize === void 0 || Number.isNaN(trackSize) || trackSize === 0) return [0, 100];
      const percentPadding = thumbSize / 2 / trackSize * 100;
      const min = percentPadding;
      const max = 100 - percentPadding;
      return [min, max];
    });
    __publicField(this, "getPositionFromValue", (thumbValue) => {
      const thumbScale = this.getThumbScale();
      const scale = linearScale2([this.opts.min.current, this.opts.max.current], thumbScale);
      return scale(thumbValue);
    });
    __privateAdd(this, _props134, user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": this.opts.orientation.current,
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      style: { touchAction: get(__privateGet(this, _touchAction)) },
      [sliderAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.domContext = new DOMContext(this.opts.ref);
  }
  get isActive() {
    return get(__privateGet(this, _isActive3));
  }
  set isActive(value) {
    set(__privateGet(this, _isActive3), value, true);
  }
  get direction() {
    return get(__privateGet(this, _direction));
  }
  set direction(value) {
    set(__privateGet(this, _direction), value);
  }
  get normalizedSteps() {
    return get(__privateGet(this, _normalizedSteps));
  }
  set normalizedSteps(value) {
    set(__privateGet(this, _normalizedSteps), value);
  }
  isThumbActive(_index) {
    return this.isActive;
  }
  get props() {
    return get(__privateGet(this, _props134));
  }
  set props(value) {
    set(__privateGet(this, _props134), value);
  }
};
_isActive3 = new WeakMap();
_direction = new WeakMap();
_normalizedSteps = new WeakMap();
_touchAction = new WeakMap();
_props134 = new WeakMap();
var _thumbsPropsArr, _thumbsRenderArr, _ticksPropsArr, _ticksRenderArr, _tickItemsArr, _thumbItemsArr, _snippetProps26;
var SliderSingleRootState = class extends SliderBaseRootState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", false);
    __publicField(this, "isTickValueSelected", (tickValue) => {
      return this.opts.value.current === tickValue;
    });
    __publicField(this, "updateValue", (newValue) => {
      this.opts.value.current = snapValueToCustomSteps(newValue, this.normalizedSteps);
    });
    __publicField(this, "handlePointerMove", (e) => {
      if (!this.isActive || this.opts.disabled.current) return;
      e.preventDefault();
      e.stopPropagation();
      const sliderNode = this.opts.ref.current;
      const activeThumb = this.getAllThumbs()[0];
      if (!sliderNode || !activeThumb) return;
      activeThumb.focus();
      const { left, right, top, bottom } = sliderNode.getBoundingClientRect();
      if (this.direction === "lr") {
        this.applyPosition({ clientXY: e.clientX, start: left, end: right });
      } else if (this.direction === "rl") {
        this.applyPosition({ clientXY: e.clientX, start: right, end: left });
      } else if (this.direction === "bt") {
        this.applyPosition({ clientXY: e.clientY, start: bottom, end: top });
      } else if (this.direction === "tb") {
        this.applyPosition({ clientXY: e.clientY, start: top, end: bottom });
      }
    });
    __publicField(this, "handlePointerDown", (e) => {
      if (e.button !== 0 || this.opts.disabled.current) return;
      const sliderNode = this.opts.ref.current;
      const closestThumb = this.getAllThumbs()[0];
      if (!closestThumb || !sliderNode) return;
      const target = e.composedPath()[0] ?? e.target;
      if (!isElementOrSVGElement(target) || !sliderNode.contains(target)) return;
      e.preventDefault();
      closestThumb.focus();
      this.isActive = true;
      this.handlePointerMove(e);
    });
    __publicField(this, "handlePointerUp", () => {
      if (this.opts.disabled.current) return;
      if (this.isActive) {
        this.opts.onValueCommit.current(untrack(() => this.opts.value.current));
      }
      this.isActive = false;
    });
    __privateAdd(this, _thumbsPropsArr, user_derived(() => {
      const currValue = this.opts.value.current;
      return Array.from({ length: 1 }, () => {
        const thumbValue = currValue;
        const thumbPosition = this.getPositionFromValue(thumbValue);
        const style = getThumbStyles(this.direction, thumbPosition);
        return {
          role: "slider",
          "aria-valuemin": this.opts.min.current,
          "aria-valuemax": this.opts.max.current,
          "aria-valuenow": thumbValue,
          "aria-disabled": boolToStr(this.opts.disabled.current),
          "aria-orientation": this.opts.orientation.current,
          "data-value": thumbValue,
          "data-orientation": this.opts.orientation.current,
          style,
          [sliderAttrs.thumb]: ""
        };
      });
    }));
    __privateAdd(this, _thumbsRenderArr, user_derived(() => {
      return this.thumbsPropsArr.map((_, i) => i);
    }));
    __privateAdd(this, _ticksPropsArr, user_derived(() => {
      const steps = this.normalizedSteps;
      const currValue = this.opts.value.current;
      return steps.map((tickValue, i) => {
        const tickPosition = this.getPositionFromValue(tickValue);
        const isFirst = i === 0;
        const isLast = i === steps.length - 1;
        const offsetPercentage = isFirst ? 0 : isLast ? -100 : -50;
        const style = getTickStyles(this.direction, tickPosition, offsetPercentage);
        const bounded = tickValue <= currValue;
        return {
          "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
          "data-orientation": this.opts.orientation.current,
          "data-bounded": bounded ? "" : void 0,
          "data-value": tickValue,
          "data-selected": this.isTickValueSelected(tickValue) ? "" : void 0,
          style,
          [sliderAttrs.tick]: ""
        };
      });
    }));
    __privateAdd(this, _ticksRenderArr, user_derived(() => {
      return this.ticksPropsArr.map((_, i) => i);
    }));
    __privateAdd(this, _tickItemsArr, user_derived(() => {
      return this.ticksPropsArr.map((tick2, i) => ({ value: tick2["data-value"], index: i }));
    }));
    __privateAdd(this, _thumbItemsArr, user_derived(() => {
      const currValue = this.opts.value.current;
      return [{ value: currValue, index: 0 }];
    }));
    __privateAdd(this, _snippetProps26, user_derived(() => ({
      ticks: this.ticksRenderArr,
      thumbs: this.thumbsRenderArr,
      tickItems: this.tickItemsArr,
      thumbItems: this.thumbItemsArr
    })));
    this.opts = opts;
    onMountEffect(() => {
      return executeCallbacks(on(this.domContext.getDocument(), "pointerdown", this.handlePointerDown), on(this.domContext.getDocument(), "pointerup", this.handlePointerUp), on(this.domContext.getDocument(), "pointermove", this.handlePointerMove), on(this.domContext.getDocument(), "pointerleave", this.handlePointerUp));
    });
    watch(
      [
        () => this.opts.step.current,
        () => this.opts.min.current,
        () => this.opts.max.current,
        () => this.opts.value.current
      ],
      ([step, min, max, value]) => {
        const steps = normalizeSteps(step, min, max);
        const isValidValue = (v) => {
          return steps.includes(v);
        };
        const gcv = (v) => {
          return snapValueToCustomSteps(v, steps);
        };
        if (!isValidValue(value)) {
          this.opts.value.current = gcv(value);
        }
      }
    );
  }
  applyPosition({ clientXY, start, end }) {
    const min = this.opts.min.current;
    const max = this.opts.max.current;
    const percent = (clientXY - start) / (end - start);
    const val = percent * (max - min) + min;
    if (val < min) {
      this.updateValue(min);
    } else if (val > max) {
      this.updateValue(max);
    } else {
      const steps = this.normalizedSteps;
      const newValue = snapValueToCustomSteps(val, steps);
      this.updateValue(newValue);
    }
  }
  get thumbsPropsArr() {
    return get(__privateGet(this, _thumbsPropsArr));
  }
  set thumbsPropsArr(value) {
    set(__privateGet(this, _thumbsPropsArr), value);
  }
  get thumbsRenderArr() {
    return get(__privateGet(this, _thumbsRenderArr));
  }
  set thumbsRenderArr(value) {
    set(__privateGet(this, _thumbsRenderArr), value);
  }
  get ticksPropsArr() {
    return get(__privateGet(this, _ticksPropsArr));
  }
  set ticksPropsArr(value) {
    set(__privateGet(this, _ticksPropsArr), value);
  }
  get ticksRenderArr() {
    return get(__privateGet(this, _ticksRenderArr));
  }
  set ticksRenderArr(value) {
    set(__privateGet(this, _ticksRenderArr), value);
  }
  get tickItemsArr() {
    return get(__privateGet(this, _tickItemsArr));
  }
  set tickItemsArr(value) {
    set(__privateGet(this, _tickItemsArr), value);
  }
  get thumbItemsArr() {
    return get(__privateGet(this, _thumbItemsArr));
  }
  set thumbItemsArr(value) {
    set(__privateGet(this, _thumbItemsArr), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps26));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps26), value);
  }
};
_thumbsPropsArr = new WeakMap();
_thumbsRenderArr = new WeakMap();
_ticksPropsArr = new WeakMap();
_ticksRenderArr = new WeakMap();
_tickItemsArr = new WeakMap();
_thumbItemsArr = new WeakMap();
_snippetProps26 = new WeakMap();
var _activeThumb, _currentThumbIdx, _getClosestThumb, _thumbsPropsArr2, _thumbsRenderArr2, _ticksPropsArr2, _ticksRenderArr2, _tickItemsArr2, _thumbItemsArr2, _snippetProps27;
var SliderMultiRootState = class extends SliderBaseRootState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", true);
    __privateAdd(this, _activeThumb, state(null));
    __privateAdd(this, _currentThumbIdx, state(0));
    __publicField(this, "isTickValueSelected", (tickValue) => {
      return this.opts.value.current.includes(tickValue);
    });
    __privateAdd(this, _getClosestThumb, (e) => {
      const thumbs = this.getAllThumbs();
      if (!thumbs.length) return;
      for (const thumb of thumbs) {
        thumb.blur();
      }
      const distances = thumbs.map((thumb) => {
        if (this.opts.orientation.current === "horizontal") {
          const { left, right } = thumb.getBoundingClientRect();
          return Math.abs(e.clientX - (left + right) / 2);
        } else {
          const { top, bottom } = thumb.getBoundingClientRect();
          return Math.abs(e.clientY - (top + bottom) / 2);
        }
      });
      const node = thumbs[distances.indexOf(Math.min(...distances))];
      const idx = thumbs.indexOf(node);
      return { node, idx };
    });
    __publicField(this, "handlePointerMove", (e) => {
      if (!this.isActive || this.opts.disabled.current) return;
      e.preventDefault();
      e.stopPropagation();
      const sliderNode = this.opts.ref.current;
      const activeThumb = this.activeThumb;
      if (!sliderNode || !activeThumb) return;
      activeThumb.node.focus();
      const { left, right, top, bottom } = sliderNode.getBoundingClientRect();
      const direction = this.direction;
      if (direction === "lr") {
        this.applyPosition({
          clientXY: e.clientX,
          activeThumbIdx: activeThumb.idx,
          start: left,
          end: right
        });
      } else if (direction === "rl") {
        this.applyPosition({
          clientXY: e.clientX,
          activeThumbIdx: activeThumb.idx,
          start: right,
          end: left
        });
      } else if (direction === "bt") {
        this.applyPosition({
          clientXY: e.clientY,
          activeThumbIdx: activeThumb.idx,
          start: bottom,
          end: top
        });
      } else if (direction === "tb") {
        this.applyPosition({
          clientXY: e.clientY,
          activeThumbIdx: activeThumb.idx,
          start: top,
          end: bottom
        });
      }
    });
    __publicField(this, "handlePointerDown", (e) => {
      if (e.button !== 0 || this.opts.disabled.current) return;
      const sliderNode = this.opts.ref.current;
      const closestThumb = __privateGet(this, _getClosestThumb).call(this, e);
      if (!closestThumb || !sliderNode) return;
      const target = e.composedPath()[0] ?? e.target;
      if (!isElementOrSVGElement(target) || !sliderNode.contains(target)) return;
      e.preventDefault();
      this.activeThumb = closestThumb;
      closestThumb.node.focus();
      this.isActive = true;
      this.handlePointerMove(e);
    });
    __publicField(this, "handlePointerUp", () => {
      if (this.opts.disabled.current) return;
      if (this.isActive) {
        this.opts.onValueCommit.current(untrack(() => this.opts.value.current));
      }
      this.isActive = false;
    });
    __publicField(this, "getAllThumbs", () => {
      const node = this.opts.ref.current;
      if (!node) return [];
      const thumbs = Array.from(node.querySelectorAll(sliderAttrs.selector("thumb")));
      return thumbs;
    });
    __publicField(this, "updateValue", (thumbValue, idx) => {
      const currValue = this.opts.value.current;
      if (!currValue.length) {
        this.opts.value.current.push(thumbValue);
        return;
      }
      const valueAtIndex = currValue[idx];
      if (valueAtIndex === thumbValue) return;
      const newValue = [...currValue];
      if (!isValidIndex(idx, newValue)) return;
      const direction = newValue[idx] > thumbValue ? -1 : 1;
      const swap = () => {
        var _a;
        const diffIndex = idx + direction;
        newValue[idx] = newValue[diffIndex];
        newValue[diffIndex] = thumbValue;
        const thumbs = this.getAllThumbs();
        if (!thumbs.length) return;
        (_a = thumbs[diffIndex]) == null ? void 0 : _a.focus();
        this.activeThumb = { node: thumbs[diffIndex], idx: diffIndex };
      };
      if (this.opts.autoSort.current && (direction === -1 && thumbValue < newValue[idx - 1] || direction === 1 && thumbValue > newValue[idx + 1])) {
        swap();
        this.opts.value.current = newValue;
        return;
      }
      const steps = this.normalizedSteps;
      newValue[idx] = snapValueToCustomSteps(thumbValue, steps);
      this.opts.value.current = newValue;
    });
    __privateAdd(this, _thumbsPropsArr2, user_derived(() => {
      const currValue = this.opts.value.current;
      return Array.from({ length: currValue.length || 1 }, (_, i) => {
        const currThumb = untrack(() => this.currentThumbIdx);
        if (currThumb < currValue.length) {
          untrack(() => {
            this.currentThumbIdx = currThumb + 1;
          });
        }
        const thumbValue = currValue[i];
        const thumbPosition = this.getPositionFromValue(thumbValue ?? 0);
        const style = getThumbStyles(this.direction, thumbPosition);
        return {
          role: "slider",
          "aria-valuemin": this.opts.min.current,
          "aria-valuemax": this.opts.max.current,
          "aria-valuenow": thumbValue,
          "aria-disabled": boolToStr(this.opts.disabled.current),
          "aria-orientation": this.opts.orientation.current,
          "data-value": thumbValue,
          "data-orientation": this.opts.orientation.current,
          style,
          [sliderAttrs.thumb]: ""
        };
      });
    }));
    __privateAdd(this, _thumbsRenderArr2, user_derived(() => {
      return this.thumbsPropsArr.map((_, i) => i);
    }));
    __privateAdd(this, _ticksPropsArr2, user_derived(() => {
      const steps = this.normalizedSteps;
      const currValue = this.opts.value.current;
      return steps.map((tickValue, i) => {
        const tickPosition = this.getPositionFromValue(tickValue);
        const isFirst = i === 0;
        const isLast = i === steps.length - 1;
        const offsetPercentage = isFirst ? 0 : isLast ? -100 : -50;
        const style = getTickStyles(this.direction, tickPosition, offsetPercentage);
        const bounded = currValue.length === 1 ? tickValue <= currValue[0] : currValue[0] <= tickValue && tickValue <= currValue[currValue.length - 1];
        return {
          "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
          "data-orientation": this.opts.orientation.current,
          "data-bounded": bounded ? "" : void 0,
          "data-value": tickValue,
          style,
          [sliderAttrs.tick]: ""
        };
      });
    }));
    __privateAdd(this, _ticksRenderArr2, user_derived(() => {
      return this.ticksPropsArr.map((_, i) => i);
    }));
    __privateAdd(this, _tickItemsArr2, user_derived(() => {
      return this.ticksPropsArr.map((tick2, i) => ({ value: tick2["data-value"], index: i }));
    }));
    __privateAdd(this, _thumbItemsArr2, user_derived(() => {
      const currValue = this.opts.value.current;
      return currValue.map((value, index) => ({ value, index }));
    }));
    __privateAdd(this, _snippetProps27, user_derived(() => ({
      ticks: this.ticksRenderArr,
      thumbs: this.thumbsRenderArr,
      tickItems: this.tickItemsArr,
      thumbItems: this.thumbItemsArr
    })));
    this.opts = opts;
    onMountEffect(() => {
      return executeCallbacks(on(this.domContext.getDocument(), "pointerdown", this.handlePointerDown), on(this.domContext.getDocument(), "pointerup", this.handlePointerUp), on(this.domContext.getDocument(), "pointermove", this.handlePointerMove), on(this.domContext.getDocument(), "pointerleave", this.handlePointerUp));
    });
    watch(
      [
        () => this.opts.step.current,
        () => this.opts.min.current,
        () => this.opts.max.current,
        () => this.opts.value.current
      ],
      ([step, min, max, value]) => {
        const steps = normalizeSteps(step, min, max);
        const isValidValue = (v) => {
          return steps.includes(v);
        };
        const gcv = (v) => {
          return snapValueToCustomSteps(v, steps);
        };
        if (value.some((v) => !isValidValue(v))) {
          this.opts.value.current = value.map(gcv);
        }
      }
    );
  }
  get activeThumb() {
    return get(__privateGet(this, _activeThumb));
  }
  set activeThumb(value) {
    set(__privateGet(this, _activeThumb), value, true);
  }
  get currentThumbIdx() {
    return get(__privateGet(this, _currentThumbIdx));
  }
  set currentThumbIdx(value) {
    set(__privateGet(this, _currentThumbIdx), value, true);
  }
  isThumbActive(index) {
    var _a;
    return this.isActive && ((_a = this.activeThumb) == null ? void 0 : _a.idx) === index;
  }
  applyPosition({ clientXY, activeThumbIdx, start, end }) {
    const min = this.opts.min.current;
    const max = this.opts.max.current;
    const percent = (clientXY - start) / (end - start);
    const val = percent * (max - min) + min;
    if (val < min) {
      this.updateValue(min, activeThumbIdx);
    } else if (val > max) {
      this.updateValue(max, activeThumbIdx);
    } else {
      const steps = this.normalizedSteps;
      const newValue = snapValueToCustomSteps(val, steps);
      this.updateValue(newValue, activeThumbIdx);
    }
  }
  get thumbsPropsArr() {
    return get(__privateGet(this, _thumbsPropsArr2));
  }
  set thumbsPropsArr(value) {
    set(__privateGet(this, _thumbsPropsArr2), value);
  }
  get thumbsRenderArr() {
    return get(__privateGet(this, _thumbsRenderArr2));
  }
  set thumbsRenderArr(value) {
    set(__privateGet(this, _thumbsRenderArr2), value);
  }
  get ticksPropsArr() {
    return get(__privateGet(this, _ticksPropsArr2));
  }
  set ticksPropsArr(value) {
    set(__privateGet(this, _ticksPropsArr2), value);
  }
  get ticksRenderArr() {
    return get(__privateGet(this, _ticksRenderArr2));
  }
  set ticksRenderArr(value) {
    set(__privateGet(this, _ticksRenderArr2), value);
  }
  get tickItemsArr() {
    return get(__privateGet(this, _tickItemsArr2));
  }
  set tickItemsArr(value) {
    set(__privateGet(this, _tickItemsArr2), value);
  }
  get thumbItemsArr() {
    return get(__privateGet(this, _thumbItemsArr2));
  }
  set thumbItemsArr(value) {
    set(__privateGet(this, _thumbItemsArr2), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps27));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps27), value);
  }
};
_activeThumb = new WeakMap();
_currentThumbIdx = new WeakMap();
_getClosestThumb = new WeakMap();
_thumbsPropsArr2 = new WeakMap();
_thumbsRenderArr2 = new WeakMap();
_ticksPropsArr2 = new WeakMap();
_ticksRenderArr2 = new WeakMap();
_tickItemsArr2 = new WeakMap();
_thumbItemsArr2 = new WeakMap();
_snippetProps27 = new WeakMap();
var SliderRootState = class {
  static create(opts) {
    const { type, ...rest } = opts;
    const rootState = type === "single" ? new SliderSingleRootState(rest) : new SliderMultiRootState(rest);
    return SliderRootContext.set(rootState);
  }
};
var VALID_SLIDER_KEYS = [
  kbd_constants_exports.ARROW_LEFT,
  kbd_constants_exports.ARROW_RIGHT,
  kbd_constants_exports.ARROW_UP,
  kbd_constants_exports.ARROW_DOWN,
  kbd_constants_exports.HOME,
  kbd_constants_exports.END
];
var _rangeStyles, _props135;
var _SliderRangeState = class _SliderRangeState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _rangeStyles, user_derived(() => {
      var _a;
      if (Array.isArray(this.root.opts.value.current)) {
        const min = this.root.opts.value.current.length > 1 ? this.root.getPositionFromValue(Math.min(...this.root.opts.value.current) ?? 0) : 0;
        const max = 100 - this.root.getPositionFromValue(Math.max(...this.root.opts.value.current) ?? 0);
        return {
          position: "absolute",
          ...getRangeStyles(this.root.direction, min, max)
        };
      } else {
        const trackPadding = (_a = this.root.opts.trackPadding) == null ? void 0 : _a.current;
        const currentValue = this.root.opts.value.current;
        const maxValue = this.root.opts.max.current;
        const min = 0;
        const max = trackPadding !== void 0 && trackPadding > 0 && currentValue === maxValue ? 0 : 100 - this.root.getPositionFromValue(currentValue);
        return {
          position: "absolute",
          ...getRangeStyles(this.root.direction, min, max)
        };
      }
    }));
    __privateAdd(this, _props135, user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": this.root.opts.orientation.current,
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      style: this.rangeStyles,
      [sliderAttrs.range]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _SliderRangeState(opts, SliderRootContext.get());
  }
  get rangeStyles() {
    return get(__privateGet(this, _rangeStyles));
  }
  set rangeStyles(value) {
    set(__privateGet(this, _rangeStyles), value);
  }
  get props() {
    return get(__privateGet(this, _props135));
  }
  set props(value) {
    set(__privateGet(this, _props135), value);
  }
};
_rangeStyles = new WeakMap();
_props135 = new WeakMap();
var SliderRangeState = _SliderRangeState;
var _isDisabled13, _SliderThumbState_instances, updateValue_fn3, _props136;
var _SliderThumbState = class _SliderThumbState {
  constructor(opts, root18) {
    __privateAdd(this, _SliderThumbState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled13, user_derived(() => this.root.opts.disabled.current || this.opts.disabled.current));
    __privateAdd(this, _props136, user_derived(() => ({
      ...this.root.thumbsPropsArr[this.opts.index.current],
      id: this.opts.id.current,
      onkeydown: this.onkeydown,
      "data-active": this.root.isThumbActive(this.opts.index.current) ? "" : void 0,
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current || this.root.opts.disabled.current),
      tabindex: this.opts.disabled.current || this.root.opts.disabled.current ? -1 : 0,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _SliderThumbState(opts, SliderRootContext.get());
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled13))) return;
    const currNode = this.opts.ref.current;
    if (!currNode) return;
    const thumbs = this.root.getAllThumbs();
    if (!thumbs.length) return;
    const idx = thumbs.indexOf(currNode);
    if (this.root.isMulti) {
      this.root.currentThumbIdx = idx;
    }
    if (!VALID_SLIDER_KEYS.includes(e.key)) return;
    e.preventDefault();
    const min = this.root.opts.min.current;
    const max = this.root.opts.max.current;
    const value = this.root.opts.value.current;
    const thumbValue = Array.isArray(value) ? value[idx] : value;
    const orientation = this.root.opts.orientation.current;
    const direction = this.root.direction;
    const steps = this.root.normalizedSteps;
    switch (e.key) {
      case kbd_constants_exports.HOME:
        __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, min);
        break;
      case kbd_constants_exports.END:
        __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, max);
        break;
      case kbd_constants_exports.ARROW_LEFT:
        if (orientation !== "horizontal") break;
        if (e.metaKey) {
          const newValue = direction === "rl" ? max : min;
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        } else {
          const stepDirection = direction === "rl" ? "next" : "prev";
          const newValue = getAdjacentStepValue(thumbValue, steps, stepDirection);
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        }
        break;
      case kbd_constants_exports.ARROW_RIGHT:
        if (orientation !== "horizontal") break;
        if (e.metaKey) {
          const newValue = direction === "rl" ? min : max;
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        } else {
          const stepDirection = direction === "rl" ? "prev" : "next";
          const newValue = getAdjacentStepValue(thumbValue, steps, stepDirection);
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        }
        break;
      case kbd_constants_exports.ARROW_UP:
        if (e.metaKey) {
          const newValue = direction === "tb" ? min : max;
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        } else {
          const stepDirection = direction === "tb" ? "prev" : "next";
          const newValue = getAdjacentStepValue(thumbValue, steps, stepDirection);
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        }
        break;
      case kbd_constants_exports.ARROW_DOWN:
        if (e.metaKey) {
          const newValue = direction === "tb" ? max : min;
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        } else {
          const stepDirection = direction === "tb" ? "next" : "prev";
          const newValue = getAdjacentStepValue(thumbValue, steps, stepDirection);
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        }
        break;
    }
    this.root.opts.onValueCommit.current(this.root.opts.value.current);
  }
  get props() {
    return get(__privateGet(this, _props136));
  }
  set props(value) {
    set(__privateGet(this, _props136), value);
  }
};
_isDisabled13 = new WeakMap();
_SliderThumbState_instances = new WeakSet();
updateValue_fn3 = function(newValue) {
  if (this.root.isMulti) {
    this.root.updateValue(newValue, this.opts.index.current);
  } else {
    this.root.updateValue(newValue);
  }
};
_props136 = new WeakMap();
var SliderThumbState = _SliderThumbState;
var _props137;
var _SliderTickState = class _SliderTickState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props137, user_derived(() => ({
      ...this.root.ticksPropsArr[this.opts.index.current],
      id: this.opts.id.current,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _SliderTickState(opts, SliderRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props137));
  }
  set props(value) {
    set(__privateGet(this, _props137), value);
  }
};
_props137 = new WeakMap();
var SliderTickState = _SliderTickState;
var _props138;
var _SliderTickLabelState = class _SliderTickLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props138, user_derived(() => {
      var _a;
      const tickProps = this.root.ticksPropsArr[this.opts.index.current];
      const steps = this.root.normalizedSteps;
      const tickValue = steps[this.opts.index.current];
      const tickPosition = this.root.getPositionFromValue(tickValue);
      const labelPosition = ((_a = this.opts.position) == null ? void 0 : _a.current) ?? "top";
      const style = getTickLabelStyles(this.root.direction, tickPosition, labelPosition);
      return {
        id: this.opts.id.current,
        "data-orientation": this.root.opts.orientation.current,
        "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
        "data-bounded": tickProps["data-bounded"],
        "data-value": tickValue,
        "data-selected": this.root.isTickValueSelected(tickValue) ? "" : void 0,
        "data-position": labelPosition,
        style,
        [sliderAttrs["tick-label"]]: "",
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _SliderTickLabelState(opts, SliderRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props138));
  }
  set props(value) {
    set(__privateGet(this, _props138), value);
  }
};
_props138 = new WeakMap();
var SliderTickLabelState = _SliderTickLabelState;
var _props139;
var _SliderThumbLabelState = class _SliderThumbLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props139, user_derived(() => {
      var _a;
      const value = this.root.opts.value.current;
      const thumbValue = Array.isArray(value) ? value[this.opts.index.current] : value;
      const thumbPosition = this.root.getPositionFromValue(thumbValue);
      const labelPosition = ((_a = this.opts.position) == null ? void 0 : _a.current) ?? "top";
      const style = getThumbLabelStyles(this.root.direction, thumbPosition, labelPosition);
      return {
        id: this.opts.id.current,
        "data-orientation": this.root.opts.orientation.current,
        "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
        "data-value": thumbValue,
        "data-active": this.root.isThumbActive(this.opts.index.current) ? "" : void 0,
        "data-position": labelPosition,
        style,
        [sliderAttrs["thumb-label"]]: "",
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _SliderThumbLabelState(opts, SliderRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props139));
  }
  set props(value) {
    set(__privateGet(this, _props139), value);
  }
};
_props139 = new WeakMap();
var SliderThumbLabelState = _SliderThumbLabelState;

// node_modules/bits-ui/dist/bits/slider/components/slider.svelte
var root_298 = from_html(`<span><!></span>`);
function Slider($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), onValueCommit = prop($$props, "onValueCommit", 3, noop3), disabled = prop($$props, "disabled", 3, false), step = prop($$props, "step", 3, 1), dir = prop($$props, "dir", 3, "ltr"), autoSort = prop($$props, "autoSort", 3, true), orientation = prop($$props, "orientation", 3, "horizontal"), thumbPositioning = prop($$props, "thumbPositioning", 3, "contain"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "value",
    "type",
    "onValueChange",
    "onValueCommit",
    "disabled",
    "min",
    "max",
    "step",
    "dir",
    "autoSort",
    "orientation",
    "thumbPositioning",
    "trackPadding"
  ]);
  const min = user_derived(() => {
    if ($$props.min !== void 0) return $$props.min;
    if (Array.isArray(step())) return Math.min(...step());
    return 0;
  });
  const max = user_derived(() => {
    if ($$props.max !== void 0) return $$props.max;
    if (Array.isArray(step())) return Math.max(...step());
    return 100;
  });
  function handleDefaultValue() {
    if (value() !== void 0) return;
    if ($$props.type === "single") {
      return get(min);
    }
    return [];
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = SliderRootState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    // @ts-expect-error - we know
    onValueCommit: boxWith(() => onValueCommit()),
    disabled: boxWith(() => disabled()),
    min: boxWith(() => get(min)),
    max: boxWith(() => get(max)),
    step: boxWith(() => step()),
    dir: boxWith(() => dir()),
    autoSort: boxWith(() => autoSort()),
    orientation: boxWith(() => orientation()),
    thumbPositioning: boxWith(() => thumbPositioning()),
    type: $$props.type,
    trackPadding: boxWith(() => $$props.trackPadding)
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_298();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/slider/components/slider-range.svelte
var root_299 = from_html(`<span><!></span>`);
function Slider_range($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id"
  ]);
  const rangeState = SliderRangeState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rangeState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_299();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/slider/components/slider-thumb.svelte
var root_2100 = from_html(`<span><!></span>`);
function Slider_thumb($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id",
    "index",
    "disabled"
  ]);
  const thumbState = SliderThumbState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    index: boxWith(() => $$props.index),
    disabled: boxWith(() => disabled())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, thumbState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        active: thumbState.root.isThumbActive(thumbState.opts.index.current),
        props: get(mergedProps)
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2100();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      var render_arg_1 = derived_safe_equal(() => ({
        active: thumbState.root.isThumbActive(thumbState.opts.index.current)
      }));
      snippet(node_2, () => $$props.children ?? noop, () => get(render_arg_1));
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/slider/components/slider-tick.svelte
var root_2101 = from_html(`<span><!></span>`);
function Slider_tick($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id",
    "index"
  ]);
  const tickState = SliderTickState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    index: boxWith(() => $$props.index)
  });
  const mergedProps = user_derived(() => mergeProps(restProps, tickState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2101();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/slider/components/slider-tick-label.svelte
var root_320 = from_html(`<span><!></span>`);
function Slider_tick_label($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id",
    "index",
    "position"
  ]);
  const root18 = SliderRootContext.get();
  const position = user_derived(() => {
    if ($$props.position !== void 0) return $$props.position;
    switch (root18.direction) {
      case "lr":
      case "rl":
        return "top";
      case "tb":
      case "bt":
        return "left";
    }
  });
  const tickLabelState = SliderTickLabelState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    index: boxWith(() => $$props.index),
    position: boxWith(() => get(position))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, tickLabelState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_320();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/slider/components/slider-thumb-label.svelte
var root_321 = from_html(`<span><!></span>`);
function Slider_thumb_label($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "id",
    "index",
    "position"
  ]);
  const root18 = SliderRootContext.get();
  const position = user_derived(() => {
    if ($$props.position !== void 0) return $$props.position;
    switch (root18.direction) {
      case "lr":
      case "rl":
        return "top";
      case "tb":
      case "bt":
        return "left";
    }
  });
  const tickLabelState = SliderThumbLabelState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    index: boxWith(() => $$props.index),
    position: boxWith(() => get(position))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, tickLabelState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_321();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/switch/exports.js
var exports_exports34 = {};
__export(exports_exports34, {
  Root: () => Switch,
  Thumb: () => Switch_thumb
});

// node_modules/bits-ui/dist/bits/switch/switch.svelte.js
var switchAttrs = createBitsAttrs({
  component: "switch",
  parts: ["root", "thumb"]
});
var SwitchRootContext = new Context("Switch.Root");
var _SwitchRootState_instances, toggle_fn2, _sharedProps2, _snippetProps28, _props140;
var _SwitchRootState = class _SwitchRootState {
  constructor(opts) {
    __privateAdd(this, _SwitchRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _sharedProps2, user_derived(() => ({
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      "data-state": getDataChecked(this.opts.checked.current),
      "data-required": boolToEmptyStrOrUndef(this.opts.required.current)
    })));
    __privateAdd(this, _snippetProps28, user_derived(() => ({ checked: this.opts.checked.current })));
    __privateAdd(this, _props140, user_derived(() => ({
      ...this.sharedProps,
      id: this.opts.id.current,
      role: "switch",
      disabled: boolToTrueOrUndef(this.opts.disabled.current),
      "aria-checked": getAriaChecked(this.opts.checked.current, false),
      "aria-required": boolToStr(this.opts.required.current),
      [switchAttrs.root]: "",
      //
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onclick = this.onclick.bind(this);
  }
  static create(opts) {
    return SwitchRootContext.set(new _SwitchRootState(opts));
  }
  onkeydown(e) {
    if (!(e.key === kbd_constants_exports.ENTER || e.key === kbd_constants_exports.SPACE) || this.opts.disabled.current) return;
    e.preventDefault();
    __privateMethod(this, _SwitchRootState_instances, toggle_fn2).call(this);
  }
  onclick(_) {
    if (this.opts.disabled.current) return;
    __privateMethod(this, _SwitchRootState_instances, toggle_fn2).call(this);
  }
  get sharedProps() {
    return get(__privateGet(this, _sharedProps2));
  }
  set sharedProps(value) {
    set(__privateGet(this, _sharedProps2), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps28));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps28), value);
  }
  get props() {
    return get(__privateGet(this, _props140));
  }
  set props(value) {
    set(__privateGet(this, _props140), value);
  }
};
_SwitchRootState_instances = new WeakSet();
toggle_fn2 = function() {
  this.opts.checked.current = !this.opts.checked.current;
};
_sharedProps2 = new WeakMap();
_snippetProps28 = new WeakMap();
_props140 = new WeakMap();
var SwitchRootState = _SwitchRootState;
var _shouldRender12, _props141;
var _SwitchInputState = class _SwitchInputState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _shouldRender12, user_derived(() => this.root.opts.name.current !== void 0));
    __privateAdd(this, _props141, user_derived(() => ({
      type: "checkbox",
      name: this.root.opts.name.current,
      value: this.root.opts.value.current,
      checked: this.root.opts.checked.current,
      disabled: this.root.opts.disabled.current,
      required: this.root.opts.required.current
    })));
    this.root = root18;
  }
  static create() {
    return new _SwitchInputState(SwitchRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender12));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender12), value);
  }
  get props() {
    return get(__privateGet(this, _props141));
  }
  set props(value) {
    set(__privateGet(this, _props141), value);
  }
};
_shouldRender12 = new WeakMap();
_props141 = new WeakMap();
var SwitchInputState = _SwitchInputState;
var _snippetProps29, _props142;
var _SwitchThumbState = class _SwitchThumbState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps29, user_derived(() => ({ checked: this.root.opts.checked.current })));
    __privateAdd(this, _props142, user_derived(() => ({
      ...this.root.sharedProps,
      id: this.opts.id.current,
      [switchAttrs.thumb]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _SwitchThumbState(opts, SwitchRootContext.get());
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps29));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps29), value);
  }
  get props() {
    return get(__privateGet(this, _props142));
  }
  set props(value) {
    set(__privateGet(this, _props142), value);
  }
};
_snippetProps29 = new WeakMap();
_props142 = new WeakMap();
var SwitchThumbState = _SwitchThumbState;

// node_modules/bits-ui/dist/bits/switch/components/switch-input.svelte
function Switch_input($$anchor, $$props) {
  push($$props, false);
  const inputState = SwitchInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Hidden_input($$anchor2, spread_props(() => inputState.props));
    };
    if_block(node, ($$render) => {
      if (inputState.shouldRender) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/switch/components/switch.svelte
var root_2102 = from_html(`<button><!></button>`);
var root15 = from_html(`<!> <!>`, 1);
function Switch($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), required = prop($$props, "required", 3, false), checked = prop($$props, "checked", 15, false), value = prop($$props, "value", 3, "on"), name = prop($$props, "name", 3, void 0), type = prop($$props, "type", 3, "button"), onCheckedChange = prop($$props, "onCheckedChange", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "ref",
    "id",
    "disabled",
    "required",
    "checked",
    "value",
    "name",
    "type",
    "onCheckedChange"
  ]);
  const rootState = SwitchRootState.create({
    checked: boxWith(() => checked(), (v) => {
      var _a;
      checked(v);
      (_a = onCheckedChange()) == null ? void 0 : _a(v);
    }),
    disabled: boxWith(() => disabled() ?? false),
    required: boxWith(() => required()),
    value: boxWith(() => value()),
    name: boxWith(() => name()),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props, { type: type() }));
  var fragment = root15();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2102();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  Switch_input(node_3, {});
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/switch/components/switch-thumb.svelte
var root_2103 = from_html(`<span><!></span>`);
function Switch_thumb($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "ref",
    "id"
  ]);
  const thumbState = SwitchThumbState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, thumbState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...thumbState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2103();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop, () => thumbState.snippetProps);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/tabs/exports.js
var exports_exports35 = {};
__export(exports_exports35, {
  Content: () => Tabs_content,
  List: () => Tabs_list,
  Root: () => Tabs,
  Trigger: () => Tabs_trigger
});

// node_modules/bits-ui/dist/bits/tabs/tabs.svelte.js
var tabsAttrs = createBitsAttrs({
  component: "tabs",
  parts: ["root", "list", "trigger", "content"]
});
var TabsRootContext = new Context("Tabs.Root");
var _triggerIds2, _props143;
var _TabsRootState = class _TabsRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __publicField(this, "rovingFocusGroup");
    __privateAdd(this, _triggerIds2, state(proxy([])));
    // holds the trigger ID for each value to associate it with the content
    __publicField(this, "valueToTriggerId", new SvelteMap());
    // holds the content ID for each value to associate it with the trigger
    __publicField(this, "valueToContentId", new SvelteMap());
    __privateAdd(this, _props143, user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": this.opts.orientation.current,
      [tabsAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      candidateAttr: tabsAttrs.trigger,
      rootNode: this.opts.ref,
      loop: this.opts.loop,
      orientation: this.opts.orientation
    });
  }
  static create(opts) {
    return TabsRootContext.set(new _TabsRootState(opts));
  }
  get triggerIds() {
    return get(__privateGet(this, _triggerIds2));
  }
  set triggerIds(value) {
    set(__privateGet(this, _triggerIds2), value, true);
  }
  registerTrigger(id, value) {
    this.triggerIds.push(id);
    this.valueToTriggerId.set(value, id);
    return () => {
      this.triggerIds = this.triggerIds.filter((triggerId) => triggerId !== id);
      this.valueToTriggerId.delete(value);
    };
  }
  registerContent(id, value) {
    this.valueToContentId.set(value, id);
    return () => {
      this.valueToContentId.delete(value);
    };
  }
  setValue(v) {
    this.opts.value.current = v;
  }
  get props() {
    return get(__privateGet(this, _props143));
  }
  set props(value) {
    set(__privateGet(this, _props143), value);
  }
};
_triggerIds2 = new WeakMap();
_props143 = new WeakMap();
var TabsRootState = _TabsRootState;
var _isDisabled14, _props144;
var _TabsListState = class _TabsListState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled14, user_derived(() => this.root.opts.disabled.current));
    __privateAdd(this, _props144, user_derived(() => ({
      id: this.opts.id.current,
      role: "tablist",
      "aria-orientation": this.root.opts.orientation.current,
      "data-orientation": this.root.opts.orientation.current,
      [tabsAttrs.list]: "",
      "data-disabled": boolToEmptyStrOrUndef(get(__privateGet(this, _isDisabled14))),
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _TabsListState(opts, TabsRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props144));
  }
  set props(value) {
    set(__privateGet(this, _props144), value);
  }
};
_isDisabled14 = new WeakMap();
_props144 = new WeakMap();
var TabsListState = _TabsListState;
var _tabIndex3, _isActive4, _isDisabled15, _ariaControls2, _TabsTriggerState_instances, activate_fn, _props145;
var _TabsTriggerState = class _TabsTriggerState {
  constructor(opts, root18) {
    __privateAdd(this, _TabsTriggerState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _tabIndex3, state(0));
    __privateAdd(this, _isActive4, user_derived(() => this.root.opts.value.current === this.opts.value.current));
    __privateAdd(this, _isDisabled15, user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current));
    __privateAdd(this, _ariaControls2, user_derived(() => this.root.valueToContentId.get(this.opts.value.current)));
    __privateAdd(this, _props145, user_derived(() => ({
      id: this.opts.id.current,
      role: "tab",
      "data-state": getTabDataState(get(__privateGet(this, _isActive4))),
      "data-value": this.opts.value.current,
      "data-orientation": this.root.opts.orientation.current,
      "data-disabled": boolToEmptyStrOrUndef(get(__privateGet(this, _isDisabled15))),
      "aria-selected": boolToStr(get(__privateGet(this, _isActive4))),
      "aria-controls": get(__privateGet(this, _ariaControls2)),
      [tabsAttrs.trigger]: "",
      disabled: boolToTrueOrUndef(get(__privateGet(this, _isDisabled15))),
      tabindex: get(__privateGet(this, _tabIndex3)),
      //
      onclick: this.onclick,
      onfocus: this.onfocus,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    watch(
      [
        () => this.opts.id.current,
        () => this.opts.value.current
      ],
      ([id, value]) => {
        return this.root.registerTrigger(id, value);
      }
    );
    user_effect(() => {
      this.root.triggerIds.length;
      if (get(__privateGet(this, _isActive4)) || !this.root.opts.value.current) {
        set(__privateGet(this, _tabIndex3), 0);
      } else {
        set(__privateGet(this, _tabIndex3), -1);
      }
    });
    this.onfocus = this.onfocus.bind(this);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _TabsTriggerState(opts, TabsRootContext.get());
  }
  onfocus(_) {
    if (this.root.opts.activationMode.current !== "automatic" || get(__privateGet(this, _isDisabled15))) return;
    __privateMethod(this, _TabsTriggerState_instances, activate_fn).call(this);
  }
  onclick(_) {
    if (get(__privateGet(this, _isDisabled15))) return;
    __privateMethod(this, _TabsTriggerState_instances, activate_fn).call(this);
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled15))) return;
    if (e.key === kbd_constants_exports.SPACE || e.key === kbd_constants_exports.ENTER) {
      e.preventDefault();
      __privateMethod(this, _TabsTriggerState_instances, activate_fn).call(this);
      return;
    }
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  get props() {
    return get(__privateGet(this, _props145));
  }
  set props(value) {
    set(__privateGet(this, _props145), value);
  }
};
_tabIndex3 = new WeakMap();
_isActive4 = new WeakMap();
_isDisabled15 = new WeakMap();
_ariaControls2 = new WeakMap();
_TabsTriggerState_instances = new WeakSet();
activate_fn = function() {
  if (this.root.opts.value.current === this.opts.value.current) return;
  this.root.setValue(this.opts.value.current);
};
_props145 = new WeakMap();
var TabsTriggerState = _TabsTriggerState;
var _isActive5, _ariaLabelledBy, _props146;
var _TabsContentState = class _TabsContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isActive5, user_derived(() => this.root.opts.value.current === this.opts.value.current));
    __privateAdd(this, _ariaLabelledBy, user_derived(() => this.root.valueToTriggerId.get(this.opts.value.current)));
    __privateAdd(this, _props146, user_derived(() => ({
      id: this.opts.id.current,
      role: "tabpanel",
      hidden: boolToTrueOrUndef(!get(__privateGet(this, _isActive5))),
      tabindex: 0,
      "data-value": this.opts.value.current,
      "data-state": getTabDataState(get(__privateGet(this, _isActive5))),
      "aria-labelledby": get(__privateGet(this, _ariaLabelledBy)),
      "data-orientation": this.root.opts.orientation.current,
      [tabsAttrs.content]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    watch(
      [
        () => this.opts.id.current,
        () => this.opts.value.current
      ],
      ([id, value]) => {
        return this.root.registerContent(id, value);
      }
    );
  }
  static create(opts) {
    return new _TabsContentState(opts, TabsRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props146));
  }
  set props(value) {
    set(__privateGet(this, _props146), value);
  }
};
_isActive5 = new WeakMap();
_ariaLabelledBy = new WeakMap();
_props146 = new WeakMap();
var TabsContentState = _TabsContentState;
function getTabDataState(condition) {
  return condition ? "active" : "inactive";
}

// node_modules/bits-ui/dist/bits/tabs/components/tabs.svelte
var root_2104 = from_html(`<div><!></div>`);
function Tabs($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), orientation = prop($$props, "orientation", 3, "horizontal"), loop = prop($$props, "loop", 3, true), activationMode = prop($$props, "activationMode", 3, "automatic"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "value",
    "onValueChange",
    "orientation",
    "loop",
    "activationMode",
    "disabled",
    "children",
    "child"
  ]);
  const rootState = TabsRootState.create({
    id: boxWith(() => id()),
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    orientation: boxWith(() => orientation()),
    loop: boxWith(() => loop()),
    activationMode: boxWith(() => activationMode()),
    disabled: boxWith(() => disabled()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2104();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/tabs/components/tabs-content.svelte
var root_2105 = from_html(`<div><!></div>`);
function Tabs_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "value"
  ]);
  const contentState = TabsContentState.create({
    value: boxWith(() => $$props.value),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2105();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/tabs/components/tabs-list.svelte
var root_2106 = from_html(`<div><!></div>`);
function Tabs_list($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "id",
    "ref"
  ]);
  const listState = TabsListState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, listState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2106();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/tabs/components/tabs-trigger.svelte
var root_2107 = from_html(`<button><!></button>`);
function Tabs_trigger($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let disabled = prop($$props, "disabled", 3, false), id = prop($$props, "id", 19, () => createId(uid)), type = prop($$props, "type", 3, "button"), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "disabled",
    "id",
    "type",
    "value",
    "ref"
  ]);
  const triggerState = TabsTriggerState.create({
    id: boxWith(() => id()),
    disabled: boxWith(() => disabled() ?? false),
    value: boxWith(() => $$props.value),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2107();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/time-field/exports.js
var exports_exports36 = {};
__export(exports_exports36, {
  Input: () => Time_field_input,
  Label: () => Time_field_label,
  Root: () => Time_field,
  Segment: () => Time_field_segment
});

// node_modules/bits-ui/dist/bits/time-field/time-field.svelte.js
var timeFieldAttrs = createBitsAttrs({
  component: "time-field",
  parts: ["input", "label"]
});
var TimeFieldRootContext = new Context("TimeField.Root");
var SEGMENT_CONFIGS2 = {
  hour: {
    min: (root18) => root18.hourCycle === 12 ? 1 : 0,
    max: (root18) => {
      if (root18.hourCycle === 24) return 23;
      if ("dayPeriod" in root18.segmentValues && root18.segmentValues.dayPeriod !== null) return 12;
      return 23;
    },
    cycle: 1,
    canBeZero: true,
    padZero: true
  },
  minute: {
    min: 0,
    max: 59,
    cycle: 1,
    canBeZero: true,
    padZero: true
  },
  second: {
    min: 0,
    max: 59,
    cycle: 1,
    canBeZero: true,
    padZero: true
  }
};
var _segmentValues2, _readonlySegmentsSet2, _fieldNode3, _labelNode5, _descriptionNode4, _validationNode2, _dayPeriodNode2, _name3, _maxValueTime, _minValueTime, _valueTime, _hourCycle, _TimeFieldRootState_instances, initializeTimeSegmentValues_fn, toDateValue_fn, clearUpdating_fn2, _validationStatus3, _isInvalid5, _inferredGranularity2, _timeRef, _allSegmentContent2, _segmentContents2, getLabelledBy_fn2;
var _TimeFieldRootState = class _TimeFieldRootState {
  constructor(props, rangeRoot) {
    __privateAdd(this, _TimeFieldRootState_instances);
    __publicField(this, "value");
    __publicField(this, "placeholder");
    __publicField(this, "validate");
    __publicField(this, "minValue");
    __publicField(this, "maxValue");
    __publicField(this, "disabled");
    __publicField(this, "readonly");
    __publicField(this, "granularity");
    __publicField(this, "readonlySegments");
    __publicField(this, "hourCycleProp");
    __publicField(this, "locale");
    __publicField(this, "hideTimeZone");
    __publicField(this, "required");
    __publicField(this, "onInvalid");
    __publicField(this, "errorMessageId");
    __publicField(this, "isInvalidProp");
    __publicField(this, "descriptionId", useId());
    __publicField(this, "formatter");
    __publicField(this, "initialSegments");
    __privateAdd(this, _segmentValues2, state());
    __publicField(this, "announcer");
    __privateAdd(this, _readonlySegmentsSet2, user_derived(() => new Set(this.readonlySegments.current)));
    __publicField(this, "segmentStates", initTimeSegmentStates());
    __privateAdd(this, _fieldNode3, state(null));
    __privateAdd(this, _labelNode5, state(null));
    __privateAdd(this, _descriptionNode4, state(null));
    __privateAdd(this, _validationNode2, state(null));
    __publicField(this, "states", initTimeSegmentStates());
    __privateAdd(this, _dayPeriodNode2, state(null));
    __privateAdd(this, _name3, state(""));
    __privateAdd(this, _maxValueTime, user_derived(() => {
      if (!this.maxValue.current) return void 0;
      return convertTimeValueToTime(this.maxValue.current);
    }));
    __privateAdd(this, _minValueTime, user_derived(() => {
      if (!this.minValue.current) return void 0;
      return convertTimeValueToTime(this.minValue.current);
    }));
    __privateAdd(this, _valueTime, user_derived(() => {
      if (!this.value.current) return void 0;
      return convertTimeValueToTime(this.value.current);
    }));
    __privateAdd(this, _hourCycle, user_derived(() => {
      if (this.hourCycleProp.current) return this.hourCycleProp.current;
      return getDefaultHourCycle(this.locale.current);
    }));
    __publicField(this, "rangeRoot");
    __publicField(this, "domContext", new DOMContext(() => null));
    __privateAdd(this, _validationStatus3, user_derived(() => {
      var _a, _b;
      const value = this.value.current;
      if (!value) return false;
      const msg = (_b = (_a = this.validate).current) == null ? void 0 : _b.call(_a, value);
      if (msg) {
        return { reason: "custom", message: msg };
      }
      if (!this.valueTime) return false;
      if (this.minValueTime && isTimeBefore(this.valueTime, this.minValueTime)) {
        return { reason: "min" };
      }
      if (this.maxValueTime && isTimeBefore(this.maxValueTime, this.valueTime)) {
        return { reason: "max" };
      }
      return false;
    }));
    __privateAdd(this, _isInvalid5, user_derived(() => {
      if (this.validationStatus === false) return false;
      if (this.isInvalidProp.current) return true;
      return true;
    }));
    __privateAdd(this, _inferredGranularity2, user_derived(() => {
      return this.granularity.current ?? "minute";
    }));
    __privateAdd(this, _timeRef, user_derived(() => this.value.current ?? this.placeholder.current));
    __privateAdd(this, _allSegmentContent2, user_derived(() => createTimeContent({
      segmentValues: this.segmentValues,
      formatter: this.formatter,
      locale: this.locale.current,
      granularity: this.inferredGranularity,
      timeRef: this.timeRef,
      hideTimeZone: this.hideTimeZone.current,
      hourCycle: this.hourCycle
    })));
    __privateAdd(this, _segmentContents2, user_derived(() => this.allSegmentContent.arr));
    __publicField(this, "sharedSegmentAttrs", {
      role: "spinbutton",
      contenteditable: "true",
      tabindex: 0,
      spellcheck: false,
      inputmode: "numeric",
      autocorrect: "off",
      enterkeyhint: "next",
      style: { caretColor: "transparent" }
    });
    this.rangeRoot = rangeRoot;
    this.value = props.value;
    this.placeholder = rangeRoot ? rangeRoot.opts.placeholder : props.placeholder;
    this.validate = rangeRoot ? simpleBox(void 0) : props.validate;
    this.minValue = rangeRoot ? rangeRoot.opts.minValue : props.minValue;
    this.maxValue = rangeRoot ? rangeRoot.opts.maxValue : props.maxValue;
    this.disabled = rangeRoot ? rangeRoot.opts.disabled : props.disabled;
    this.readonly = rangeRoot ? rangeRoot.opts.readonly : props.readonly;
    this.granularity = rangeRoot ? rangeRoot.opts.granularity : props.granularity;
    this.readonlySegments = rangeRoot ? rangeRoot.opts.readonlySegments : props.readonlySegments;
    this.hourCycleProp = rangeRoot ? rangeRoot.opts.hourCycle : props.hourCycle;
    this.locale = rangeRoot ? rangeRoot.opts.locale : props.locale;
    this.hideTimeZone = rangeRoot ? rangeRoot.opts.hideTimeZone : props.hideTimeZone;
    this.required = rangeRoot ? rangeRoot.opts.required : props.required;
    this.onInvalid = rangeRoot ? rangeRoot.opts.onInvalid : props.onInvalid;
    this.errorMessageId = rangeRoot ? rangeRoot.opts.errorMessageId : props.errorMessageId;
    this.isInvalidProp = props.isInvalidProp;
    this.formatter = createTimeFormatter(this.locale.current);
    this.initialSegments = __privateMethod(this, _TimeFieldRootState_instances, initializeTimeSegmentValues_fn).call(this);
    this.segmentValues = this.initialSegments;
    this.announcer = getAnnouncer(null);
    this.getFieldNode = this.getFieldNode.bind(this);
    this.updateSegment = this.updateSegment.bind(this);
    this.handleSegmentClick = this.handleSegmentClick.bind(this);
    this.getBaseSegmentAttrs = this.getBaseSegmentAttrs.bind(this);
    user_effect(() => {
      untrack(() => {
        this.initialSegments = __privateMethod(this, _TimeFieldRootState_instances, initializeTimeSegmentValues_fn).call(this);
      });
    });
    onMount(() => {
      this.announcer = getAnnouncer(this.domContext.getDocument());
    });
    onDestroyEffect(() => {
      removeTimeDescriptionElement(this.descriptionId, this.domContext.getDocument());
    });
    user_effect(() => {
      if (this.formatter.getLocale() === this.locale.current) return;
      this.formatter.setLocale(this.locale.current);
    });
    user_effect(() => {
      if (this.value.current) {
        const descriptionId = untrack(() => this.descriptionId);
        setTimeDescription({
          id: descriptionId,
          formatter: this.formatter,
          value: __privateMethod(this, _TimeFieldRootState_instances, toDateValue_fn).call(this, this.value.current),
          doc: this.domContext.getDocument()
        });
      }
      const placeholder = untrack(() => this.placeholder.current);
      if (this.value.current && placeholder !== this.value.current) {
        untrack(() => {
          if (this.value.current) {
            this.placeholder.current = this.value.current;
          }
        });
      }
    });
    if (this.value.current) {
      this.syncSegmentValues(this.value.current);
    }
    user_effect(() => {
      this.locale.current;
      if (this.value.current) {
        this.syncSegmentValues(this.value.current);
      }
      __privateMethod(this, _TimeFieldRootState_instances, clearUpdating_fn2).call(this);
    });
    user_effect(() => {
      if (this.value.current === void 0) {
        this.segmentValues = __privateMethod(this, _TimeFieldRootState_instances, initializeTimeSegmentValues_fn).call(this);
      }
    });
    watch(() => this.validationStatus, () => {
      var _a, _b;
      if (this.validationStatus !== false) {
        (_b = (_a = this.onInvalid).current) == null ? void 0 : _b.call(_a, this.validationStatus.reason, this.validationStatus.message);
      }
    });
  }
  static create(opts, rangeRoot) {
    return TimeFieldRootContext.set(new _TimeFieldRootState(opts, rangeRoot));
  }
  get segmentValues() {
    return get(__privateGet(this, _segmentValues2));
  }
  set segmentValues(value) {
    set(__privateGet(this, _segmentValues2), value, true);
  }
  get readonlySegmentsSet() {
    return get(__privateGet(this, _readonlySegmentsSet2));
  }
  set readonlySegmentsSet(value) {
    set(__privateGet(this, _readonlySegmentsSet2), value);
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode4));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode4), value, true);
  }
  get validationNode() {
    return get(__privateGet(this, _validationNode2));
  }
  set validationNode(value) {
    set(__privateGet(this, _validationNode2), value, true);
  }
  get dayPeriodNode() {
    return get(__privateGet(this, _dayPeriodNode2));
  }
  set dayPeriodNode(value) {
    set(__privateGet(this, _dayPeriodNode2), value, true);
  }
  get name() {
    return get(__privateGet(this, _name3));
  }
  set name(value) {
    set(__privateGet(this, _name3), value, true);
  }
  get maxValueTime() {
    return get(__privateGet(this, _maxValueTime));
  }
  set maxValueTime(value) {
    set(__privateGet(this, _maxValueTime), value);
  }
  get minValueTime() {
    return get(__privateGet(this, _minValueTime));
  }
  set minValueTime(value) {
    set(__privateGet(this, _minValueTime), value);
  }
  get valueTime() {
    return get(__privateGet(this, _valueTime));
  }
  set valueTime(value) {
    set(__privateGet(this, _valueTime), value);
  }
  get hourCycle() {
    return get(__privateGet(this, _hourCycle));
  }
  set hourCycle(value) {
    set(__privateGet(this, _hourCycle), value);
  }
  setName(name) {
    this.name = name;
  }
  setFieldNode(node) {
    set(__privateGet(this, _fieldNode3), node, true);
  }
  /**
   * Gets the correct field node for the time field regardless of whether it's being
   * used in a standalone context or within a `TimeRangeField` component.
   */
  getFieldNode() {
    if (!this.rangeRoot) {
      return get(__privateGet(this, _fieldNode3));
    } else {
      return this.rangeRoot.fieldNode;
    }
  }
  setLabelNode(node) {
    set(__privateGet(this, _labelNode5), node, true);
  }
  getLabelNode() {
    return get(__privateGet(this, _labelNode5));
  }
  setValue(value) {
    this.value.current = value;
  }
  syncSegmentValues(value) {
    const timeValues = EDITABLE_TIME_SEGMENT_PARTS.map((part) => {
      if (part === "dayPeriod") {
        if (this.states.dayPeriod.updating) {
          return [part, this.states.dayPeriod.updating];
        } else {
          return [
            part,
            this.formatter.dayPeriod(toDate(__privateMethod(this, _TimeFieldRootState_instances, toDateValue_fn).call(this, value)))
          ];
        }
      } else if (part === "hour") {
        if (this.states.hour.updating) {
          return [part, this.states.hour.updating];
        }
        if (value[part] !== void 0 && value[part] < 10) {
          return [part, `0${value[part]}`];
        }
        if (value[part] === 0 && this.dayPeriodNode) {
          return [part, "12"];
        }
      } else if (part === "minute") {
        if (this.states.minute.updating) {
          return [part, this.states.minute.updating];
        }
        if (value[part] !== void 0 && value[part] < 10) {
          return [part, `0${value[part]}`];
        }
      } else if (part === "second") {
        if (this.states.second.updating) {
          return [part, this.states.second.updating];
        }
        if (value[part] !== void 0 && value[part] < 10) {
          return [part, `0${value[part]}`];
        }
      }
      return [part, `${value[part]}`];
    });
    this.segmentValues = Object.fromEntries(timeValues);
    __privateMethod(this, _TimeFieldRootState_instances, clearUpdating_fn2).call(this);
  }
  get validationStatus() {
    return get(__privateGet(this, _validationStatus3));
  }
  set validationStatus(value) {
    set(__privateGet(this, _validationStatus3), value);
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid5));
  }
  set isInvalid(value) {
    set(__privateGet(this, _isInvalid5), value);
  }
  get inferredGranularity() {
    return get(__privateGet(this, _inferredGranularity2));
  }
  set inferredGranularity(value) {
    set(__privateGet(this, _inferredGranularity2), value);
  }
  get timeRef() {
    return get(__privateGet(this, _timeRef));
  }
  set timeRef(value) {
    set(__privateGet(this, _timeRef), value);
  }
  get allSegmentContent() {
    return get(__privateGet(this, _allSegmentContent2));
  }
  set allSegmentContent(value) {
    set(__privateGet(this, _allSegmentContent2), value);
  }
  get segmentContents() {
    return get(__privateGet(this, _segmentContents2));
  }
  set segmentContents(value) {
    set(__privateGet(this, _segmentContents2), value);
  }
  updateSegment(part, cb) {
    const disabled = this.disabled.current;
    const readonly = this.readonly.current;
    const readonlySegmentsSet = this.readonlySegmentsSet;
    if (disabled || readonly || readonlySegmentsSet.has(part)) return;
    const prev2 = this.segmentValues;
    let newSegmentValues = prev2;
    if (part === "dayPeriod") {
      const next3 = cb(prev2[part]);
      this.states.dayPeriod.updating = next3;
      const value = this.value.current;
      if (value && "hour" in value) {
        const trueHour = value.hour;
        if (next3 === "AM") {
          if (trueHour >= 12) {
            prev2.hour = `${trueHour - 12}`;
          }
        } else if (next3 === "PM") {
          if (trueHour < 12) {
            prev2.hour = `${trueHour + 12}`;
          }
        }
      }
      newSegmentValues = { ...prev2, [part]: next3 };
    } else if (part === "hour") {
      const next3 = cb(prev2[part]);
      this.states.hour.updating = next3;
      if (next3 !== null && prev2.dayPeriod !== null) {
        const dayPeriod = this.formatter.dayPeriod(toDate(__privateMethod(this, _TimeFieldRootState_instances, toDateValue_fn).call(this, this.timeRef.set({ hour: Number.parseInt(next3) }))), this.hourCycle);
        if (dayPeriod === "AM" || dayPeriod === "PM") {
          prev2.dayPeriod = dayPeriod;
        }
      }
      newSegmentValues = { ...prev2, [part]: next3 };
    } else if (part === "minute") {
      const next3 = cb(prev2[part]);
      this.states.minute.updating = next3;
      newSegmentValues = { ...prev2, [part]: next3 };
    } else if (part === "second") {
      const next3 = cb(prev2[part]);
      this.states.second.updating = next3;
      newSegmentValues = { ...prev2, [part]: next3 };
    }
    this.segmentValues = newSegmentValues;
    if (areAllTimeSegmentsFilled(newSegmentValues, get(__privateGet(this, _fieldNode3)))) {
      this.setValue(getTimeValueFromSegments({
        segmentObj: newSegmentValues,
        fieldNode: get(__privateGet(this, _fieldNode3)),
        timeRef: this.timeRef
      }));
    } else {
    }
  }
  handleSegmentClick(e) {
    if (this.disabled.current) {
      e.preventDefault();
    }
  }
  getBaseSegmentAttrs(part, segmentId) {
    var _a, _b;
    const inReadonlySegments = this.readonlySegmentsSet.has(part);
    const defaultAttrs = {
      "aria-invalid": boolToStrTrueOrUndef(this.isInvalid),
      "aria-disabled": boolToStr(this.disabled.current),
      "aria-readonly": boolToStr(this.readonly.current || inReadonlySegments),
      "data-invalid": boolToEmptyStrOrUndef(this.isInvalid),
      "data-disabled": boolToEmptyStrOrUndef(this.disabled.current),
      "data-readonly": boolToEmptyStrOrUndef(this.readonly.current || inReadonlySegments),
      "data-segment": `${part}`
    };
    if (part === "literal") return defaultAttrs;
    const descriptionId = (_a = this.descriptionNode) == null ? void 0 : _a.id;
    const hasDescription = isFirstTimeSegment(segmentId, get(__privateGet(this, _fieldNode3))) && descriptionId;
    const errorMsgId = (_b = this.errorMessageId) == null ? void 0 : _b.current;
    const describedBy = hasDescription ? `${descriptionId} ${this.isInvalid && errorMsgId ? errorMsgId : ""}` : void 0;
    const contenteditable = !(this.readonly.current || inReadonlySegments || this.disabled.current);
    return {
      ...defaultAttrs,
      "aria-labelledby": __privateMethod(this, _TimeFieldRootState_instances, getLabelledBy_fn2).call(this, segmentId),
      contenteditable: contenteditable ? "true" : void 0,
      "aria-describedby": describedBy,
      tabindex: this.disabled.current ? void 0 : 0
    };
  }
};
_segmentValues2 = new WeakMap();
_readonlySegmentsSet2 = new WeakMap();
_fieldNode3 = new WeakMap();
_labelNode5 = new WeakMap();
_descriptionNode4 = new WeakMap();
_validationNode2 = new WeakMap();
_dayPeriodNode2 = new WeakMap();
_name3 = new WeakMap();
_maxValueTime = new WeakMap();
_minValueTime = new WeakMap();
_valueTime = new WeakMap();
_hourCycle = new WeakMap();
_TimeFieldRootState_instances = new WeakSet();
initializeTimeSegmentValues_fn = function() {
  const granularity = this.inferredGranularity;
  const segments = {
    hour: null,
    minute: null,
    second: null,
    dayPeriod: "AM"
  };
  if (granularity === "second") {
    segments.second = null;
  }
  if (this.hourCycle === 24) {
    segments.dayPeriod = null;
  }
  return segments;
};
toDateValue_fn = function(timeValue) {
  if ("calendar" in timeValue) {
    return timeValue;
  } else {
    return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(2e3, 1, 1, timeValue.hour, timeValue.minute, timeValue.second, timeValue.millisecond);
  }
};
clearUpdating_fn2 = function() {
  this.states.hour.updating = null;
  this.states.minute.updating = null;
  this.states.second.updating = null;
  this.states.dayPeriod.updating = null;
};
_validationStatus3 = new WeakMap();
_isInvalid5 = new WeakMap();
_inferredGranularity2 = new WeakMap();
_timeRef = new WeakMap();
_allSegmentContent2 = new WeakMap();
_segmentContents2 = new WeakMap();
getLabelledBy_fn2 = function(segmentId) {
  var _a;
  return `${segmentId} ${((_a = this.getLabelNode()) == null ? void 0 : _a.id) ?? ""}`;
};
var TimeFieldRootState = _TimeFieldRootState;
var _ariaDescribedBy2, _props147;
var _TimeFieldInputState = class _TimeFieldInputState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __publicField(this, "domContext");
    __privateAdd(this, _ariaDescribedBy2, user_derived(() => {
      if (!isBrowser) return void 0;
      const doesDescriptionExist = this.domContext.getElementById(this.root.descriptionId);
      if (!doesDescriptionExist) return void 0;
      return this.root.descriptionId;
    }));
    __privateAdd(this, _props147, user_derived(() => {
      var _a;
      return {
        id: this.opts.id.current,
        role: "group",
        "aria-labelledby": ((_a = this.root.getLabelNode()) == null ? void 0 : _a.id) ?? void 0,
        "aria-describedby": get(__privateGet(this, _ariaDescribedBy2)),
        "aria-disabled": boolToStr(this.root.disabled.current),
        "data-invalid": this.root.isInvalid ? "" : void 0,
        "data-disabled": boolToEmptyStrOrUndef(this.root.disabled.current),
        [timeFieldAttrs.input]: "",
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.setFieldNode(v));
    this.domContext = new DOMContext(opts.ref);
    this.root.setName(this.opts.name.current);
    user_effect(() => {
      this.root.setName(this.opts.name.current);
    });
  }
  static create(opts) {
    return new _TimeFieldInputState(opts, TimeFieldRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props147));
  }
  set props(value) {
    set(__privateGet(this, _props147), value);
  }
};
_ariaDescribedBy2 = new WeakMap();
_props147 = new WeakMap();
var TimeFieldInputState = _TimeFieldInputState;
var _shouldRender13, _isoValue2, _props148;
var _TimeFieldHiddenInputState = class _TimeFieldHiddenInputState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _shouldRender13, user_derived(() => this.root.name !== ""));
    __privateAdd(this, _isoValue2, user_derived(() => this.root.value.current ? getISOTimeValue(this.root.value.current) : void 0));
    __privateAdd(this, _props148, user_derived(() => ({
      name: this.root.name,
      value: this.isoValue,
      required: this.root.required.current
    })));
    this.root = root18;
  }
  static create() {
    return new _TimeFieldHiddenInputState(TimeFieldRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender13));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender13), value);
  }
  get isoValue() {
    return get(__privateGet(this, _isoValue2));
  }
  set isoValue(value) {
    set(__privateGet(this, _isoValue2), value);
  }
  get props() {
    return get(__privateGet(this, _props148));
  }
  set props(value) {
    set(__privateGet(this, _props148), value);
  }
};
_shouldRender13 = new WeakMap();
_isoValue2 = new WeakMap();
_props148 = new WeakMap();
var TimeFieldHiddenInputState = _TimeFieldHiddenInputState;
var _props149;
var _TimeFieldLabelState = class _TimeFieldLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props149, user_derived(() => ({
      id: this.opts.id.current,
      "data-invalid": boolToEmptyStrOrUndef(this.root.isInvalid),
      "data-disabled": boolToEmptyStrOrUndef(this.root.disabled.current),
      [timeFieldAttrs.label]: "",
      onclick: this.onclick,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.setLabelNode(v));
    this.onclick = this.onclick.bind(this);
  }
  static create(opts) {
    return new _TimeFieldLabelState(opts, TimeFieldRootContext.get());
  }
  onclick(_) {
    if (this.root.disabled.current) return;
    const firstSegment = getFirstTimeSegment(this.root.getFieldNode());
    if (!firstSegment) return;
    firstSegment.focus();
  }
  get props() {
    return get(__privateGet(this, _props149));
  }
  set props(value) {
    set(__privateGet(this, _props149), value);
  }
};
_props149 = new WeakMap();
var TimeFieldLabelState = _TimeFieldLabelState;
var _BaseTimeSegmentState_instances, getMax_fn2, getMin_fn2, formatValue_fn2, handleArrowUp_fn2, handleArrowDown_fn2, handleNumberKey_fn2, handleBackspace_fn2, _props150;
var BaseTimeSegmentState = class {
  constructor(opts, root18, part, config) {
    __privateAdd(this, _BaseTimeSegmentState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "announcer");
    __publicField(this, "part");
    __publicField(this, "config");
    __publicField(this, "attachment");
    __privateAdd(this, _props150, user_derived(() => {
      return {
        ...this.root.sharedSegmentAttrs,
        id: this.opts.id.current,
        ...this.getSegmentProps(),
        onkeydown: this.onkeydown,
        onfocusout: this.onfocusout,
        onclick: this.root.handleSegmentClick,
        ...this.root.getBaseSegmentAttrs(this.part, this.opts.id.current),
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    this.part = part;
    this.config = config;
    this.announcer = root18.announcer;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onfocusout = this.onfocusout.bind(this);
  }
  onkeydown(e) {
    const placeholder = this.root.value.current ?? this.root.placeholder.current;
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if (e.key !== kbd_constants_exports.TAB) e.preventDefault();
    if (!isAcceptableSegmentKey(e.key)) return;
    if (isArrowUp2(e.key)) {
      __privateMethod(this, _BaseTimeSegmentState_instances, handleArrowUp_fn2).call(this, placeholder);
      return;
    }
    if (isArrowDown2(e.key)) {
      __privateMethod(this, _BaseTimeSegmentState_instances, handleArrowDown_fn2).call(this, placeholder);
      return;
    }
    if (isNumberString(e.key)) {
      __privateMethod(this, _BaseTimeSegmentState_instances, handleNumberKey_fn2).call(this, e);
      return;
    }
    if (isBackspace2(e.key)) {
      __privateMethod(this, _BaseTimeSegmentState_instances, handleBackspace_fn2).call(this, e);
      return;
    }
    if (isSegmentNavigationKey(e.key)) {
      handleTimeSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  onfocusout(_) {
    const stateKey = this.part;
    if (stateKey in this.root.states) {
      this.root.states[stateKey].hasLeftFocus = true;
    }
    if (this.config.padZero) {
      this.root.updateSegment(this.part, (prev2) => {
        if (prev2 && prev2.length === 1) {
          return `0${prev2}`;
        }
        return prev2;
      });
    }
  }
  getSegmentProps() {
    const segmentValues = this.root.segmentValues;
    const placeholder = this.root.placeholder.current;
    const isEmpty = segmentValues[this.part] === null;
    let value = placeholder;
    if (segmentValues[this.part]) {
      value = placeholder.set({
        [this.part]: Number.parseInt(segmentValues[this.part])
      });
    }
    const valueNow = value[this.part];
    const valueMin = __privateMethod(this, _BaseTimeSegmentState_instances, getMin_fn2).call(this);
    const valueMax = __privateMethod(this, _BaseTimeSegmentState_instances, getMax_fn2).call(this);
    let valueText = isEmpty ? "Empty" : `${valueNow}`;
    if (this.part === "hour" && "dayPeriod" in segmentValues && segmentValues.dayPeriod) {
      valueText = isEmpty ? "Empty" : `${valueNow} ${segmentValues.dayPeriod}`;
    }
    return {
      "aria-label": `${this.part}, `,
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  get props() {
    return get(__privateGet(this, _props150));
  }
  set props(value) {
    set(__privateGet(this, _props150), value);
  }
};
_BaseTimeSegmentState_instances = new WeakSet();
getMax_fn2 = function() {
  return typeof this.config.max === "function" ? this.config.max(this.root) : this.config.max;
};
getMin_fn2 = function() {
  return typeof this.config.min === "function" ? this.config.min(this.root) : this.config.min;
};
formatValue_fn2 = function(value, forDisplay = true) {
  const str = String(value);
  if (forDisplay && this.config.padZero && str.length === 1) {
    return `0${value}`;
  }
  return str;
};
handleArrowUp_fn2 = function(placeholder) {
  const stateKey = this.part;
  if (stateKey in this.root.states) {
    this.root.states[stateKey].hasLeftFocus = false;
  }
  this.root.updateSegment(this.part, (prev2) => {
    if (prev2 === null) {
      const next4 = placeholder[this.part];
      this.announcer.announce(String(next4));
      return __privateMethod(this, _BaseTimeSegmentState_instances, formatValue_fn2).call(this, next4);
    }
    const current = placeholder.set({ [this.part]: Number.parseInt(prev2) });
    const next3 = current.cycle(this.part, this.config.cycle)[this.part];
    this.announcer.announce(String(next3));
    return __privateMethod(this, _BaseTimeSegmentState_instances, formatValue_fn2).call(this, next3);
  });
};
handleArrowDown_fn2 = function(placeholder) {
  const stateKey = this.part;
  if (stateKey in this.root.states) {
    this.root.states[stateKey].hasLeftFocus = false;
  }
  this.root.updateSegment(this.part, (prev2) => {
    if (prev2 === null) {
      const next4 = placeholder[this.part];
      this.announcer.announce(String(next4));
      return __privateMethod(this, _BaseTimeSegmentState_instances, formatValue_fn2).call(this, next4);
    }
    const current = placeholder.set({ [this.part]: Number.parseInt(prev2) });
    const next3 = current.cycle(this.part, -this.config.cycle)[this.part];
    this.announcer.announce(String(next3));
    return __privateMethod(this, _BaseTimeSegmentState_instances, formatValue_fn2).call(this, next3);
  });
};
handleNumberKey_fn2 = function(e) {
  const num = Number.parseInt(e.key);
  let moveToNext = false;
  const max = __privateMethod(this, _BaseTimeSegmentState_instances, getMax_fn2).call(this);
  const maxStart = Math.floor(max / 10);
  const numIsZero = num === 0;
  const stateKey = this.part;
  this.root.updateSegment(this.part, (prev2) => {
    if (stateKey in this.root.states && this.root.states[stateKey].hasLeftFocus) {
      prev2 = null;
      this.root.states[stateKey].hasLeftFocus = false;
    }
    if (prev2 === null) {
      if (numIsZero) {
        if (stateKey in this.root.states) {
          this.root.states[stateKey].lastKeyZero = true;
        }
        this.announcer.announce("0");
        return "0";
      }
      if (stateKey in this.root.states && (this.root.states[stateKey].lastKeyZero || num > maxStart)) {
        moveToNext = true;
      }
      if (stateKey in this.root.states) {
        this.root.states[stateKey].lastKeyZero = false;
      }
      if (moveToNext && String(num).length === 1) {
        this.announcer.announce(num);
        return `0${num}`;
      }
      return `${num}`;
    }
    if (stateKey in this.root.states && this.root.states[stateKey].lastKeyZero) {
      if (num !== 0) {
        moveToNext = true;
        this.root.states[stateKey].lastKeyZero = false;
        return `0${num}`;
      }
      if (this.part === "hour" && num === 0 && this.root.hourCycle === 24) {
        moveToNext = true;
        this.root.states[stateKey].lastKeyZero = false;
        return `00`;
      }
      if ((this.part === "minute" || this.part === "second") && num === 0) {
        moveToNext = true;
        this.root.states[stateKey].lastKeyZero = false;
        return "00";
      }
      return prev2;
    }
    const total = Number.parseInt(prev2 + num.toString());
    if (total > max) {
      moveToNext = true;
      return `0${num}`;
    }
    moveToNext = true;
    return `${total}`;
  });
  if (moveToNext) {
    moveToNextTimeSegment(e, this.root.getFieldNode());
  }
};
handleBackspace_fn2 = function(e) {
  const stateKey = this.part;
  if (stateKey in this.root.states) {
    this.root.states[stateKey].hasLeftFocus = false;
  }
  let moveToPrev = false;
  this.root.updateSegment(this.part, (prev2) => {
    if (prev2 === null) {
      moveToPrev = true;
      this.announcer.announce(null);
      return null;
    }
    if (prev2.length === 2 && prev2.startsWith("0")) {
      this.announcer.announce(null);
      return null;
    }
    const str = prev2.toString();
    if (str.length === 1) {
      this.announcer.announce(null);
      return null;
    }
    const next3 = Number.parseInt(str.slice(0, -1));
    this.announcer.announce(String(next3));
    return `${next3}`;
  });
  if (moveToPrev) {
    moveToPrevTimeSegment(e, this.root.getFieldNode());
  }
};
_props150 = new WeakMap();
var TimeFieldHourSegmentState = class extends BaseTimeSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "hour", SEGMENT_CONFIGS2.hour);
  }
  onkeydown(e) {
    if (isNumberString(e.key)) {
      const oldUpdateSegment = this.root.updateSegment.bind(this.root);
      this.root.updateSegment = (part, cb) => {
        const result = oldUpdateSegment(part, cb);
        if (part === "hour" && "hour" in this.root.segmentValues) {
          const hourValue = this.root.segmentValues.hour;
          if (hourValue === "0" && this.root.dayPeriodNode && this.root.hourCycle !== 24) {
            this.root.segmentValues.hour = "12";
          }
        }
        return result;
      };
    }
    super.onkeydown(e);
    this.root.updateSegment = this.root.updateSegment.bind(this.root);
  }
};
var TimeFieldMinuteSegmentState = class extends BaseTimeSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "minute", SEGMENT_CONFIGS2.minute);
  }
};
var TimeFieldSecondSegmentState = class extends BaseTimeSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "second", SEGMENT_CONFIGS2.second);
  }
};
var _announcer2, _props151;
var TimeFieldDayPeriodSegmentState = class {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _announcer2);
    __privateAdd(this, _props151, user_derived(() => {
      const segmentValues = this.root.segmentValues;
      if (!("dayPeriod" in segmentValues)) return;
      const valueMin = 0;
      const valueMax = 12;
      const valueNow = segmentValues.dayPeriod === "AM" ? 0 : 12;
      const valueText = segmentValues.dayPeriod === "AM" ? "AM" : "PM";
      return {
        ...this.root.sharedSegmentAttrs,
        id: this.opts.id.current,
        inputmode: "text",
        "aria-label": "AM/PM",
        "aria-valuemin": valueMin,
        "aria-valuemax": valueMax,
        "aria-valuenow": valueNow,
        "aria-valuetext": valueText,
        onkeydown: this.onkeydown,
        onclick: this.root.handleSegmentClick,
        ...this.root.getBaseSegmentAttrs("dayPeriod", this.opts.id.current),
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    __privateSet(this, _announcer2, this.root.announcer);
    this.attachment = attachRef(opts.ref, (v) => this.root.dayPeriodNode = v);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onkeydown(e) {
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if (e.key !== kbd_constants_exports.TAB) e.preventDefault();
    if (!isAcceptableDayPeriodKey2(e.key)) return;
    if (isArrowUp2(e.key) || isArrowDown2(e.key)) {
      this.root.updateSegment("dayPeriod", (prev2) => {
        if (prev2 === "AM") {
          const next4 = "PM";
          __privateGet(this, _announcer2).announce(next4);
          return next4;
        }
        const next3 = "AM";
        __privateGet(this, _announcer2).announce(next3);
        return next3;
      });
      return;
    }
    if (isBackspace2(e.key)) {
      this.root.states.dayPeriod.hasLeftFocus = false;
      this.root.updateSegment("dayPeriod", () => {
        const next3 = "AM";
        __privateGet(this, _announcer2).announce(next3);
        return next3;
      });
    }
    if (e.key === kbd_constants_exports.A || e.key === kbd_constants_exports.P || e.key === kbd_constants_exports.a || e.key === kbd_constants_exports.p) {
      this.root.updateSegment("dayPeriod", () => {
        const next3 = e.key === kbd_constants_exports.A || e.key === kbd_constants_exports.a ? "AM" : "PM";
        __privateGet(this, _announcer2).announce(next3);
        return next3;
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleTimeSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  get props() {
    return get(__privateGet(this, _props151));
  }
  set props(value) {
    set(__privateGet(this, _props151), value);
  }
};
_announcer2 = new WeakMap();
_props151 = new WeakMap();
var _props152;
var TimeFieldLiteralSegmentState = class {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props152, user_derived(() => ({
      id: this.opts.id.current,
      "aria-hidden": boolToStrTrueOrUndef(true),
      ...this.root.getBaseSegmentAttrs("literal", this.opts.id.current),
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  get props() {
    return get(__privateGet(this, _props152));
  }
  set props(value) {
    set(__privateGet(this, _props152), value);
  }
};
_props152 = new WeakMap();
var _props153;
var TimeFieldTimeZoneSegmentState = class {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props153, user_derived(() => ({
      role: "textbox",
      id: this.opts.id.current,
      "aria-label": "timezone, ",
      style: { caretColor: "transparent" },
      onkeydown: this.onkeydown,
      tabindex: 0,
      ...this.root.getBaseSegmentAttrs("timeZoneName", this.opts.id.current),
      "data-readonly": boolToEmptyStrOrUndef(true),
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onkeydown(e) {
    if (e.key !== kbd_constants_exports.TAB) e.preventDefault();
    if (this.root.disabled.current) return;
    if (isSegmentNavigationKey(e.key)) {
      handleTimeSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  get props() {
    return get(__privateGet(this, _props153));
  }
  set props(value) {
    set(__privateGet(this, _props153), value);
  }
};
_props153 = new WeakMap();
var DateFieldSegmentState2 = class {
  static create(part, opts) {
    const root18 = TimeFieldRootContext.get();
    switch (part) {
      case "hour":
        return new TimeFieldHourSegmentState(opts, root18);
      case "minute":
        return new TimeFieldMinuteSegmentState(opts, root18);
      case "second":
        return new TimeFieldSecondSegmentState(opts, root18);
      case "dayPeriod":
        return new TimeFieldDayPeriodSegmentState(opts, root18);
      case "literal":
        return new TimeFieldLiteralSegmentState(opts, root18);
      case "timeZoneName":
        return new TimeFieldTimeZoneSegmentState(opts, root18);
      default:
        throw new Error(`Invalid part: ${part}`);
    }
  }
};
function isAcceptableDayPeriodKey2(key) {
  return isAcceptableSegmentKey(key) || key === kbd_constants_exports.A || key === kbd_constants_exports.P || key === kbd_constants_exports.a || key === kbd_constants_exports.p;
}
function isArrowUp2(key) {
  return key === kbd_constants_exports.ARROW_UP;
}
function isArrowDown2(key) {
  return key === kbd_constants_exports.ARROW_DOWN;
}
function isBackspace2(key) {
  return key === kbd_constants_exports.BACKSPACE;
}

// node_modules/bits-ui/dist/bits/time-field/components/time-field.svelte
function Time_field($$anchor, $$props) {
  push($$props, true);
  let disabled = prop($$props, "disabled", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), onValueChange = prop($$props, "onValueChange", 3, noop3), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), placeholder = prop($$props, "placeholder", 15), value = prop($$props, "value", 15), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), required = prop($$props, "required", 3, false);
  function handleDefaultPlaceholder() {
    if (placeholder() !== void 0) return;
    const defaultPlaceholder = getDefaultTime({
      granularity: $$props.granularity,
      defaultValue: value()
    });
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  TimeFieldRootState.create({
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: boxWith(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    disabled: boxWith(() => disabled()),
    granularity: boxWith(() => $$props.granularity),
    hideTimeZone: boxWith(() => hideTimeZone()),
    hourCycle: boxWith(() => $$props.hourCycle),
    locale: resolveLocaleProp(() => $$props.locale),
    maxValue: boxWith(() => $$props.maxValue),
    minValue: boxWith(() => $$props.minValue),
    validate: boxWith(() => validate()),
    readonly: boxWith(() => readonly()),
    readonlySegments: boxWith(() => readonlySegments()),
    required: boxWith(() => required()),
    onInvalid: boxWith(() => onInvalid()),
    errorMessageId: boxWith(() => $$props.errorMessageId),
    isInvalidProp: boxWith(() => void 0)
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/time-field/components/time-field-hidden-input.svelte
function Time_field_hidden_input($$anchor, $$props) {
  push($$props, false);
  const hiddenInputState = TimeFieldHiddenInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Hidden_input($$anchor2, spread_props(() => hiddenInputState.props));
    };
    if_block(node, ($$render) => {
      if (hiddenInputState.shouldRender) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/time-field/components/time-field-input.svelte
var root_2108 = from_html(`<div><!></div>`);
var root16 = from_html(`<!> <!>`, 1);
function Time_field_input($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "name",
    "children",
    "child"
  ]);
  const inputState = TimeFieldInputState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    name: boxWith(() => name())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, inputState.props));
  var fragment = root16();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        segments: inputState.root.segmentContents
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2108();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents }));
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  Time_field_hidden_input(node_3, {});
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/time-field/components/time-field-label.svelte
var root_2109 = from_html(`<div><!></div>`);
function Time_field_label($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const labelState = TimeFieldLabelState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, labelState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2109();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/time-field/components/time-field-segment.svelte
var root_2110 = from_html(`<span><!></span>`);
function Time_field_segment($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child",
    "part"
  ]);
  const segmentState = DateFieldSegmentState2.create($$props.part, {
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, segmentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2110();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/time-range-field/exports.js
var exports_exports37 = {};
__export(exports_exports37, {
  Input: () => Time_range_field_input,
  Label: () => Time_range_field_label,
  Root: () => Time_range_field,
  Segment: () => Time_field_segment
});

// node_modules/bits-ui/dist/bits/time-range-field/time-range-field.svelte.js
var timeRangeFieldAttrs = createBitsAttrs({
  component: "time-range-field",
  parts: ["root", "label"]
});
var TimeRangeFieldRootContext = new Context("TimeRangeField.Root");
var _fieldNode4, _labelNode6, _descriptionNode5, _startValueComplete2, _endValueComplete2, _rangeComplete2, _startValueTime, _endValueTime, _minValueTime2, _maxValueTime2, _validationStatus4, _isInvalid6, _TimeRangeFieldRootState_instances, updateValue_fn4, _props154;
var _TimeRangeFieldRootState = class _TimeRangeFieldRootState {
  constructor(opts) {
    __privateAdd(this, _TimeRangeFieldRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __publicField(this, "startFieldState");
    __publicField(this, "endFieldState");
    __publicField(this, "descriptionId", useId());
    __publicField(this, "formatter");
    __privateAdd(this, _fieldNode4, state(null));
    __privateAdd(this, _labelNode6, state(null));
    __privateAdd(this, _descriptionNode5, state(null));
    __privateAdd(this, _startValueComplete2, user_derived(() => this.opts.startValue.current !== void 0));
    __privateAdd(this, _endValueComplete2, user_derived(() => this.opts.endValue.current !== void 0));
    __privateAdd(this, _rangeComplete2, user_derived(() => this.startValueComplete && this.endValueComplete));
    __privateAdd(this, _startValueTime, user_derived(() => {
      if (!this.opts.startValue.current) return void 0;
      return convertTimeValueToTime(this.opts.startValue.current);
    }));
    __privateAdd(this, _endValueTime, user_derived(() => {
      if (!this.opts.endValue.current) return void 0;
      return convertTimeValueToTime(this.opts.endValue.current);
    }));
    __privateAdd(this, _minValueTime2, user_derived(() => {
      if (!this.opts.minValue.current) return void 0;
      return convertTimeValueToTime(this.opts.minValue.current);
    }));
    __privateAdd(this, _maxValueTime2, user_derived(() => {
      if (!this.opts.maxValue.current) return void 0;
      return convertTimeValueToTime(this.opts.maxValue.current);
    }));
    __publicField(this, "domContext");
    __privateAdd(this, _validationStatus4, user_derived(() => {
      var _a, _b;
      const value = this.opts.value.current;
      if (value === void 0) return false;
      if (value.start === void 0 || value.end === void 0) return false;
      const msg = (_b = (_a = this.opts.validate).current) == null ? void 0 : _b.call(_a, { start: value.start, end: value.end });
      if (msg) {
        return { reason: "custom", message: msg };
      }
      if (this.minValueTime && this.startValueTime && isTimeBefore(this.startValueTime, this.minValueTime)) {
        return { reason: "min" };
      }
      if (this.maxValueTime && this.endValueTime && isTimeBefore(this.maxValueTime, this.endValueTime)) {
        return { reason: "max" };
      }
      return false;
    }));
    __privateAdd(this, _isInvalid6, user_derived(() => {
      if (this.validationStatus === false) return false;
      return true;
    }));
    __privateAdd(this, _props154, user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      [timeRangeFieldAttrs.root]: "",
      "data-invalid": boolToEmptyStrOrUndef(this.isInvalid),
      ...this.attachment
    })));
    this.opts = opts;
    this.formatter = createTimeFormatter(this.opts.locale.current);
    this.domContext = new DOMContext(this.opts.ref);
    this.attachment = attachRef(this.opts.ref, (v) => this.fieldNode = v);
    onDestroyEffect(() => {
      removeDescriptionElement(this.descriptionId, this.domContext.getDocument());
    });
    user_effect(() => {
      if (this.formatter.getLocale() === this.opts.locale.current) return;
      this.formatter.setLocale(this.opts.locale.current);
    });
    watch(() => this.opts.value.current, (value) => {
      if (value.start && value.end) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = value.end;
      } else if (value.start) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = void 0;
      } else if (value.start === void 0 && value.end === void 0) {
        this.opts.startValue.current = void 0;
        this.opts.endValue.current = void 0;
      }
    });
    watch(() => this.opts.value.current, (value) => {
      const startValue = value.start;
      if (startValue && this.opts.placeholder.current !== startValue) {
        this.opts.placeholder.current = startValue;
      }
    });
    watch(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current
      ],
      ([startValue, endValue]) => {
        if (this.opts.value.current && this.opts.value.current.start === startValue && this.opts.value.current.end === endValue) {
          return;
        }
        if (startValue && endValue) {
          __privateMethod(this, _TimeRangeFieldRootState_instances, updateValue_fn4).call(this, (prev2) => {
            if (prev2.start === startValue && prev2.end === endValue) {
              return prev2;
            }
            return { start: startValue, end: endValue };
          });
        } else if (this.opts.value.current && this.opts.value.current.start && this.opts.value.current.end) {
          this.opts.value.current.start = void 0;
          this.opts.value.current.end = void 0;
        }
      }
    );
  }
  static create(opts) {
    return TimeRangeFieldRootContext.set(new _TimeRangeFieldRootState(opts));
  }
  get fieldNode() {
    return get(__privateGet(this, _fieldNode4));
  }
  set fieldNode(value) {
    set(__privateGet(this, _fieldNode4), value, true);
  }
  get labelNode() {
    return get(__privateGet(this, _labelNode6));
  }
  set labelNode(value) {
    set(__privateGet(this, _labelNode6), value, true);
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode5));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode5), value, true);
  }
  get startValueComplete() {
    return get(__privateGet(this, _startValueComplete2));
  }
  set startValueComplete(value) {
    set(__privateGet(this, _startValueComplete2), value);
  }
  get endValueComplete() {
    return get(__privateGet(this, _endValueComplete2));
  }
  set endValueComplete(value) {
    set(__privateGet(this, _endValueComplete2), value);
  }
  get rangeComplete() {
    return get(__privateGet(this, _rangeComplete2));
  }
  set rangeComplete(value) {
    set(__privateGet(this, _rangeComplete2), value);
  }
  get startValueTime() {
    return get(__privateGet(this, _startValueTime));
  }
  set startValueTime(value) {
    set(__privateGet(this, _startValueTime), value);
  }
  get endValueTime() {
    return get(__privateGet(this, _endValueTime));
  }
  set endValueTime(value) {
    set(__privateGet(this, _endValueTime), value);
  }
  get minValueTime() {
    return get(__privateGet(this, _minValueTime2));
  }
  set minValueTime(value) {
    set(__privateGet(this, _minValueTime2), value);
  }
  get maxValueTime() {
    return get(__privateGet(this, _maxValueTime2));
  }
  set maxValueTime(value) {
    set(__privateGet(this, _maxValueTime2), value);
  }
  get validationStatus() {
    return get(__privateGet(this, _validationStatus4));
  }
  set validationStatus(value) {
    set(__privateGet(this, _validationStatus4), value);
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid6));
  }
  set isInvalid(value) {
    set(__privateGet(this, _isInvalid6), value);
  }
  get props() {
    return get(__privateGet(this, _props154));
  }
  set props(value) {
    set(__privateGet(this, _props154), value);
  }
};
_fieldNode4 = new WeakMap();
_labelNode6 = new WeakMap();
_descriptionNode5 = new WeakMap();
_startValueComplete2 = new WeakMap();
_endValueComplete2 = new WeakMap();
_rangeComplete2 = new WeakMap();
_startValueTime = new WeakMap();
_endValueTime = new WeakMap();
_minValueTime2 = new WeakMap();
_maxValueTime2 = new WeakMap();
_validationStatus4 = new WeakMap();
_isInvalid6 = new WeakMap();
_TimeRangeFieldRootState_instances = new WeakSet();
updateValue_fn4 = function(cb) {
  const value = this.opts.value.current;
  const newValue = cb(value);
  this.opts.value.current = newValue;
};
_props154 = new WeakMap();
var TimeRangeFieldRootState = _TimeRangeFieldRootState;
var _onclick2, _props155;
var _TimeRangeFieldLabelState = class _TimeRangeFieldLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _onclick2, () => {
      if (this.root.opts.disabled.current) return;
      const firstSegment = getFirstSegment(this.root.fieldNode);
      if (!firstSegment) return;
      firstSegment.focus();
    });
    __privateAdd(this, _props155, user_derived(() => ({
      id: this.opts.id.current,
      "data-invalid": boolToEmptyStrOrUndef(this.root.isInvalid),
      "data-disabled": boolToEmptyStrOrUndef(this.root.opts.disabled.current),
      [timeRangeFieldAttrs.label]: "",
      onclick: __privateGet(this, _onclick2),
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.labelNode = v);
  }
  static create(opts) {
    return new _TimeRangeFieldLabelState(opts, TimeRangeFieldRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props155));
  }
  set props(value) {
    set(__privateGet(this, _props155), value);
  }
};
_onclick2 = new WeakMap();
_props155 = new WeakMap();
var TimeRangeFieldLabelState = _TimeRangeFieldLabelState;
var TimeRangeFieldInputState = class {
  static create(opts, type) {
    const root18 = TimeRangeFieldRootContext.get();
    const fieldState = TimeFieldRootState.create(
      {
        value: type === "start" ? root18.opts.startValue : root18.opts.endValue,
        disabled: root18.opts.disabled,
        readonly: root18.opts.readonly,
        readonlySegments: root18.opts.readonlySegments,
        validate: boxWith(() => void 0),
        minValue: root18.opts.minValue,
        maxValue: root18.opts.maxValue,
        hourCycle: root18.opts.hourCycle,
        locale: root18.opts.locale,
        hideTimeZone: root18.opts.hideTimeZone,
        required: root18.opts.required,
        granularity: root18.opts.granularity,
        placeholder: root18.opts.placeholder,
        onInvalid: root18.opts.onInvalid,
        errorMessageId: root18.opts.errorMessageId,
        isInvalidProp: boxWith(() => root18.isInvalid)
      },
      root18
    );
    return new TimeFieldInputState({ name: opts.name, id: opts.id, ref: opts.ref }, fieldState);
  }
};

// node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field.svelte
var root_2111 = from_html(`<div><!></div>`);
function Time_range_field($$anchor, $$props) {
  var _a, _b;
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), required = prop($$props, "required", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), readonlySegments = prop($$props, "readonlySegments", 19, () => []), onStartValueChange = prop($$props, "onStartValueChange", 3, noop3), onEndValueChange = prop($$props, "onEndValueChange", 3, noop3), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "value",
    "onValueChange",
    "placeholder",
    "onPlaceholderChange",
    "disabled",
    "readonly",
    "required",
    "hourCycle",
    "granularity",
    "locale",
    "hideTimeZone",
    "validate",
    "onInvalid",
    "maxValue",
    "minValue",
    "readonlySegments",
    "children",
    "child",
    "onStartValueChange",
    "onEndValueChange",
    "errorMessageId"
  ]);
  let startValue = state(proxy((_a = value()) == null ? void 0 : _a.start));
  let endValue = state(proxy((_b = value()) == null ? void 0 : _b.end));
  function handleDefaultPlaceholder() {
    var _a2;
    if (placeholder() !== void 0) return;
    const defaultPlaceholder = getDefaultTime({
      granularity: $$props.granularity,
      defaultValue: (_a2 = value()) == null ? void 0 : _a2.start
    });
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function handleDefaultValue() {
    if (value() !== void 0) return;
    const defaultValue = { start: void 0, end: void 0 };
    value(defaultValue);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = TimeRangeFieldRootState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    disabled: boxWith(() => disabled()),
    readonly: boxWith(() => readonly()),
    required: boxWith(() => required()),
    hourCycle: boxWith(() => $$props.hourCycle),
    granularity: boxWith(() => $$props.granularity),
    locale: resolveLocaleProp(() => $$props.locale),
    hideTimeZone: boxWith(() => hideTimeZone()),
    validate: boxWith(() => validate()),
    maxValue: boxWith(() => $$props.maxValue),
    minValue: boxWith(() => $$props.minValue),
    placeholder: boxWith(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    readonlySegments: boxWith(() => readonlySegments()),
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    startValue: boxWith(() => get(startValue), (v) => {
      set(startValue, v, true);
      onStartValueChange()(v);
    }),
    endValue: boxWith(() => get(endValue), (v) => {
      set(endValue, v, true);
      onEndValueChange()(v);
    }),
    onInvalid: boxWith(() => onInvalid()),
    errorMessageId: boxWith(() => $$props.errorMessageId)
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2111();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field-input.svelte
var root_2112 = from_html(`<div><!></div>`);
var root17 = from_html(`<!> <!>`, 1);
function Time_range_field_input($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "name",
    "child",
    "children",
    "type"
  ]);
  const inputState = TimeRangeFieldInputState.create(
    {
      id: boxWith(() => id()),
      ref: boxWith(() => ref(), (v) => ref(v)),
      name: boxWith(() => name())
    },
    $$props.type
  );
  const mergedProps = user_derived(() => mergeProps(restProps, inputState.props, { role: "presentation" }));
  var fragment = root17();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        segments: inputState.root.segmentContents
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2112();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents }));
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  Time_field_hidden_input(node_3, {});
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field-label.svelte
var root_2113 = from_html(`<span><!></span>`);
function Time_range_field_label($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "children",
    "child"
  ]);
  const labelState = TimeRangeFieldLabelState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, labelState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2113();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/toggle/exports.js
var exports_exports38 = {};
__export(exports_exports38, {
  Root: () => Toggle
});

// node_modules/bits-ui/dist/bits/toggle/toggle.svelte.js
var toggleAttrs = createBitsAttrs({ component: "toggle", parts: ["root"] });
var _snippetProps30, _props156;
var _ToggleRootState = class _ToggleRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps30, user_derived(() => ({ pressed: this.opts.pressed.current })));
    __privateAdd(this, _props156, user_derived(() => ({
      [toggleAttrs.root]: "",
      id: this.opts.id.current,
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      "aria-pressed": boolToStr(this.opts.pressed.current),
      "data-state": getToggleDataState(this.opts.pressed.current),
      disabled: boolToTrueOrUndef(this.opts.disabled.current),
      onclick: this.onclick,
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
  }
  static create(opts) {
    return new _ToggleRootState(opts);
  }
  onclick(_) {
    if (this.opts.disabled.current) return;
    this.opts.pressed.current = !this.opts.pressed.current;
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps30));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps30), value);
  }
  get props() {
    return get(__privateGet(this, _props156));
  }
  set props(value) {
    set(__privateGet(this, _props156), value);
  }
};
_snippetProps30 = new WeakMap();
_props156 = new WeakMap();
var ToggleRootState = _ToggleRootState;
function getToggleDataState(condition) {
  return condition ? "on" : "off";
}

// node_modules/bits-ui/dist/bits/toggle/components/toggle.svelte
var root_2114 = from_html(`<button><!></button>`);
function Toggle($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), pressed = prop($$props, "pressed", 15, false), onPressedChange = prop($$props, "onPressedChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "pressed",
    "onPressedChange",
    "disabled",
    "type",
    "children",
    "child"
  ]);
  const toggleState = ToggleRootState.create({
    pressed: boxWith(() => pressed(), (v) => {
      pressed(v);
      onPressedChange()(v);
    }),
    disabled: boxWith(() => disabled() ?? false),
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, toggleState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...toggleState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2114();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => toggleState.snippetProps);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/toggle-group/exports.js
var exports_exports39 = {};
__export(exports_exports39, {
  Item: () => Toggle_group_item,
  Root: () => Toggle_group
});

// node_modules/bits-ui/dist/bits/toggle-group/toggle-group.svelte.js
var toggleGroupAttrs = createBitsAttrs({
  component: "toggle-group",
  parts: ["root", "item"]
});
var ToggleGroupRootContext = new Context("ToggleGroup.Root");
var _props157;
var ToggleGroupBaseState = class {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "attachment");
    __privateAdd(this, _props157, user_derived(() => ({
      id: this.opts.id.current,
      [toggleGroupAttrs.root]: "",
      role: "group",
      "data-orientation": this.opts.orientation.current,
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      candidateAttr: toggleGroupAttrs.item,
      rootNode: opts.ref,
      loop: opts.loop,
      orientation: opts.orientation
    });
  }
  get props() {
    return get(__privateGet(this, _props157));
  }
  set props(value) {
    set(__privateGet(this, _props157), value);
  }
};
_props157 = new WeakMap();
var _anyPressed;
var ToggleGroupSingleState = class extends ToggleGroupBaseState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", false);
    __privateAdd(this, _anyPressed, user_derived(() => this.opts.value.current !== ""));
    this.opts = opts;
  }
  get anyPressed() {
    return get(__privateGet(this, _anyPressed));
  }
  set anyPressed(value) {
    set(__privateGet(this, _anyPressed), value);
  }
  includesItem(item) {
    return this.opts.value.current === item;
  }
  toggleItem(item, id) {
    if (this.includesItem(item)) {
      this.opts.value.current = "";
    } else {
      this.opts.value.current = item;
      this.rovingFocusGroup.setCurrentTabStopId(id);
    }
  }
};
_anyPressed = new WeakMap();
var _anyPressed2;
var ToggleGroupMultipleState = class extends ToggleGroupBaseState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", true);
    __privateAdd(this, _anyPressed2, user_derived(() => this.opts.value.current.length > 0));
    this.opts = opts;
  }
  get anyPressed() {
    return get(__privateGet(this, _anyPressed2));
  }
  set anyPressed(value) {
    set(__privateGet(this, _anyPressed2), value);
  }
  includesItem(item) {
    return this.opts.value.current.includes(item);
  }
  toggleItem(item, id) {
    if (this.includesItem(item)) {
      this.opts.value.current = this.opts.value.current.filter((v) => v !== item);
    } else {
      this.opts.value.current = [...this.opts.value.current, item];
      this.rovingFocusGroup.setCurrentTabStopId(id);
    }
  }
};
_anyPressed2 = new WeakMap();
var ToggleGroupRootState = class {
  static create(opts) {
    const { type, ...rest } = opts;
    const rootState = type === "single" ? new ToggleGroupSingleState(rest) : new ToggleGroupMultipleState(rest);
    return ToggleGroupRootContext.set(rootState);
  }
};
var _isDisabled16, _isPressed, _ariaChecked, _ariaPressed, _ToggleGroupItemState_instances, toggleItem_fn, _tabIndex4, _snippetProps31, _props158;
var _ToggleGroupItemState = class _ToggleGroupItemState {
  constructor(opts, root18) {
    __privateAdd(this, _ToggleGroupItemState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled16, user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current));
    __privateAdd(this, _isPressed, user_derived(() => this.root.includesItem(this.opts.value.current)));
    __privateAdd(this, _ariaChecked, user_derived(() => {
      return this.root.isMulti ? void 0 : getAriaChecked(this.isPressed, false);
    }));
    __privateAdd(this, _ariaPressed, user_derived(() => {
      return this.root.isMulti ? boolToStr(this.isPressed) : void 0;
    }));
    __privateAdd(this, _tabIndex4, state(0));
    __privateAdd(this, _snippetProps31, user_derived(() => ({ pressed: this.isPressed })));
    __privateAdd(this, _props158, user_derived(() => ({
      id: this.opts.id.current,
      role: this.root.isMulti ? void 0 : "radio",
      tabindex: get(__privateGet(this, _tabIndex4)),
      "data-orientation": this.root.opts.orientation.current,
      "data-disabled": boolToEmptyStrOrUndef(get(__privateGet(this, _isDisabled16))),
      "data-state": getToggleItemDataState(this.isPressed),
      "data-value": this.opts.value.current,
      "aria-pressed": get(__privateGet(this, _ariaPressed)),
      "aria-checked": get(__privateGet(this, _ariaChecked)),
      disabled: boolToTrueOrUndef(get(__privateGet(this, _isDisabled16))),
      [toggleGroupAttrs.item]: "",
      //
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      if (!this.root.opts.rovingFocus.current) {
        set(__privateGet(this, _tabIndex4), 0);
      } else {
        set(__privateGet(this, _tabIndex4), this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
      }
    });
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _ToggleGroupItemState(opts, ToggleGroupRootContext.get());
  }
  get isPressed() {
    return get(__privateGet(this, _isPressed));
  }
  set isPressed(value) {
    set(__privateGet(this, _isPressed), value);
  }
  onclick(_) {
    if (get(__privateGet(this, _isDisabled16))) return;
    this.root.toggleItem(this.opts.value.current, this.opts.id.current);
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled16))) return;
    if (e.key === kbd_constants_exports.ENTER || e.key === kbd_constants_exports.SPACE) {
      e.preventDefault();
      __privateMethod(this, _ToggleGroupItemState_instances, toggleItem_fn).call(this);
      return;
    }
    if (!this.root.opts.rovingFocus.current) return;
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps31));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps31), value);
  }
  get props() {
    return get(__privateGet(this, _props158));
  }
  set props(value) {
    set(__privateGet(this, _props158), value);
  }
};
_isDisabled16 = new WeakMap();
_isPressed = new WeakMap();
_ariaChecked = new WeakMap();
_ariaPressed = new WeakMap();
_ToggleGroupItemState_instances = new WeakSet();
toggleItem_fn = function() {
  if (get(__privateGet(this, _isDisabled16))) return;
  this.root.toggleItem(this.opts.value.current, this.opts.id.current);
};
_tabIndex4 = new WeakMap();
_snippetProps31 = new WeakMap();
_props158 = new WeakMap();
var ToggleGroupItemState = _ToggleGroupItemState;
function getToggleItemDataState(condition) {
  return condition ? "on" : "off";
}

// node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group.svelte
var root_2115 = from_html(`<div><!></div>`);
function Toggle_group($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), loop = prop($$props, "loop", 3, true), orientation = prop($$props, "orientation", 3, "horizontal"), rovingFocus = prop($$props, "rovingFocus", 3, true), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "value",
    "onValueChange",
    "type",
    "disabled",
    "loop",
    "orientation",
    "rovingFocus",
    "child",
    "children"
  ]);
  function handleDefaultValue() {
    if (value() !== void 0) return;
    value($$props.type === "single" ? "" : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = ToggleGroupRootState.create({
    id: boxWith(() => id()),
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    disabled: boxWith(() => disabled()),
    loop: boxWith(() => loop()),
    orientation: boxWith(() => orientation()),
    rovingFocus: boxWith(() => rovingFocus()),
    type: $$props.type,
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2115();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group-item.svelte
var root_2116 = from_html(`<button><!></button>`);
function Toggle_group_item($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), id = prop($$props, "id", 19, () => createId(uid)), type = prop($$props, "type", 3, "button"), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "ref",
    "value",
    "disabled",
    "id",
    "type"
  ]);
  const itemState = ToggleGroupItemState.create({
    id: boxWith(() => id()),
    value: boxWith(() => $$props.value),
    disabled: boxWith(() => disabled() ?? false),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, itemState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...itemState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2116();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/toolbar/exports.js
var exports_exports40 = {};
__export(exports_exports40, {
  Button: () => Toolbar_button,
  Group: () => Toolbar_group,
  GroupItem: () => Toolbar_group_item,
  Link: () => Toolbar_link,
  Root: () => Toolbar
});

// node_modules/bits-ui/dist/bits/toolbar/toolbar.svelte.js
var toolbarAttrs = createBitsAttrs({
  component: "toolbar",
  parts: [
    "root",
    "item",
    "group",
    "group-item",
    "link",
    "button"
  ]
});
var ToolbarRootContext = new Context("Toolbar.Root");
var ToolbarGroupContext = new Context("Toolbar.Group");
var _props159;
var _ToolbarRootState = class _ToolbarRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "attachment");
    __privateAdd(this, _props159, user_derived(() => ({
      id: this.opts.id.current,
      role: "toolbar",
      "data-orientation": this.opts.orientation.current,
      [toolbarAttrs.root]: "",
      ...this.attachment
    })));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      orientation: this.opts.orientation,
      loop: this.opts.loop,
      rootNode: this.opts.ref,
      candidateAttr: toolbarAttrs.item
    });
  }
  static create(opts) {
    return ToolbarRootContext.set(new _ToolbarRootState(opts));
  }
  get props() {
    return get(__privateGet(this, _props159));
  }
  set props(value) {
    set(__privateGet(this, _props159), value);
  }
};
_props159 = new WeakMap();
var ToolbarRootState = _ToolbarRootState;
var _props160;
var ToolbarGroupBaseState = class {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props160, user_derived(() => ({
      id: this.opts.id.current,
      [toolbarAttrs.group]: "",
      role: "group",
      "data-orientation": this.root.opts.orientation.current,
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  get props() {
    return get(__privateGet(this, _props160));
  }
  set props(value) {
    set(__privateGet(this, _props160), value);
  }
};
_props160 = new WeakMap();
var _anyPressed3;
var ToolbarGroupSingleState = class extends ToolbarGroupBaseState {
  constructor(opts, root18) {
    super(opts, root18);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "isMulti", false);
    __privateAdd(this, _anyPressed3, user_derived(() => this.opts.value.current !== ""));
    this.opts = opts;
    this.root = root18;
  }
  get anyPressed() {
    return get(__privateGet(this, _anyPressed3));
  }
  set anyPressed(value) {
    set(__privateGet(this, _anyPressed3), value);
  }
  includesItem(item) {
    return this.opts.value.current === item;
  }
  toggleItem(item) {
    if (this.includesItem(item)) {
      this.opts.value.current = "";
    } else {
      this.opts.value.current = item;
    }
  }
};
_anyPressed3 = new WeakMap();
var _anyPressed4;
var ToolbarGroupMultipleState = class extends ToolbarGroupBaseState {
  constructor(opts, root18) {
    super(opts, root18);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "isMulti", true);
    __privateAdd(this, _anyPressed4, user_derived(() => this.opts.value.current.length > 0));
    this.opts = opts;
    this.root = root18;
  }
  get anyPressed() {
    return get(__privateGet(this, _anyPressed4));
  }
  set anyPressed(value) {
    set(__privateGet(this, _anyPressed4), value);
  }
  includesItem(item) {
    return this.opts.value.current.includes(item);
  }
  toggleItem(item) {
    if (this.includesItem(item)) {
      this.opts.value.current = this.opts.value.current.filter((v) => v !== item);
    } else {
      this.opts.value.current = [...this.opts.value.current, item];
    }
  }
};
_anyPressed4 = new WeakMap();
var ToolbarGroupState = class {
  static create(opts) {
    const { type, ...rest } = opts;
    const rootState = ToolbarRootContext.get();
    const groupState = type === "single" ? new ToolbarGroupSingleState(rest, rootState) : new ToolbarGroupMultipleState(rest, rootState);
    return ToolbarGroupContext.set(groupState);
  }
};
var _isDisabled17, _ToolbarGroupItemState_instances, toggleItem_fn2, _isPressed2, _ariaChecked2, _ariaPressed2, _tabIndex5, _props161;
var _ToolbarGroupItemState = class _ToolbarGroupItemState {
  constructor(opts, group, root18) {
    __privateAdd(this, _ToolbarGroupItemState_instances);
    __publicField(this, "opts");
    __publicField(this, "group");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled17, user_derived(() => this.opts.disabled.current || this.group.opts.disabled.current));
    __privateAdd(this, _isPressed2, user_derived(() => this.group.includesItem(this.opts.value.current)));
    __privateAdd(this, _ariaChecked2, user_derived(() => {
      return this.group.isMulti ? void 0 : getAriaChecked(this.isPressed, false);
    }));
    __privateAdd(this, _ariaPressed2, user_derived(() => {
      return this.group.isMulti ? boolToStr(this.isPressed) : void 0;
    }));
    __privateAdd(this, _tabIndex5, state(0));
    __privateAdd(this, _props161, user_derived(() => ({
      id: this.opts.id.current,
      role: this.group.isMulti ? void 0 : "radio",
      tabindex: get(__privateGet(this, _tabIndex5)),
      "data-orientation": this.root.opts.orientation.current,
      "data-disabled": boolToEmptyStrOrUndef(get(__privateGet(this, _isDisabled17))),
      "data-state": getToggleItemDataState2(this.isPressed),
      "data-value": this.opts.value.current,
      "aria-pressed": get(__privateGet(this, _ariaPressed2)),
      "aria-checked": get(__privateGet(this, _ariaChecked2)),
      [toolbarAttrs.item]: "",
      [toolbarAttrs["group-item"]]: "",
      disabled: boolToTrueOrUndef(get(__privateGet(this, _isDisabled17))),
      //
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.group = group;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      set(__privateGet(this, _tabIndex5), this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
    });
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    const group = ToolbarGroupContext.get();
    return new _ToolbarGroupItemState(opts, group, group.root);
  }
  onclick(_) {
    if (get(__privateGet(this, _isDisabled17))) return;
    __privateMethod(this, _ToolbarGroupItemState_instances, toggleItem_fn2).call(this);
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled17))) return;
    if (e.key === kbd_constants_exports.ENTER || e.key === kbd_constants_exports.SPACE) {
      e.preventDefault();
      __privateMethod(this, _ToolbarGroupItemState_instances, toggleItem_fn2).call(this);
      return;
    }
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  get isPressed() {
    return get(__privateGet(this, _isPressed2));
  }
  set isPressed(value) {
    set(__privateGet(this, _isPressed2), value);
  }
  get props() {
    return get(__privateGet(this, _props161));
  }
  set props(value) {
    set(__privateGet(this, _props161), value);
  }
};
_isDisabled17 = new WeakMap();
_ToolbarGroupItemState_instances = new WeakSet();
toggleItem_fn2 = function() {
  if (get(__privateGet(this, _isDisabled17))) return;
  this.group.toggleItem(this.opts.value.current);
};
_isPressed2 = new WeakMap();
_ariaChecked2 = new WeakMap();
_ariaPressed2 = new WeakMap();
_tabIndex5 = new WeakMap();
_props161 = new WeakMap();
var ToolbarGroupItemState = _ToolbarGroupItemState;
var _role, _tabIndex6, _props162;
var _ToolbarLinkState = class _ToolbarLinkState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _role, user_derived(() => {
      if (!this.opts.ref.current) return void 0;
      const tagName = this.opts.ref.current.tagName;
      if (tagName !== "A") return "link";
      return void 0;
    }));
    __privateAdd(this, _tabIndex6, state(0));
    __privateAdd(this, _props162, user_derived(() => ({
      id: this.opts.id.current,
      [toolbarAttrs.link]: "",
      [toolbarAttrs.item]: "",
      role: get(__privateGet(this, _role)),
      tabindex: get(__privateGet(this, _tabIndex6)),
      "data-orientation": this.root.opts.orientation.current,
      //
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      set(__privateGet(this, _tabIndex6), this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
    });
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _ToolbarLinkState(opts, ToolbarRootContext.get());
  }
  onkeydown(e) {
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  get props() {
    return get(__privateGet(this, _props162));
  }
  set props(value) {
    set(__privateGet(this, _props162), value);
  }
};
_role = new WeakMap();
_tabIndex6 = new WeakMap();
_props162 = new WeakMap();
var ToolbarLinkState = _ToolbarLinkState;
var _tabIndex7, _role2, _props163;
var _ToolbarButtonState = class _ToolbarButtonState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _tabIndex7, state(0));
    __privateAdd(this, _role2, user_derived(() => {
      if (!this.opts.ref.current) return void 0;
      const tagName = this.opts.ref.current.tagName;
      if (tagName !== "BUTTON") return "button";
      return void 0;
    }));
    __privateAdd(this, _props163, user_derived(() => ({
      id: this.opts.id.current,
      [toolbarAttrs.item]: "",
      [toolbarAttrs.button]: "",
      role: get(__privateGet(this, _role2)),
      tabindex: get(__privateGet(this, _tabIndex7)),
      "data-disabled": boolToEmptyStrOrUndef(this.opts.disabled.current),
      "data-orientation": this.root.opts.orientation.current,
      disabled: boolToTrueOrUndef(this.opts.disabled.current),
      //
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      set(__privateGet(this, _tabIndex7), this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
    });
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _ToolbarButtonState(opts, ToolbarRootContext.get());
  }
  onkeydown(e) {
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  get props() {
    return get(__privateGet(this, _props163));
  }
  set props(value) {
    set(__privateGet(this, _props163), value);
  }
};
_tabIndex7 = new WeakMap();
_role2 = new WeakMap();
_props163 = new WeakMap();
var ToolbarButtonState = _ToolbarButtonState;
function getToggleItemDataState2(condition) {
  return condition ? "on" : "off";
}

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar.svelte
var root_2117 = from_html(`<div><!></div>`);
function Toolbar($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), orientation = prop($$props, "orientation", 3, "horizontal"), loop = prop($$props, "loop", 3, true), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "ref",
    "id",
    "orientation",
    "loop",
    "child",
    "children"
  ]);
  const rootState = ToolbarRootState.create({
    id: boxWith(() => id()),
    orientation: boxWith(() => orientation()),
    loop: boxWith(() => loop()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, rootState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2117();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-button.svelte
var root_2118 = from_html(`<button><!></button>`);
function Toolbar_button($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "disabled",
    "type",
    "id",
    "ref"
  ]);
  const buttonState = ToolbarButtonState.create({
    id: boxWith(() => id()),
    disabled: boxWith(() => disabled() ?? false),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, buttonState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2118();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-link.svelte
var root_2119 = from_html(`<a><!></a>`);
function Toolbar_link($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "href",
    "child",
    "ref",
    "id"
  ]);
  const linkState = ToolbarLinkState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, linkState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var a2 = root_2119();
      attribute_effect(a2, () => ({ href: $$props.href, ...get(mergedProps) }));
      var node_2 = child(a2);
      snippet(node_2, () => $$props.children ?? noop);
      reset(a2);
      append($$anchor2, a2);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group.svelte
var root_2120 = from_html(`<div><!></div>`);
function Toolbar_group($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "id",
    "ref",
    "value",
    "onValueChange",
    "type",
    "disabled",
    "child",
    "children"
  ]);
  function handleDefaultValue() {
    if (value() !== void 0) return;
    value($$props.type === "single" ? "" : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const groupState = ToolbarGroupState.create({
    id: boxWith(() => id()),
    disabled: boxWith(() => disabled()),
    type: $$props.type,
    value: boxWith(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, groupState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2120();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group-item.svelte
var root_2121 = from_html(`<button><!></button>`);
function Toolbar_group_item($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "child",
    "children",
    "value",
    "disabled",
    "type",
    "id",
    "ref"
  ]);
  const groupItemState = ToolbarGroupItemState.create({
    id: boxWith(() => id()),
    value: boxWith(() => $$props.value),
    disabled: boxWith(() => disabled() ?? false),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, groupItemState.props, { type: type() }));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        pressed: groupItemState.isPressed
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2121();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => ({ pressed: groupItemState.isPressed }));
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/tooltip/exports.js
var exports_exports41 = {};
__export(exports_exports41, {
  Arrow: () => Tooltip_arrow,
  Content: () => Tooltip_content,
  ContentStatic: () => Tooltip_content_static,
  Portal: () => Portal,
  Provider: () => Tooltip_provider,
  Root: () => Tooltip,
  Trigger: () => Tooltip_trigger
});

// node_modules/bits-ui/dist/internal/timeout-fn.js
var _interval, _cb, _timer2, _TimeoutFn_instances, clear_fn;
var TimeoutFn = class {
  constructor(cb, interval) {
    __privateAdd(this, _TimeoutFn_instances);
    __privateAdd(this, _interval);
    __privateAdd(this, _cb);
    __privateAdd(this, _timer2, null);
    __privateSet(this, _cb, cb);
    __privateSet(this, _interval, interval);
    this.stop = this.stop.bind(this);
    this.start = this.start.bind(this);
    onDestroyEffect(this.stop);
  }
  stop() {
    __privateMethod(this, _TimeoutFn_instances, clear_fn).call(this);
  }
  start(...args) {
    __privateMethod(this, _TimeoutFn_instances, clear_fn).call(this);
    __privateSet(this, _timer2, window.setTimeout(() => {
      __privateSet(this, _timer2, null);
      __privateGet(this, _cb).call(this, ...args);
    }, __privateGet(this, _interval)));
  }
};
_interval = new WeakMap();
_cb = new WeakMap();
_timer2 = new WeakMap();
_TimeoutFn_instances = new WeakSet();
clear_fn = function() {
  if (__privateGet(this, _timer2) !== null) {
    window.clearTimeout(__privateGet(this, _timer2));
    __privateSet(this, _timer2, null);
  }
};

// node_modules/bits-ui/dist/bits/tooltip/tooltip.svelte.js
var tooltipAttrs = createBitsAttrs({
  component: "tooltip",
  parts: ["content", "trigger"]
});
var TooltipProviderContext = new Context("Tooltip.Provider");
var TooltipRootContext = new Context("Tooltip.Root");
var _isOpenDelayed, _timerFn, _openTooltip, _startTimer, _clearTimer;
var _TooltipProviderState = class _TooltipProviderState {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _isOpenDelayed, state(true));
    __publicField(this, "isPointerInTransit", simpleBox(false));
    __privateAdd(this, _timerFn);
    __privateAdd(this, _openTooltip, state(null));
    __privateAdd(this, _startTimer, () => {
      const skipDuration = this.opts.skipDelayDuration.current;
      if (skipDuration === 0) {
        return;
      } else {
        __privateGet(this, _timerFn).start();
      }
    });
    __privateAdd(this, _clearTimer, () => {
      __privateGet(this, _timerFn).stop();
    });
    __publicField(this, "onOpen", (tooltip) => {
      if (get(__privateGet(this, _openTooltip)) && get(__privateGet(this, _openTooltip)) !== tooltip) {
        get(__privateGet(this, _openTooltip)).handleClose();
      }
      __privateGet(this, _clearTimer).call(this);
      this.isOpenDelayed = false;
      set(__privateGet(this, _openTooltip), tooltip, true);
    });
    __publicField(this, "onClose", (tooltip) => {
      if (get(__privateGet(this, _openTooltip)) === tooltip) {
        set(__privateGet(this, _openTooltip), null);
      }
      __privateGet(this, _startTimer).call(this);
    });
    __publicField(this, "isTooltipOpen", (tooltip) => {
      return get(__privateGet(this, _openTooltip)) === tooltip;
    });
    this.opts = opts;
    __privateSet(this, _timerFn, new TimeoutFn(
      () => {
        this.isOpenDelayed = true;
      },
      this.opts.skipDelayDuration.current
    ));
  }
  static create(opts) {
    return TooltipProviderContext.set(new _TooltipProviderState(opts));
  }
  get isOpenDelayed() {
    return get(__privateGet(this, _isOpenDelayed));
  }
  set isOpenDelayed(value) {
    set(__privateGet(this, _isOpenDelayed), value, true);
  }
};
_isOpenDelayed = new WeakMap();
_timerFn = new WeakMap();
_openTooltip = new WeakMap();
_startTimer = new WeakMap();
_clearTimer = new WeakMap();
var TooltipProviderState = _TooltipProviderState;
var _delayDuration, _disableHoverableContent, _disableCloseOnTriggerClick, _disabled, _ignoreNonKeyboardFocus, _contentNode12, _triggerNode8, _wasOpenDelayed, _timerFn2, _stateAttr, _handleDelayedOpen;
var _TooltipRootState = class _TooltipRootState {
  constructor(opts, provider) {
    __publicField(this, "opts");
    __publicField(this, "provider");
    __privateAdd(this, _delayDuration, user_derived(() => this.opts.delayDuration.current ?? this.provider.opts.delayDuration.current));
    __privateAdd(this, _disableHoverableContent, user_derived(() => this.opts.disableHoverableContent.current ?? this.provider.opts.disableHoverableContent.current));
    __privateAdd(this, _disableCloseOnTriggerClick, user_derived(() => this.opts.disableCloseOnTriggerClick.current ?? this.provider.opts.disableCloseOnTriggerClick.current));
    __privateAdd(this, _disabled, user_derived(() => this.opts.disabled.current ?? this.provider.opts.disabled.current));
    __privateAdd(this, _ignoreNonKeyboardFocus, user_derived(() => this.opts.ignoreNonKeyboardFocus.current ?? this.provider.opts.ignoreNonKeyboardFocus.current));
    __privateAdd(this, _contentNode12, state(null));
    __publicField(this, "contentPresence");
    __privateAdd(this, _triggerNode8, state(null));
    __privateAdd(this, _wasOpenDelayed, state(false));
    __privateAdd(this, _timerFn2);
    __privateAdd(this, _stateAttr, user_derived(() => {
      if (!this.opts.open.current) return "closed";
      return get(__privateGet(this, _wasOpenDelayed)) ? "delayed-open" : "instant-open";
    }));
    __publicField(this, "handleOpen", () => {
      __privateGet(this, _timerFn2).stop();
      set(__privateGet(this, _wasOpenDelayed), false);
      this.opts.open.current = true;
    });
    __publicField(this, "handleClose", () => {
      __privateGet(this, _timerFn2).stop();
      this.opts.open.current = false;
    });
    __privateAdd(this, _handleDelayedOpen, () => {
      __privateGet(this, _timerFn2).stop();
      const shouldSkipDelay = !this.provider.isOpenDelayed;
      const delayDuration = this.delayDuration ?? 0;
      if (shouldSkipDelay || delayDuration === 0) {
        set(__privateGet(this, _wasOpenDelayed), delayDuration > 0 && shouldSkipDelay, true);
        this.opts.open.current = true;
      } else {
        __privateGet(this, _timerFn2).start();
      }
    });
    __publicField(this, "onTriggerEnter", () => {
      __privateGet(this, _handleDelayedOpen).call(this);
    });
    __publicField(this, "onTriggerLeave", () => {
      if (this.disableHoverableContent) {
        this.handleClose();
      } else {
        __privateGet(this, _timerFn2).stop();
      }
    });
    this.opts = opts;
    this.provider = provider;
    __privateSet(this, _timerFn2, new TimeoutFn(
      () => {
        set(__privateGet(this, _wasOpenDelayed), true);
        this.opts.open.current = true;
      },
      this.delayDuration ?? 0
    ));
    this.contentPresence = new PresenceManager({
      open: this.opts.open,
      ref: boxWith(() => this.contentNode),
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    watch(() => this.delayDuration, () => {
      if (this.delayDuration === void 0) return;
      __privateSet(this, _timerFn2, new TimeoutFn(
        () => {
          set(__privateGet(this, _wasOpenDelayed), true);
          this.opts.open.current = true;
        },
        this.delayDuration
      ));
    });
    watch(
      () => this.opts.open.current,
      (isOpen) => {
        if (isOpen) {
          this.provider.onOpen(this);
        } else {
          this.provider.onClose(this);
        }
      },
      { lazy: true }
    );
  }
  static create(opts) {
    return TooltipRootContext.set(new _TooltipRootState(opts, TooltipProviderContext.get()));
  }
  get delayDuration() {
    return get(__privateGet(this, _delayDuration));
  }
  set delayDuration(value) {
    set(__privateGet(this, _delayDuration), value);
  }
  get disableHoverableContent() {
    return get(__privateGet(this, _disableHoverableContent));
  }
  set disableHoverableContent(value) {
    set(__privateGet(this, _disableHoverableContent), value);
  }
  get disableCloseOnTriggerClick() {
    return get(__privateGet(this, _disableCloseOnTriggerClick));
  }
  set disableCloseOnTriggerClick(value) {
    set(__privateGet(this, _disableCloseOnTriggerClick), value);
  }
  get disabled() {
    return get(__privateGet(this, _disabled));
  }
  set disabled(value) {
    set(__privateGet(this, _disabled), value);
  }
  get ignoreNonKeyboardFocus() {
    return get(__privateGet(this, _ignoreNonKeyboardFocus));
  }
  set ignoreNonKeyboardFocus(value) {
    set(__privateGet(this, _ignoreNonKeyboardFocus), value);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode12));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode12), value, true);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode8));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode8), value, true);
  }
  get stateAttr() {
    return get(__privateGet(this, _stateAttr));
  }
  set stateAttr(value) {
    set(__privateGet(this, _stateAttr), value);
  }
};
_delayDuration = new WeakMap();
_disableHoverableContent = new WeakMap();
_disableCloseOnTriggerClick = new WeakMap();
_disabled = new WeakMap();
_ignoreNonKeyboardFocus = new WeakMap();
_contentNode12 = new WeakMap();
_triggerNode8 = new WeakMap();
_wasOpenDelayed = new WeakMap();
_timerFn2 = new WeakMap();
_stateAttr = new WeakMap();
_handleDelayedOpen = new WeakMap();
var TooltipRootState = _TooltipRootState;
var _isPointerDown2, _hasPointerMoveOpened, _isDisabled18, _transitCheckTimeout, _clearTransitCheck, _onpointerup, _onpointerdown, _onpointerenter, _onpointermove, _onpointerleave, _onfocus, _onblur, _onclick3, _props164;
var _TooltipTriggerState = class _TooltipTriggerState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isPointerDown2, simpleBox(false));
    __privateAdd(this, _hasPointerMoveOpened, state(false));
    __privateAdd(this, _isDisabled18, user_derived(() => this.opts.disabled.current || this.root.disabled));
    __publicField(this, "domContext");
    __privateAdd(this, _transitCheckTimeout, null);
    __privateAdd(this, _clearTransitCheck, () => {
      if (__privateGet(this, _transitCheckTimeout) !== null) {
        clearTimeout(__privateGet(this, _transitCheckTimeout));
        __privateSet(this, _transitCheckTimeout, null);
      }
    });
    __publicField(this, "handlePointerUp", () => {
      __privateGet(this, _isPointerDown2).current = false;
    });
    __privateAdd(this, _onpointerup, () => {
      if (get(__privateGet(this, _isDisabled18))) return;
      __privateGet(this, _isPointerDown2).current = false;
    });
    __privateAdd(this, _onpointerdown, () => {
      if (get(__privateGet(this, _isDisabled18))) return;
      __privateGet(this, _isPointerDown2).current = true;
      this.domContext.getDocument().addEventListener(
        "pointerup",
        () => {
          this.handlePointerUp();
        },
        { once: true }
      );
    });
    __privateAdd(this, _onpointerenter, (e) => {
      if (get(__privateGet(this, _isDisabled18))) return;
      if (e.pointerType === "touch") return;
      if (this.root.provider.isPointerInTransit.current) {
        __privateGet(this, _clearTransitCheck).call(this);
        __privateSet(this, _transitCheckTimeout, window.setTimeout(
          () => {
            if (this.root.provider.isPointerInTransit.current) {
              this.root.provider.isPointerInTransit.current = false;
              this.root.onTriggerEnter();
              set(__privateGet(this, _hasPointerMoveOpened), true);
            }
          },
          250
        ));
        return;
      }
      this.root.onTriggerEnter();
      set(__privateGet(this, _hasPointerMoveOpened), true);
    });
    __privateAdd(this, _onpointermove, (e) => {
      if (get(__privateGet(this, _isDisabled18))) return;
      if (e.pointerType === "touch") return;
      if (get(__privateGet(this, _hasPointerMoveOpened))) return;
      __privateGet(this, _clearTransitCheck).call(this);
      this.root.provider.isPointerInTransit.current = false;
      this.root.onTriggerEnter();
      set(__privateGet(this, _hasPointerMoveOpened), true);
    });
    __privateAdd(this, _onpointerleave, () => {
      if (get(__privateGet(this, _isDisabled18))) return;
      __privateGet(this, _clearTransitCheck).call(this);
      this.root.onTriggerLeave();
      set(__privateGet(this, _hasPointerMoveOpened), false);
    });
    __privateAdd(this, _onfocus, (e) => {
      if (__privateGet(this, _isPointerDown2).current || get(__privateGet(this, _isDisabled18))) return;
      if (this.root.ignoreNonKeyboardFocus && !isFocusVisible(e.currentTarget)) return;
      this.root.handleOpen();
    });
    __privateAdd(this, _onblur, () => {
      if (get(__privateGet(this, _isDisabled18))) return;
      this.root.handleClose();
    });
    __privateAdd(this, _onclick3, () => {
      if (this.root.disableCloseOnTriggerClick || get(__privateGet(this, _isDisabled18))) return;
      this.root.handleClose();
    });
    __privateAdd(this, _props164, user_derived(() => {
      var _a;
      return {
        id: this.opts.id.current,
        "aria-describedby": this.root.opts.open.current ? (_a = this.root.contentNode) == null ? void 0 : _a.id : void 0,
        "data-state": this.root.stateAttr,
        "data-disabled": boolToEmptyStrOrUndef(get(__privateGet(this, _isDisabled18))),
        "data-delay-duration": `${this.root.delayDuration}`,
        [tooltipAttrs.trigger]: "",
        tabindex: get(__privateGet(this, _isDisabled18)) ? void 0 : 0,
        disabled: this.opts.disabled.current,
        onpointerup: __privateGet(this, _onpointerup),
        onpointerdown: __privateGet(this, _onpointerdown),
        onpointerenter: __privateGet(this, _onpointerenter),
        onpointermove: __privateGet(this, _onpointermove),
        onpointerleave: __privateGet(this, _onpointerleave),
        onfocus: __privateGet(this, _onfocus),
        onblur: __privateGet(this, _onblur),
        onclick: __privateGet(this, _onclick3),
        ...this.attachment
      };
    }));
    this.opts = opts;
    this.root = root18;
    this.domContext = new DOMContext(opts.ref);
    this.attachment = attachRef(this.opts.ref, (v) => this.root.triggerNode = v);
  }
  static create(opts) {
    return new _TooltipTriggerState(opts, TooltipRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props164));
  }
  set props(value) {
    set(__privateGet(this, _props164), value);
  }
};
_isPointerDown2 = new WeakMap();
_hasPointerMoveOpened = new WeakMap();
_isDisabled18 = new WeakMap();
_transitCheckTimeout = new WeakMap();
_clearTransitCheck = new WeakMap();
_onpointerup = new WeakMap();
_onpointerdown = new WeakMap();
_onpointerenter = new WeakMap();
_onpointermove = new WeakMap();
_onpointerleave = new WeakMap();
_onfocus = new WeakMap();
_onblur = new WeakMap();
_onclick3 = new WeakMap();
_props164 = new WeakMap();
var TooltipTriggerState = _TooltipTriggerState;
var _snippetProps32, _props165;
var _TooltipContentState = class _TooltipContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __publicField(this, "onInteractOutside", (e) => {
      var _a;
      if (isElement2(e.target) && ((_a = this.root.triggerNode) == null ? void 0 : _a.contains(e.target)) && this.root.disableCloseOnTriggerClick) {
        e.preventDefault();
        return;
      }
      this.opts.onInteractOutside.current(e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onEscapeKeydown", (e) => {
      var _a, _b;
      (_b = (_a = this.opts.onEscapeKeydown).current) == null ? void 0 : _b.call(_a, e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onOpenAutoFocus", (e) => {
      e.preventDefault();
    });
    __publicField(this, "onCloseAutoFocus", (e) => {
      e.preventDefault();
    });
    __privateAdd(this, _snippetProps32, user_derived(() => ({ open: this.root.opts.open.current })));
    __privateAdd(this, _props165, user_derived(() => ({
      id: this.opts.id.current,
      "data-state": this.root.stateAttr,
      "data-disabled": boolToEmptyStrOrUndef(this.root.disabled),
      style: { pointerEvents: "auto", outline: "none" },
      [tooltipAttrs.content]: "",
      ...this.attachment
    })));
    __publicField(this, "popperProps", {
      onInteractOutside: this.onInteractOutside,
      onEscapeKeydown: this.onEscapeKeydown,
      onOpenAutoFocus: this.onOpenAutoFocus,
      onCloseAutoFocus: this.onCloseAutoFocus
    });
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.contentNode = v);
    new GraceArea({
      triggerNode: () => this.root.triggerNode,
      contentNode: () => this.root.contentNode,
      enabled: () => this.root.opts.open.current && !this.root.disableHoverableContent,
      onPointerExit: () => {
        if (this.root.provider.isTooltipOpen(this.root)) {
          this.root.handleClose();
        }
      },
      setIsPointerInTransit: (value) => {
        this.root.provider.isPointerInTransit.current = value;
      },
      transitTimeout: this.root.provider.opts.skipDelayDuration.current
    });
    onMountEffect(() => on(window, "scroll", (e) => {
      const target = e.target;
      if (!target) return;
      if (target.contains(this.root.triggerNode)) {
        this.root.handleClose();
      }
    }));
  }
  static create(opts) {
    return new _TooltipContentState(opts, TooltipRootContext.get());
  }
  get shouldRender() {
    return this.root.contentPresence.shouldRender;
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps32));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps32), value);
  }
  get props() {
    return get(__privateGet(this, _props165));
  }
  set props(value) {
    set(__privateGet(this, _props165), value);
  }
};
_snippetProps32 = new WeakMap();
_props165 = new WeakMap();
var TooltipContentState = _TooltipContentState;

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip.svelte
function Tooltip($$anchor, $$props) {
  push($$props, true);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  TooltipRootState.create({
    open: boxWith(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    delayDuration: boxWith(() => $$props.delayDuration),
    disableCloseOnTriggerClick: boxWith(() => $$props.disableCloseOnTriggerClick),
    disableHoverableContent: boxWith(() => $$props.disableHoverableContent),
    ignoreNonKeyboardFocus: boxWith(() => $$props.ignoreNonKeyboardFocus),
    disabled: boxWith(() => $$props.disabled),
    onOpenChangeComplete: boxWith(() => onOpenChangeComplete())
  });
  Floating_layer($$anchor, {
    tooltip: true,
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      snippet(node, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content.svelte
var root_421 = from_html(`<div><div><!></div></div>`);
var root_915 = from_html(`<div><div><!></div></div>`);
function Tooltip_content($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), side = prop($$props, "side", 3, "top"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), avoidCollisions = prop($$props, "avoidCollisions", 3, true), arrowPadding = prop($$props, "arrowPadding", 3, 0), sticky = prop($$props, "sticky", 3, "partial"), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), collisionPadding = prop($$props, "collisionPadding", 3, 0), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "side",
    "sideOffset",
    "align",
    "avoidCollisions",
    "arrowPadding",
    "sticky",
    "strategy",
    "hideWhenDetached",
    "collisionPadding",
    "onInteractOutside",
    "onEscapeKeydown",
    "forceMount"
  ]);
  const contentState = TooltipContentState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onInteractOutside: boxWith(() => onInteractOutside()),
    onEscapeKeydown: boxWith(() => onEscapeKeydown())
  });
  const floatingProps = user_derived(() => ({
    side: side(),
    sideOffset: sideOffset(),
    align: align(),
    avoidCollisions: avoidCollisions(),
    arrowPadding: arrowPadding(),
    sticky: sticky(),
    hideWhenDetached: hideWhenDetached(),
    collisionPadding: collisionPadding(),
    strategy: $$props.strategy
  }));
  const mergedProps = user_derived(() => mergeProps(restProps, get(floatingProps), contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          var fragment_2 = comment();
          const mergedProps2 = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("tooltip")
          }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(mergedProps2),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_421();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(mergedProps2) }));
              var node_3 = child(div_1);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          trapFocus: false,
          loop: false,
          preventScroll: false,
          forceMount: true,
          get ref() {
            return contentState.opts.ref;
          },
          tooltip: true,
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              var fragment_5 = comment();
              const mergedProps2 = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("tooltip")
              }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(mergedProps2),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_915();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(mergedProps2) }));
                  var node_6 = child(div_3);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              trapFocus: false,
              loop: false,
              preventScroll: false,
              forceMount: false,
              get ref() {
                return contentState.opts.ref;
              },
              tooltip: true,
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content-static.svelte
var root_422 = from_html(`<div><!></div>`);
var root_916 = from_html(`<div><!></div>`);
function Tooltip_content_static($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "ref",
    "onInteractOutside",
    "onEscapeKeydown",
    "forceMount"
  ]);
  const contentState = TooltipContentState.create({
    id: boxWith(() => id()),
    ref: boxWith(() => ref(), (v) => ref(v)),
    onInteractOutside: boxWith(() => onInteractOutside()),
    onEscapeKeydown: boxWith(() => onEscapeKeydown())
  });
  const mergedProps = user_derived(() => mergeProps(restProps, contentState.props));
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      {
        const popper = ($$anchor3, $$arg0) => {
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          var fragment_2 = comment();
          const mergedProps2 = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("tooltip")
          }));
          var node_1 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_2 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(mergedProps2),
                ...contentState.snippetProps
              }));
              snippet(node_2, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_422();
              attribute_effect(div, () => ({ ...get(mergedProps2) }));
              var node_3 = child(div);
              snippet(node_3, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        };
        Popper_layer_force_mount($$anchor2, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          isStatic: true,
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          trapFocus: false,
          loop: false,
          preventScroll: false,
          forceMount: true,
          get ref() {
            return contentState.opts.ref;
          },
          tooltip: true,
          get shouldRender() {
            return contentState.shouldRender;
          },
          popper,
          $$slots: { popper: true }
        }));
      }
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          {
            const popper = ($$anchor4, $$arg0) => {
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              var fragment_5 = comment();
              const mergedProps2 = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("tooltip")
              }));
              var node_4 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_5 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(mergedProps2),
                    ...contentState.snippetProps
                  }));
                  snippet(node_5, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_916();
                  attribute_effect(div_1, () => ({ ...get(mergedProps2) }));
                  var node_6 = child(div_1);
                  snippet(node_6, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_4, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            };
            Popper_layer($$anchor3, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              tooltip: true,
              isStatic: true,
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              trapFocus: false,
              loop: false,
              preventScroll: false,
              forceMount: false,
              get ref() {
                return contentState.opts.ref;
              },
              get shouldRender() {
                return contentState.shouldRender;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-trigger.svelte
var root_322 = from_html(`<button><!></button>`);
function Tooltip_trigger($$anchor, $$props) {
  const uid = props_id();
  push($$props, true);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, [
    "$$slots",
    "$$events",
    "$$legacy",
    "children",
    "child",
    "id",
    "disabled",
    "type",
    "ref"
  ]);
  const triggerState = TooltipTriggerState.create({
    id: boxWith(() => id()),
    disabled: boxWith(() => disabled() ?? false),
    ref: boxWith(() => ref(), (v) => ref(v))
  });
  const mergedProps = user_derived(() => mergeProps(restProps, triggerState.props, { type: type() }));
  Floating_layer_anchor($$anchor, {
    get id() {
      return id();
    },
    get ref() {
      return triggerState.opts.ref;
    },
    tooltip: true,
    children: ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_1 = first_child(fragment_2);
          snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var button = root_322();
          attribute_effect(button, () => ({ ...get(mergedProps) }));
          var node_2 = child(button);
          snippet(node_2, () => $$props.children ?? noop);
          reset(button);
          append($$anchor3, button);
        };
        if_block(node, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    },
    $$slots: { default: true }
  });
  pop();
}

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-arrow.svelte
function Tooltip_arrow($$anchor, $$props) {
  push($$props, true);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref"]);
  Floating_layer_arrow($$anchor, spread_props(() => restProps, {
    get ref() {
      return ref();
    },
    set ref($$value) {
      ref($$value);
    }
  }));
  pop();
}

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-provider.svelte
function Tooltip_provider($$anchor, $$props) {
  push($$props, true);
  let delayDuration = prop($$props, "delayDuration", 3, 700), disableCloseOnTriggerClick = prop($$props, "disableCloseOnTriggerClick", 3, false), disableHoverableContent = prop($$props, "disableHoverableContent", 3, false), disabled = prop($$props, "disabled", 3, false), ignoreNonKeyboardFocus = prop($$props, "ignoreNonKeyboardFocus", 3, false), skipDelayDuration = prop($$props, "skipDelayDuration", 3, 300);
  TooltipProviderState.create({
    delayDuration: boxWith(() => delayDuration()),
    disableCloseOnTriggerClick: boxWith(() => disableCloseOnTriggerClick()),
    disableHoverableContent: boxWith(() => disableHoverableContent()),
    disabled: boxWith(() => disabled()),
    ignoreNonKeyboardFocus: boxWith(() => ignoreNonKeyboardFocus()),
    skipDelayDuration: boxWith(() => skipDelayDuration())
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  pop();
}

// node_modules/bits-ui/dist/bits/utilities/is-using-keyboard/is-using-keyboard.svelte.js
var isUsingKeyboard = state(false);
var _IsUsingKeyboard = class _IsUsingKeyboard {
  constructor() {
    user_effect(() => {
      if (_IsUsingKeyboard._refs === 0) {
        _IsUsingKeyboard._cleanup = effect_root(() => {
          const callbacksToDispose = [];
          const handlePointer = (_) => {
            set(isUsingKeyboard, false);
          };
          const handleKeydown = (_) => {
            set(isUsingKeyboard, true);
          };
          callbacksToDispose.push(on(document, "pointerdown", handlePointer, { capture: true }), on(document, "pointermove", handlePointer, { capture: true }), on(document, "keydown", handleKeydown, { capture: true }));
          return executeCallbacks(...callbacksToDispose);
        });
      }
      _IsUsingKeyboard._refs++;
      return () => {
        var _a;
        _IsUsingKeyboard._refs--;
        if (_IsUsingKeyboard._refs === 0) {
          set(isUsingKeyboard, false);
          (_a = _IsUsingKeyboard._cleanup) == null ? void 0 : _a.call(_IsUsingKeyboard);
        }
      };
    });
  }
  get current() {
    return get(isUsingKeyboard);
  }
  set current(value) {
    set(isUsingKeyboard, value, true);
  }
};
__publicField(_IsUsingKeyboard, "_refs", 0);
// Reference counting to avoid multiple listeners.
__publicField(_IsUsingKeyboard, "_cleanup");
var IsUsingKeyboard = _IsUsingKeyboard;
export {
  exports_exports as Accordion,
  exports_exports2 as AlertDialog,
  exports_exports3 as AspectRatio,
  exports_exports4 as Avatar,
  Bits_config as BitsConfig,
  exports_exports5 as Button,
  exports_exports6 as Calendar,
  exports_exports7 as Checkbox,
  exports_exports8 as Collapsible,
  exports_exports9 as Combobox,
  exports_exports10 as Command,
  exports_exports11 as ContextMenu,
  exports_exports12 as DateField,
  exports_exports13 as DatePicker,
  exports_exports14 as DateRangeField,
  exports_exports15 as DateRangePicker,
  exports_exports16 as Dialog,
  exports_exports17 as DropdownMenu,
  IsUsingKeyboard,
  exports_exports18 as Label,
  exports_exports19 as LinkPreview,
  exports_exports20 as Menubar,
  exports_exports21 as Meter,
  exports_exports22 as NavigationMenu,
  exports_exports23 as Pagination,
  exports_exports24 as PinInput,
  exports_exports25 as Popover,
  Portal,
  exports_exports26 as Progress,
  REGEXP_ONLY_CHARS,
  REGEXP_ONLY_DIGITS,
  REGEXP_ONLY_DIGITS_AND_CHARS,
  exports_exports27 as RadioGroup,
  exports_exports28 as RangeCalendar,
  exports_exports29 as RatingGroup,
  exports_exports30 as ScrollArea,
  exports_exports31 as Select,
  exports_exports32 as Separator,
  exports_exports33 as Slider,
  exports_exports34 as Switch,
  exports_exports35 as Tabs,
  exports_exports36 as TimeField,
  exports_exports37 as TimeRangeField,
  exports_exports38 as Toggle,
  exports_exports39 as ToggleGroup,
  exports_exports40 as Toolbar,
  exports_exports41 as Tooltip,
  computeCommandScore,
  getBitsConfig,
  mergeProps,
  useId
};
//# sourceMappingURL=bits-ui.js.map
