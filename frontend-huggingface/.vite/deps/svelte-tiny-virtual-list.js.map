{
  "version": 3,
  "sources": ["../../node_modules/svelte-tiny-virtual-list/dist/constants.js", "../../node_modules/svelte-tiny-virtual-list/dist/SizeAndPositionManager.js", "../../node_modules/svelte-tiny-virtual-list/dist/VirtualList.svelte"],
  "sourcesContent": ["export const ALIGNMENT = /** @type {const} */ ({\n\tAUTO: 'auto',\n\tSTART: 'start',\n\tCENTER: 'center',\n\tEND: 'end'\n});\n\nexport const DIRECTION = /** @type {const} */ ({\n\tHORIZONTAL: 'horizontal',\n\tVERTICAL: 'vertical'\n});\n\nexport const SCROLL_CHANGE_REASON = {\n\tOBSERVED: 0,\n\tREQUESTED: 1\n};\n\nexport const SCROLL_PROP = /** @type {const} */ ({\n\t[DIRECTION.VERTICAL]: 'top',\n\t[DIRECTION.HORIZONTAL]: 'left'\n});\n\nexport const SCROLL_PROP_LEGACY = /** @type {const} */ ({\n\t[DIRECTION.VERTICAL]: 'scrollTop',\n\t[DIRECTION.HORIZONTAL]: 'scrollLeft'\n});\n", "/*\n * SizeAndPositionManager was forked from react-tiny-virtual-list, which was\n * forked from react-virtualized.\n */\n\nimport { ALIGNMENT } from './constants.js';\n\n/**\n * @callback ItemSizeGetter\n * @param {number} index\n * @return {number}\n */\n\n/**\n * @typedef ItemSize\n * @type {number | number[] | ItemSizeGetter}\n */\n\n/**\n * @typedef SizeAndPosition\n * @type {object}\n * @property {number} size\n * @property {number} offset\n */\n\n/**\n * @typedef SizeAndPositionData\n * @type {Object.<number, SizeAndPosition>}\n */\n\nexport default class SizeAndPositionManager {\n\t/**\n\t * @param {ItemSize} itemSize\n\t * @param {number} itemCount\n\t * @param {number} estimatedItemSize\n\t */\n\tconstructor(itemSize, itemCount, estimatedItemSize) {\n\t\t/**\n\t\t * @private\n\t\t * @type {ItemSize}\n\t\t */\n\t\tthis.itemSize = itemSize;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {number}\n\t\t */\n\t\tthis.itemCount = itemCount;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {number}\n\t\t */\n\t\tthis.estimatedItemSize = estimatedItemSize;\n\n\t\t/**\n\t\t * Cache of size and position data for items, mapped by item index.\n\t\t *\n\t\t * @private\n\t\t * @type {SizeAndPositionData}\n\t\t */\n\t\tthis.itemSizeAndPositionData = {};\n\n\t\t/**\n\t\t * Measurements for items up to this index can be trusted; items afterward should be estimated.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t */\n\t\tthis.lastMeasuredIndex = -1;\n\n\t\tthis.checkForMismatchItemSizeAndItemCount();\n\n\t\tif (!this.justInTime) this.computeTotalSizeAndPositionData();\n\t}\n\n\tget justInTime() {\n\t\treturn typeof this.itemSize === 'function';\n\t}\n\n\t/**\n\t * @param {ItemSize} itemSize\n\t * @param {number} itemCount\n\t * @param {number} estimatedItemSize\n\t */\n\tupdateConfig(itemSize, itemCount, estimatedItemSize) {\n\t\tthis.itemSize = itemSize;\n\t\tthis.itemCount = itemCount;\n\t\tthis.estimatedItemSize = estimatedItemSize;\n\n\t\tthis.checkForMismatchItemSizeAndItemCount();\n\n\t\tif (this.justInTime && this.totalSize != null) {\n\t\t\tthis.totalSize = undefined;\n\t\t} else {\n\t\t\tthis.computeTotalSizeAndPositionData();\n\t\t}\n\t}\n\n\tcheckForMismatchItemSizeAndItemCount() {\n\t\tif (Array.isArray(this.itemSize) && this.itemSize.length < this.itemCount) {\n\t\t\tthrow Error(`When itemSize is an array, itemSize.length can't be smaller than itemCount`);\n\t\t}\n\t}\n\n\t/**\n\t * @param {number} index\n\t */\n\tgetSize(index) {\n\t\tconst { itemSize } = this;\n\n\t\tif (typeof itemSize === 'function') {\n\t\t\treturn itemSize(index);\n\t\t}\n\n\t\treturn Array.isArray(itemSize) ? itemSize[index] : itemSize;\n\t}\n\n\t/**\n\t * Compute the totalSize and itemSizeAndPositionData at the start,\n\t * only when itemSize is a number or an array.\n\t */\n\tcomputeTotalSizeAndPositionData() {\n\t\tlet totalSize = 0;\n\t\tfor (let i = 0; i < this.itemCount; i++) {\n\t\t\tconst size = this.getSize(i);\n\t\t\tconst offset = totalSize;\n\t\t\ttotalSize += size;\n\n\t\t\tthis.itemSizeAndPositionData[i] = {\n\t\t\t\toffset,\n\t\t\t\tsize\n\t\t\t};\n\t\t}\n\n\t\tthis.totalSize = totalSize;\n\t}\n\n\tgetLastMeasuredIndex() {\n\t\treturn this.lastMeasuredIndex;\n\t}\n\n\t/**\n\t * This method returns the size and position for the item at the specified index.\n\t *\n\t * @param {number} index\n\t */\n\tgetSizeAndPositionForIndex(index) {\n\t\tif (index < 0 || index >= this.itemCount) {\n\t\t\tthrow Error(`Requested index ${index} is outside of range 0..${this.itemCount}`);\n\t\t}\n\n\t\treturn this.justInTime\n\t\t\t? this.getJustInTimeSizeAndPositionForIndex(index)\n\t\t\t: this.itemSizeAndPositionData[index];\n\t}\n\n\t/**\n\t * This is used when itemSize is a function.\n\t * just-in-time calculates (or used cached values) for items leading up to the index.\n\t *\n\t * @param {number} index\n\t */\n\tgetJustInTimeSizeAndPositionForIndex(index) {\n\t\tif (index > this.lastMeasuredIndex) {\n\t\t\tconst lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\t\t\tlet offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n\n\t\t\tfor (let i = this.lastMeasuredIndex + 1; i <= index; i++) {\n\t\t\t\tconst size = this.getSize(i);\n\n\t\t\t\tif (size == null || Number.isNaN(size)) {\n\t\t\t\t\tthrow Error(`Invalid size returned for index ${i} of value ${size}`);\n\t\t\t\t}\n\n\t\t\t\tthis.itemSizeAndPositionData[i] = {\n\t\t\t\t\toffset,\n\t\t\t\t\tsize\n\t\t\t\t};\n\n\t\t\t\toffset += size;\n\t\t\t}\n\n\t\t\tthis.lastMeasuredIndex = index;\n\t\t}\n\n\t\treturn this.itemSizeAndPositionData[index];\n\t}\n\n\tgetSizeAndPositionOfLastMeasuredItem() {\n\t\treturn this.lastMeasuredIndex >= 0\n\t\t\t? this.itemSizeAndPositionData[this.lastMeasuredIndex]\n\t\t\t: { offset: 0, size: 0 };\n\t}\n\n\t/**\n\t * Total size of all items being measured.\n\t *\n\t * @return {number}\n\t */\n\tgetTotalSize() {\n\t\t// Return the pre computed totalSize when itemSize is number or array.\n\t\tif (this.totalSize) return this.totalSize;\n\n\t\t/**\n\t\t * When itemSize is a function,\n\t\t * This value will be completedly estimated initially.\n\t\t * As items as measured the estimate will be updated.\n\t\t */\n\t\tconst lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\n\t\treturn (\n\t\t\tlastMeasuredSizeAndPosition.offset +\n\t\t\tlastMeasuredSizeAndPosition.size +\n\t\t\t(this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize\n\t\t);\n\t}\n\n\t/**\n\t * Determines a new offset that ensures a certain item is visible, given the alignment.\n\t *\n\t * @param {'auto' | 'start' | 'center' | 'end'} align Desired alignment within container\n\t * @param {number | undefined} containerSize Size (width or height) of the container viewport\n\t * @param {number | undefined} currentOffset\n\t * @param {number | undefined} targetIndex\n\t * @return {number} Offset to use to ensure the specified item is visible\n\t */\n\tgetUpdatedOffsetForIndex(align, containerSize, currentOffset, targetIndex) {\n\t\tif (containerSize <= 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst datum = this.getSizeAndPositionForIndex(targetIndex);\n\t\tconst maxOffset = datum.offset;\n\t\tconst minOffset = maxOffset - containerSize + datum.size;\n\n\t\tlet idealOffset;\n\n\t\tswitch (align) {\n\t\t\tcase ALIGNMENT.END:\n\t\t\t\tidealOffset = minOffset;\n\t\t\t\tbreak;\n\t\t\tcase ALIGNMENT.CENTER:\n\t\t\t\tidealOffset = maxOffset - (containerSize - datum.size) / 2;\n\t\t\t\tbreak;\n\t\t\tcase ALIGNMENT.START:\n\t\t\t\tidealOffset = maxOffset;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tidealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n\t\t}\n\n\t\tconst totalSize = this.getTotalSize();\n\n\t\treturn Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n\t}\n\n\t/**\n\t * @param {number} containerSize\n\t * @param {number} offset\n\t * @param {number} overscanCount\n\t * @return {{start: number|undefined, end: number|undefined}}\n\t */\n\tgetVisibleRange(containerSize, offset, overscanCount) {\n\t\tconst totalSize = this.getTotalSize();\n\n\t\tif (totalSize === 0) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst maxOffset = offset + containerSize;\n\t\tlet start = this.findNearestItem(offset);\n\n\t\tif (start === undefined) {\n\t\t\tthrow Error(`Invalid offset ${offset} specified`);\n\t\t}\n\n\t\tconst datum = this.getSizeAndPositionForIndex(start);\n\t\toffset = datum.offset + datum.size;\n\n\t\tlet end = start;\n\n\t\twhile (offset < maxOffset && end < this.itemCount - 1) {\n\t\t\tend++;\n\t\t\toffset += this.getSizeAndPositionForIndex(end).size;\n\t\t}\n\n\t\tif (overscanCount) {\n\t\t\tstart = Math.max(0, start - overscanCount);\n\t\t\tend = Math.min(end + overscanCount, this.itemCount - 1);\n\t\t}\n\n\t\treturn {\n\t\t\tstart,\n\t\t\tend\n\t\t};\n\t}\n\n\t/**\n\t * Clear all cached values for items after the specified index.\n\t * This method should be called for any item that has changed its size.\n\t * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n\t *\n\t * @param {number} index\n\t */\n\tresetItem(index) {\n\t\tthis.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\n\t}\n\n\t/**\n\t * Searches for the item (index) nearest the specified offset.\n\t *\n\t * If no exact match is found the next lowest item index will be returned.\n\t * This allows partially visible items (with offsets just before/above the fold) to be visible.\n\t *\n\t * @param {number} offset\n\t */\n\tfindNearestItem(offset) {\n\t\tif (Number.isNaN(offset)) {\n\t\t\tthrow Error(`Invalid offset ${offset} specified`);\n\t\t}\n\n\t\t// Our search algorithms find the nearest match at or below the specified offset.\n\t\t// So make sure the offset is at least 0 or no match will be found.\n\t\toffset = Math.max(0, offset);\n\n\t\tconst lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\t\tconst lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\n\n\t\tif (lastMeasuredSizeAndPosition.offset >= offset) {\n\t\t\t// If we've already measured items within this range just use a binary search as it's faster.\n\t\t\treturn this.binarySearch(lastMeasuredIndex, 0, offset);\n\t\t} else {\n\t\t\t// If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n\t\t\t// The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n\t\t\t// The overall complexity for this approach is O(log n).\n\t\t\treturn this.exponentialSearch(lastMeasuredIndex, offset);\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {number} high\n\t * @param {number} low\n\t * @param {number} offset\n\t */\n\tbinarySearch(high, low, offset) {\n\t\tlet middle = 0;\n\t\tlet currentOffset = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmiddle = low + Math.floor((high - low) / 2);\n\t\t\tcurrentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n\t\t\tif (currentOffset === offset) {\n\t\t\t\treturn middle;\n\t\t\t} else if (currentOffset < offset) {\n\t\t\t\tlow = middle + 1;\n\t\t\t} else if (currentOffset > offset) {\n\t\t\t\thigh = middle - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (low > 0) {\n\t\t\treturn low - 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/**\n\t * @private\n\t * @param {number} index\n\t * @param {number} offset\n\t */\n\texponentialSearch(index, offset) {\n\t\tlet interval = 1;\n\n\t\twhile (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n\t\t\tindex += interval;\n\t\t\tinterval *= 2;\n\t\t}\n\n\t\treturn this.binarySearch(Math.min(index, this.itemCount - 1), Math.floor(index / 2), offset);\n\t}\n}\n", "<script>\n\timport { untrack } from 'svelte';\n\timport SizeAndPositionManager from './SizeAndPositionManager.js';\n\timport {\n\t\tALIGNMENT,\n\t\tDIRECTION,\n\t\tSCROLL_CHANGE_REASON,\n\t\tSCROLL_PROP,\n\t\tSCROLL_PROP_LEGACY\n\t} from './constants.js';\n\t/** @import { VirtualListProps, VirtualListEvents, VirtualListSnippets } from './types.js'; */\n\n\t/** @type {VirtualListProps & VirtualListEvents & VirtualListSnippets} */\n\tlet {\n\t\t/* Props: */\n\n\t\theight = '100%',\n\t\twidth = '100%',\n\n\t\titemCount,\n\t\titemSize,\n\t\testimatedItemSize: optEstimatedItemSize,\n\t\tstickyIndices = [],\n\t\tgetKey,\n\n\t\tscrollDirection = DIRECTION.VERTICAL,\n\t\tscrollOffset,\n\t\tscrollToIndex,\n\t\tscrollToAlignment = ALIGNMENT.START,\n\t\tscrollToBehaviour = 'instant',\n\n\t\toverscanCount = 3,\n\n\t\t/* Events: */\n\n\t\tonItemsUpdated: handleItemsUpdated,\n\t\tonListItemsUpdate: handleListItemsUpdate, // DEPRECATED\n\n\t\tonAfterScroll: handleAfterScroll,\n\n\t\t/* Snippets: */\n\n\t\titem: itemSnippet,\n\t\tchildren: childrenSnippet, // DEPRECATED\n\n\t\theader: headerSnippet,\n\t\tfooter: footerSnippet\n\t} = $props();\n\n\tlet estimatedItemSize = $derived(\n\t\toptEstimatedItemSize || (typeof itemSize === 'number' && itemSize) || 50\n\t);\n\tconst sizeAndPositionManager = new SizeAndPositionManager(itemSize, itemCount, estimatedItemSize);\n\n\t/** @type {HTMLDivElement} */\n\tlet wrapper;\n\tlet wrapperHeight = $state(400);\n\tlet wrapperWidth = $state(400);\n\t/** @type {{ index: number, style: string }[]} */\n\tlet items = $state.raw([]);\n\n\t/** @type {{ offset: number, changeReason: number }} */\n\tlet scroll = $state.raw({\n\t\toffset: scrollOffset || (scrollToIndex !== undefined && getOffsetForIndex(scrollToIndex)) || 0,\n\t\tchangeReason: SCROLL_CHANGE_REASON.REQUESTED\n\t});\n\tlet prevScroll = $state.snapshot(scroll);\n\n\tlet heightNumber = $derived(Number.isFinite(height) ? Number(height) : wrapperHeight);\n\tlet widthNumber = $derived(Number.isFinite(width) ? Number(width) : wrapperWidth);\n\tlet prevProps = {\n\t\tscrollToIndex: $state.snapshot(scrollToIndex),\n\t\tscrollToAlignment: $state.snapshot(scrollToAlignment),\n\t\tscrollOffset: $state.snapshot(scrollOffset),\n\t\titemCount: $state.snapshot(itemCount),\n\t\titemSize: typeof itemSize === 'function' ? itemSize : $state.snapshot(itemSize),\n\t\testimatedItemSize: $state.snapshot(estimatedItemSize),\n\t\theightNumber: $state.snapshot(heightNumber),\n\t\twidthNumber: $state.snapshot(widthNumber),\n\t\tstickyIndices: $state.snapshot(stickyIndices)\n\t};\n\n\t/** @type {Record<number, string>} */\n\tlet styleCache = $state({});\n\tlet wrapperStyle = $state.raw('');\n\tlet innerStyle = $state.raw('');\n\n\t// Effect 0: Event listener\n\t$effect(() => {\n\t\t/** @type {number | undefined} */\n\t\tlet frame;\n\t\t/** @param {Event} event */\n\t\tconst handleScrollAsync = (event) => {\n\t\t\tif (frame !== undefined) {\n\t\t\t\tcancelAnimationFrame(frame);\n\t\t\t}\n\t\t\tframe = requestAnimationFrame(() => {\n\t\t\t\thandleScroll(event);\n\t\t\t\tframe = undefined;\n\t\t\t});\n\t\t};\n\n\t\tconst options = { passive: true };\n\t\twrapper.addEventListener('scroll', handleScrollAsync, options);\n\n\t\treturn () => {\n\t\t\t// @ts-expect-error because options is not really needed, but maybe in the future\n\t\t\twrapper.removeEventListener('scroll', handleScrollAsync, options);\n\t\t};\n\t});\n\n\t// Effect 1: Update props from user provided props\n\t$effect(() => {\n\t\tscrollToIndex;\n\t\tscrollToAlignment;\n\t\tscrollOffset;\n\t\titemCount;\n\t\titemSize;\n\t\testimatedItemSize;\n\t\theightNumber;\n\t\twidthNumber;\n\t\tstickyIndices;\n\n\t\tuntrack(propsUpdated);\n\t});\n\n\t// Effect 2: Update scroll\n\t$effect(() => {\n\t\tscroll;\n\n\t\tuntrack(scrollUpdated);\n\t});\n\n\tfunction propsUpdated() {\n\t\tconst scrollPropsHaveChanged =\n\t\t\tprevProps.scrollToIndex !== scrollToIndex ||\n\t\t\tprevProps.scrollToAlignment !== scrollToAlignment;\n\t\tconst itemPropsHaveChanged =\n\t\t\tprevProps.itemCount !== itemCount ||\n\t\t\tprevProps.itemSize !== itemSize ||\n\t\t\tprevProps.estimatedItemSize !== estimatedItemSize;\n\n\t\tlet forceRecomputeSizes = false;\n\t\tif (itemPropsHaveChanged) {\n\t\t\tsizeAndPositionManager.updateConfig(itemSize, itemCount, estimatedItemSize);\n\n\t\t\tforceRecomputeSizes = true;\n\t\t}\n\n\t\tif (prevProps.scrollOffset !== scrollOffset) {\n\t\t\tscroll = {\n\t\t\t\toffset: scrollOffset || 0,\n\t\t\t\tchangeReason: SCROLL_CHANGE_REASON.REQUESTED\n\t\t\t};\n\t\t} else if (\n\t\t\ttypeof scrollToIndex === 'number' &&\n\t\t\t(scrollPropsHaveChanged || itemPropsHaveChanged)\n\t\t) {\n\t\t\tscroll = {\n\t\t\t\toffset: getOffsetForIndex(scrollToIndex),\n\t\t\t\tchangeReason: SCROLL_CHANGE_REASON.REQUESTED\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tforceRecomputeSizes ||\n\t\t\tprevProps.heightNumber !== heightNumber ||\n\t\t\tprevProps.widthNumber !== widthNumber ||\n\t\t\tprevProps.stickyIndices.toString() !== $state.snapshot(stickyIndices).toString()\n\t\t) {\n\t\t\trecomputeSizes();\n\t\t}\n\n\t\tprevProps = {\n\t\t\tscrollToIndex: $state.snapshot(scrollToIndex),\n\t\t\tscrollToAlignment: $state.snapshot(scrollToAlignment),\n\t\t\tscrollOffset: $state.snapshot(scrollOffset),\n\t\t\titemCount: $state.snapshot(itemCount),\n\t\t\titemSize: typeof itemSize === 'function' ? itemSize : $state.snapshot(itemSize),\n\t\t\testimatedItemSize: $state.snapshot(estimatedItemSize),\n\t\t\theightNumber: $state.snapshot(heightNumber),\n\t\t\twidthNumber: $state.snapshot(widthNumber),\n\t\t\tstickyIndices: $state.snapshot(stickyIndices)\n\t\t};\n\t}\n\n\tfunction scrollUpdated() {\n\t\tif (prevScroll.offset !== scroll.offset || prevScroll.changeReason !== scroll.changeReason) {\n\t\t\trefresh();\n\t\t}\n\n\t\tif (\n\t\t\tprevScroll.offset !== scroll.offset &&\n\t\t\tscroll.changeReason === SCROLL_CHANGE_REASON.REQUESTED\n\t\t) {\n\t\t\twrapper.scroll({\n\t\t\t\t[SCROLL_PROP[scrollDirection]]: scroll.offset,\n\t\t\t\tbehavior: scrollToBehaviour\n\t\t\t});\n\t\t}\n\n\t\tprevScroll = $state.snapshot(scroll);\n\t}\n\n\t/**\n\t * Recomputes the sizes of the items and updates the visible items.\n\t */\n\tfunction refresh() {\n\t\tconst { start, end } = sizeAndPositionManager.getVisibleRange(\n\t\t\tscrollDirection === DIRECTION.VERTICAL ? heightNumber : widthNumber,\n\t\t\tscroll.offset,\n\t\t\toverscanCount\n\t\t);\n\n\t\t/** @type {{ index: number, style: string }[]} */\n\t\tconst visibleItems = [];\n\n\t\tconst totalSize = sizeAndPositionManager.getTotalSize();\n\t\tconst heightUnit = typeof height === 'number' ? 'px' : '';\n\t\tconst widthUnit = typeof width === 'number' ? 'px' : '';\n\n\t\twrapperStyle = `height:${height}${heightUnit};width:${width}${widthUnit};`;\n\t\tif (scrollDirection === DIRECTION.VERTICAL) {\n\t\t\tinnerStyle = `flex-direction:column;height:${totalSize}px;`;\n\t\t} else {\n\t\t\tinnerStyle = `min-height:100%;width:${totalSize}px;`;\n\t\t}\n\n\t\tconst hasStickyIndices = stickyIndices.length > 0;\n\t\tif (hasStickyIndices) {\n\t\t\tfor (const index of stickyIndices) {\n\t\t\t\tvisibleItems.push({\n\t\t\t\t\tindex,\n\t\t\t\t\tstyle: getStyle(index, true)\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (start !== undefined && end !== undefined) {\n\t\t\tfor (let index = start; index <= end; index++) {\n\t\t\t\tif (hasStickyIndices && stickyIndices.includes(index)) continue;\n\n\t\t\t\tvisibleItems.push({\n\t\t\t\t\tindex,\n\t\t\t\t\tstyle: getStyle(index, false)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (handleItemsUpdated) handleItemsUpdated({ start, end });\n\t\t\tif (handleListItemsUpdate) handleListItemsUpdate({ start, end }); // DEPRECATED\n\t\t}\n\n\t\titems = visibleItems;\n\t}\n\n\t/**\n\t * Recomputes the sizes of the items in the list.\n\t */\n\texport function recomputeSizes(startIndex = scrollToIndex) {\n\t\tstyleCache = {};\n\t\tif (startIndex !== undefined && startIndex >= 0) {\n\t\t\tsizeAndPositionManager.resetItem(startIndex);\n\t\t}\n\t\trefresh();\n\t}\n\n\t/**\n\t * Calculates the offset for a given index based on the scroll direction and alignment.\n\t * @param {number} index\n\t */\n\tfunction getOffsetForIndex(index) {\n\t\tif (index < 0 || index >= itemCount) index = 0;\n\n\t\treturn sizeAndPositionManager.getUpdatedOffsetForIndex(\n\t\t\tscrollToAlignment,\n\t\t\tscrollDirection === DIRECTION.VERTICAL ? heightNumber : widthNumber,\n\t\t\tscroll.offset || 0,\n\t\t\tindex\n\t\t);\n\t}\n\n\t/**\n\t * Handles the scroll event on the wrapper element.\n\t * @param {Event} event\n\t */\n\tfunction handleScroll(event) {\n\t\tconst offset = wrapper[SCROLL_PROP_LEGACY[scrollDirection]];\n\n\t\tif (offset < 0 || scroll.offset === offset || event.target !== wrapper) return;\n\n\t\tscroll = { offset, changeReason: SCROLL_CHANGE_REASON.OBSERVED };\n\n\t\tif (handleAfterScroll) handleAfterScroll({ offset, event });\n\t}\n\n\t/**\n\t * Returns the style for a given item index.\n\t * @param {number} index The index of the item\n\t * @param {boolean} sticky Whether the item should be sticky or not\n\t */\n\tfunction getStyle(index, sticky) {\n\t\tif (styleCache[index]) return styleCache[index];\n\n\t\tconst { size, offset } = sizeAndPositionManager.getSizeAndPositionForIndex(index);\n\n\t\tlet style;\n\t\tif (scrollDirection === DIRECTION.VERTICAL) {\n\t\t\tstyle = `left:0;width:100%;height:${size}px;`;\n\n\t\t\tif (sticky) {\n\t\t\t\tstyle += `position:sticky;flex-grow:0;z-index:1;top:0;margin-top:${offset}px;margin-bottom:${-(offset + size)}px;`;\n\t\t\t} else {\n\t\t\t\tstyle += `position:absolute;top:${offset}px;`;\n\t\t\t}\n\t\t} else {\n\t\t\tstyle = `top:0;width:${size}px;`;\n\n\t\t\tif (sticky) {\n\t\t\t\tstyle += `position:sticky;z-index:1;left:0;margin-left:${offset}px;margin-right:${-(offset + size)}px;`;\n\t\t\t} else {\n\t\t\t\tstyle += `position:absolute;height:100%;left:${offset}px;`;\n\t\t\t}\n\t\t}\n\n\t\tstyleCache[index] = style;\n\t\treturn styleCache[index];\n\t}\n</script>\n\n<div\n\tbind:this={wrapper}\n\tbind:offsetHeight={wrapperHeight}\n\tbind:offsetWidth={wrapperWidth}\n\tclass=\"virtual-list-wrapper\"\n\tstyle={wrapperStyle}\n>\n\t{#if headerSnippet}\n\t\t{@render headerSnippet()}\n\t{/if}\n\n\t<div class=\"virtual-list-inner\" style={innerStyle}>\n\t\t{#each items as item (getKey ? getKey(item.index) : item.index)}\n\t\t\t{@render (childrenSnippet || itemSnippet)({ style: item.style, index: item.index })}\n\t\t{/each}\n\t</div>\n\n\t{#if footerSnippet}\n\t\t{@render footerSnippet()}\n\t{/if}\n</div>\n\n<style>\n\t.virtual-list-wrapper {\n\t\toverflow: auto;\n\t\twill-change: transform;\n\t\t-webkit-overflow-scrolling: touch;\n\t}\n\n\t.virtual-list-inner {\n\t\tposition: relative;\n\t\tdisplay: flex;\n\t\twidth: 100%;\n\t}\n</style>\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,IAAM;AAAA;AAAA,EAAkC;AAAA,IAC9C,MAAM;AAAA,IACN,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,KAAK;AAAA,EACN;AAAA;AAEO,IAAM;AAAA;AAAA,EAAkC;AAAA,IAC9C,YAAY;AAAA,IACZ,UAAU;AAAA,EACX;AAAA;AAEO,IAAM,uBAAuB;AAAA,EACnC,UAAU;AAAA,EACV,WAAW;AACZ;AAEO,IAAM;AAAA;AAAA,EAAoC;AAAA,IAChD,CAAC,UAAU,QAAQ,GAAG;AAAA,IACtB,CAAC,UAAU,UAAU,GAAG;AAAA,EACzB;AAAA;AAEO,IAAM;AAAA;AAAA,EAA2C;AAAA,IACvD,CAAC,UAAU,QAAQ,GAAG;AAAA,IACtB,CAAC,UAAU,UAAU,GAAG;AAAA,EACzB;AAAA;;;ACKA,IAAqB,yBAArB,MAA4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM3C,YAAY,UAAU,WAAW,mBAAmB;AAKnD,SAAK,WAAW;AAMhB,SAAK,YAAY;AAMjB,SAAK,oBAAoB;AAQzB,SAAK,0BAA0B,CAAC;AAQhC,SAAK,oBAAoB;AAEzB,SAAK,qCAAqC;AAE1C,QAAI,CAAC,KAAK,WAAY,MAAK,gCAAgC;AAAA,EAC5D;AAAA,EAEA,IAAI,aAAa;AAChB,WAAO,OAAO,KAAK,aAAa;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,UAAU,WAAW,mBAAmB;AACpD,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,oBAAoB;AAEzB,SAAK,qCAAqC;AAE1C,QAAI,KAAK,cAAc,KAAK,aAAa,MAAM;AAC9C,WAAK,YAAY;AAAA,IAClB,OAAO;AACN,WAAK,gCAAgC;AAAA,IACtC;AAAA,EACD;AAAA,EAEA,uCAAuC;AACtC,QAAI,MAAM,QAAQ,KAAK,QAAQ,KAAK,KAAK,SAAS,SAAS,KAAK,WAAW;AAC1E,YAAM,MAAM,4EAA4E;AAAA,IACzF;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,OAAO;AACd,UAAM,EAAE,SAAS,IAAI;AAErB,QAAI,OAAO,aAAa,YAAY;AACnC,aAAO,SAAS,KAAK;AAAA,IACtB;AAEA,WAAO,MAAM,QAAQ,QAAQ,IAAI,SAAS,KAAK,IAAI;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kCAAkC;AACjC,QAAI,YAAY;AAChB,aAAS,IAAI,GAAG,IAAI,KAAK,WAAW,KAAK;AACxC,YAAM,OAAO,KAAK,QAAQ,CAAC;AAC3B,YAAM,SAAS;AACf,mBAAa;AAEb,WAAK,wBAAwB,CAAC,IAAI;AAAA,QACjC;AAAA,QACA;AAAA,MACD;AAAA,IACD;AAEA,SAAK,YAAY;AAAA,EAClB;AAAA,EAEA,uBAAuB;AACtB,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,2BAA2B,OAAO;AACjC,QAAI,QAAQ,KAAK,SAAS,KAAK,WAAW;AACzC,YAAM,MAAM,mBAAmB,KAAK,2BAA2B,KAAK,SAAS,EAAE;AAAA,IAChF;AAEA,WAAO,KAAK,aACT,KAAK,qCAAqC,KAAK,IAC/C,KAAK,wBAAwB,KAAK;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,qCAAqC,OAAO;AAC3C,QAAI,QAAQ,KAAK,mBAAmB;AACnC,YAAM,8BAA8B,KAAK,qCAAqC;AAC9E,UAAI,SAAS,4BAA4B,SAAS,4BAA4B;AAE9E,eAAS,IAAI,KAAK,oBAAoB,GAAG,KAAK,OAAO,KAAK;AACzD,cAAM,OAAO,KAAK,QAAQ,CAAC;AAE3B,YAAI,QAAQ,QAAQ,OAAO,MAAM,IAAI,GAAG;AACvC,gBAAM,MAAM,mCAAmC,CAAC,aAAa,IAAI,EAAE;AAAA,QACpE;AAEA,aAAK,wBAAwB,CAAC,IAAI;AAAA,UACjC;AAAA,UACA;AAAA,QACD;AAEA,kBAAU;AAAA,MACX;AAEA,WAAK,oBAAoB;AAAA,IAC1B;AAEA,WAAO,KAAK,wBAAwB,KAAK;AAAA,EAC1C;AAAA,EAEA,uCAAuC;AACtC,WAAO,KAAK,qBAAqB,IAC9B,KAAK,wBAAwB,KAAK,iBAAiB,IACnD,EAAE,QAAQ,GAAG,MAAM,EAAE;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAe;AAEd,QAAI,KAAK,UAAW,QAAO,KAAK;AAOhC,UAAM,8BAA8B,KAAK,qCAAqC;AAE9E,WACC,4BAA4B,SAC5B,4BAA4B,QAC3B,KAAK,YAAY,KAAK,oBAAoB,KAAK,KAAK;AAAA,EAEvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,yBAAyB,OAAO,eAAe,eAAe,aAAa;AAC1E,QAAI,iBAAiB,GAAG;AACvB,aAAO;AAAA,IACR;AAEA,UAAM,QAAQ,KAAK,2BAA2B,WAAW;AACzD,UAAM,YAAY,MAAM;AACxB,UAAM,YAAY,YAAY,gBAAgB,MAAM;AAEpD,QAAI;AAEJ,YAAQ,OAAO;AAAA,MACd,KAAK,UAAU;AACd,sBAAc;AACd;AAAA,MACD,KAAK,UAAU;AACd,sBAAc,aAAa,gBAAgB,MAAM,QAAQ;AACzD;AAAA,MACD,KAAK,UAAU;AACd,sBAAc;AACd;AAAA,MACD;AACC,sBAAc,KAAK,IAAI,WAAW,KAAK,IAAI,WAAW,aAAa,CAAC;AAAA,IACtE;AAEA,UAAM,YAAY,KAAK,aAAa;AAEpC,WAAO,KAAK,IAAI,GAAG,KAAK,IAAI,YAAY,eAAe,WAAW,CAAC;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,gBAAgB,eAAe,QAAQ,eAAe;AACrD,UAAM,YAAY,KAAK,aAAa;AAEpC,QAAI,cAAc,GAAG;AACpB,aAAO,CAAC;AAAA,IACT;AAEA,UAAM,YAAY,SAAS;AAC3B,QAAI,QAAQ,KAAK,gBAAgB,MAAM;AAEvC,QAAI,UAAU,QAAW;AACxB,YAAM,MAAM,kBAAkB,MAAM,YAAY;AAAA,IACjD;AAEA,UAAM,QAAQ,KAAK,2BAA2B,KAAK;AACnD,aAAS,MAAM,SAAS,MAAM;AAE9B,QAAI,MAAM;AAEV,WAAO,SAAS,aAAa,MAAM,KAAK,YAAY,GAAG;AACtD;AACA,gBAAU,KAAK,2BAA2B,GAAG,EAAE;AAAA,IAChD;AAEA,QAAI,eAAe;AAClB,cAAQ,KAAK,IAAI,GAAG,QAAQ,aAAa;AACzC,YAAM,KAAK,IAAI,MAAM,eAAe,KAAK,YAAY,CAAC;AAAA,IACvD;AAEA,WAAO;AAAA,MACN;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,UAAU,OAAO;AAChB,SAAK,oBAAoB,KAAK,IAAI,KAAK,mBAAmB,QAAQ,CAAC;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,gBAAgB,QAAQ;AACvB,QAAI,OAAO,MAAM,MAAM,GAAG;AACzB,YAAM,MAAM,kBAAkB,MAAM,YAAY;AAAA,IACjD;AAIA,aAAS,KAAK,IAAI,GAAG,MAAM;AAE3B,UAAM,8BAA8B,KAAK,qCAAqC;AAC9E,UAAM,oBAAoB,KAAK,IAAI,GAAG,KAAK,iBAAiB;AAE5D,QAAI,4BAA4B,UAAU,QAAQ;AAEjD,aAAO,KAAK,aAAa,mBAAmB,GAAG,MAAM;AAAA,IACtD,OAAO;AAIN,aAAO,KAAK,kBAAkB,mBAAmB,MAAM;AAAA,IACxD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAa,MAAM,KAAK,QAAQ;AAC/B,QAAI,SAAS;AACb,QAAI,gBAAgB;AAEpB,WAAO,OAAO,MAAM;AACnB,eAAS,MAAM,KAAK,OAAO,OAAO,OAAO,CAAC;AAC1C,sBAAgB,KAAK,2BAA2B,MAAM,EAAE;AAExD,UAAI,kBAAkB,QAAQ;AAC7B,eAAO;AAAA,MACR,WAAW,gBAAgB,QAAQ;AAClC,cAAM,SAAS;AAAA,MAChB,WAAW,gBAAgB,QAAQ;AAClC,eAAO,SAAS;AAAA,MACjB;AAAA,IACD;AAEA,QAAI,MAAM,GAAG;AACZ,aAAO,MAAM;AAAA,IACd;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,kBAAkB,OAAO,QAAQ;AAChC,QAAI,WAAW;AAEf,WAAO,QAAQ,KAAK,aAAa,KAAK,2BAA2B,KAAK,EAAE,SAAS,QAAQ;AACxF,eAAS;AACT,kBAAY;AAAA,IACb;AAEA,WAAO,KAAK,aAAa,KAAK,IAAI,OAAO,KAAK,YAAY,CAAC,GAAG,KAAK,MAAM,QAAQ,CAAC,GAAG,MAAM;AAAA,EAC5F;AACD;;;;;;;;;;;MCjXE,SAAM,KAAA,SAAA,UAAA,GAAG,MAAM,GACf,QAAK,KAAA,SAAA,SAAA,GAAG,MAAM,GAKd,gBAAa,KAAA,SAAA,iBAAA,IAAA,MAAA,CAAA,CAAA,GAGb,kBAAe,KAAA,SAAA,mBAAA,IAAA,MAAG,UAAU,QAAQ,GAGpC,oBAAiB,KAAA,SAAA,qBAAA,IAAA,MAAG,UAAU,KAAK,GACnC,oBAAiB,KAAA,SAAA,qBAAA,GAAG,SAAS,GAE7B,gBAAa,KAAA,SAAA,iBAAA,GAAG,CAAC;MAkBd,oBAAiB,aAAA,MAAA,QAAA,qBAAA,OAAA,QAAA,aACyB,YAAQ,QAAA,YAAiB,EAAA;QAEjE,yBAAsB,IAAO,uBAAsB,QAAA,UAAA,QAAA,WAAA,IAAsB,iBAAiB,CAAA;MAG5F;MACA,gBAAa,MAAU,GAAG;MAC1B,eAAY,MAAU,GAAG;MAEzB,QAAK,MAAA,CAAA,CAAA;MAGL,SAAM,MAAA;IACT,QAAM,QAAA,gBAAA,QAAA,kBAAqC,UAAa,kBAAiB,QAAA,aAAA,KAAoB;IAC7F,cAAc,qBAAqB;;MAEhC,aAAU,SAAA,IAAmB,MAAM,CAAA;MAEnC,eAAY,aAAA,MAAY,OAAO,SAAS,OAAM,CAAA,IAAI,OAAO,OAAM,CAAA,IAAA,IAAI,aAAa,CAAA;MAChF,cAAW,aAAA,MAAY,OAAO,SAAS,MAAK,CAAA,IAAI,OAAO,MAAK,CAAA,IAAA,IAAI,YAAY,CAAA;MAC5E,YAAS;IACZ,eAAa,SAAA,QAAA,aAAA;IACb,mBAAiB,SAAkB,kBAAiB,CAAA;IACpD,cAAY,SAAA,QAAA,YAAA;IACZ,WAAS,SAAA,QAAA,SAAA;IACT,UAAQ,OAAA,QAAA,aAAsB,aAAU,QAAA,WAAA,SAAA,QAAA,QAAA;IACxC,mBAAiB,SAAA,IAAkB,iBAAiB,CAAA;IACpD,cAAY,SAAA,IAAkB,YAAY,CAAA;IAC1C,aAAW,SAAA,IAAkB,WAAW,CAAA;IACxC,eAAa,SAAkB,cAAa,CAAA;;MAIzC,aAAU,MAAA,MAAA,CAAA,CAAA,CAAA;MACV,eAAY,MAAc,EAAE;MAC5B,aAAU,MAAc,EAAE;AAG9B,EAAA,YAAO,MAAO;QAET;UAEE,oBAAiB,CAAI,UAAU;UAChC,UAAU,QAAW;AACxB,6BAAqB,KAAK;MAC3B;AACA,cAAQ,sBAAqB,MAAO;AACnC,qBAAa,KAAK;AAClB,gBAAQ;MACT,CAAC;IACF;UAEM,UAAO,EAAK,SAAS,KAAI;AAC/B,YAAQ,iBAAiB,UAAU,mBAAmB,OAAO;iBAEhD;AAEZ,cAAQ,oBAAoB,UAAU,mBAAmB,OAAO;IACjE;EACD,CAAC;AAGD,EAAA,YAAO,MAAO;;AAEb,sBAAiB;;;;QAIjB,iBAAiB;QACjB,YAAY;QACZ,WAAW;AACX,kBAAa;AAEb,YAAQ,YAAY;EACrB,CAAC;AAGD,EAAA,YAAO,MAAO;QACb,MAAM;AAEN,YAAQ,aAAa;EACtB,CAAC;WAEQ,eAAe;UACjB,yBACL,UAAU,kBAAa,QAAA,iBACvB,UAAU,sBAAsB,kBAAiB;UAC5C,uBACL,UAAU,cAAS,QAAA,aACnB,UAAU,aAAQ,QAAA,YAClB,UAAU,sBAAiB,IAAK,iBAAiB;QAE9C,sBAAsB;QACtB,sBAAsB;AACzB,6BAAuB,aAAY,QAAA,UAAA,QAAA,WAAA,IAAsB,iBAAiB,CAAA;AAE1E,4BAAsB;IACvB;QAEI,UAAU,iBAAY,QAAA,cAAmB;UAC5C,QAAM;QACL,QAAM,QAAA,gBAAkB;QACxB,cAAc,qBAAqB;;IAErC,WAAC,OAAA,QAAA,kBACyB,aACxB,0BAA0B,uBAC1B;UACD,QAAM;QACL,QAAQ,kBAAiB,QAAA,aAAA;QACzB,cAAc,qBAAqB;;IAErC;QAGC,uBACA,UAAU,iBAAY,IAAK,YAAY,KACvC,UAAU,gBAAW,IAAK,WAAW,KACrC,UAAU,cAAc,SAAQ,MAAA,SAAuB,cAAa,CAAA,EAAE,SAAQ,GAC7E;AACD,qBAAc;IACf;AAEA,gBAAS;MACR,eAAa,SAAA,QAAA,aAAA;MACb,mBAAiB,SAAkB,kBAAiB,CAAA;MACpD,cAAY,SAAA,QAAA,YAAA;MACZ,WAAS,SAAA,QAAA,SAAA;MACT,UAAQ,OAAA,QAAA,aAAsB,aAAU,QAAA,WAAA,SAAA,QAAA,QAAA;MACxC,mBAAiB,SAAA,IAAkB,iBAAiB,CAAA;MACpD,cAAY,SAAA,IAAkB,YAAY,CAAA;MAC1C,aAAW,SAAA,IAAkB,WAAW,CAAA;MACxC,eAAa,SAAkB,cAAa,CAAA;;EAE9C;WAES,gBAAgB;QACpB,WAAW,WAAM,IAAK,MAAM,EAAC,UAAU,WAAW,iBAAY,IAAK,MAAM,EAAC,cAAc;AAC3F,cAAO;IACR;QAGC,WAAW,WAAM,IAAK,MAAM,EAAC,UAAM,IACnC,MAAM,EAAC,iBAAiB,qBAAqB,WAC5C;AACD,cAAQ,OAAM;SACZ,YAAY,gBAAe,CAAA,CAAA,GAAA,IAAI,MAAM,EAAC;QACvC,UAAU,kBAAA;;IAEZ;AAEA,iBAAU,SAAA,IAAmB,MAAM,CAAA;EACpC;WAKS,UAAU;YACV,OAAO,IAAG,IAAK,uBAAuB,gBAC7C,gBAAe,MAAK,UAAU,WAAQ,IAAG,YAAY,IAAA,IAAG,WAAW,GAAA,IACnE,MAAM,EAAC,QACP,cAAA,CAAA;UAIK,eAAY,CAAA;UAEZ,YAAY,uBAAuB,aAAY;UAC/C,aAAU,OAAU,OAAM,MAAK,WAAW,OAAO;UACjD,YAAS,OAAU,MAAK,MAAK,WAAW,OAAO;QAErD,cAAY,UAAa,OAAM,CAAA,GAAG,UAAU,UAAU,MAAK,CAAA,GAAG,SAAS,GAAA;QACnE,gBAAe,MAAK,UAAU,UAAU;UAC3C,YAAU,gCAAmC,SAAS,KAAA;IACvD,OAAO;UACN,YAAU,yBAA4B,SAAS,KAAA;IAChD;UAEM,mBAAmB,cAAa,EAAC,SAAS;QAC5C,kBAAkB;iBACV,SAAS,cAAa,GAAE;AAClC,qBAAa,KAAI,EAChB,OACA,OAAO,SAAS,OAAO,IAAI,EAAA,CAAA;MAE7B;IACD;QAEI,UAAU,UAAa,QAAQ,QAAW;eACpC,QAAQ,OAAO,SAAS,KAAK,SAAS;YAC1C,oBAAoB,cAAa,EAAC,SAAS,KAAK,EAAA;AAEpD,qBAAa,KAAI,EAChB,OACA,OAAO,SAAS,OAAO,KAAK,EAAA,CAAA;MAE9B;2DAE6C,OAAO,IAAG,CAAA;iEACJ,OAAO,IAAG,CAAA;IAC9D;QAEA,OAAQ,YAAY;EACrB;WAKgB,eAAe,aAAU,QAAA,eAAkB;QAC1D,YAAU,CAAA,GAAA,IAAA;QACN,eAAe,UAAa,cAAc,GAAG;AAChD,6BAAuB,UAAU,UAAU;IAC5C;AACA,YAAO;EACR;WAMS,kBAAkB,OAAO;QAC7B,QAAQ,KAAK,SAAK,QAAA,UAAe,SAAQ;WAEtC,uBAAuB,yBAC7B,kBAAiB,GACjB,gBAAe,MAAK,UAAU,WAAQ,IAAG,YAAY,IAAA,IAAG,WAAW,GAAA,IACnE,MAAM,EAAC,UAAU,GACjB,KAAA;EAEF;WAMS,aAAa,OAAO;UACtB,SAAS,QAAQ,mBAAmB,gBAAe,CAAA,CAAA;QAErD,SAAS,KAAC,IAAI,MAAM,EAAC,WAAW,UAAU,MAAM,WAAW,QAAO;QAEtE,QAAM;MAAK;MAAQ,cAAc,qBAAqB;;uDAEX,QAAQ,MAAK,CAAA;EACzD;WAOS,SAAS,OAAO,QAAQ;YAC5B,UAAU,EAAC,KAAK,EAAA,QAAA,IAAU,UAAU,EAAC,KAAK;YAEtC,MAAM,OAAM,IAAK,uBAAuB,2BAA2B,KAAK;QAE5E;QACA,gBAAe,MAAK,UAAU,UAAU;AAC3C,cAAK,4BAA+B,IAAI;UAEpC,QAAQ;AACX,iBAAK,0DAA8D,MAAM,oBAAA,EAAsB,SAAS,KAAI;MAC7G,OAAO;AACN,iBAAK,yBAA6B,MAAM;MACzC;IACD,OAAO;AACN,cAAK,eAAkB,IAAI;UAEvB,QAAQ;AACX,iBAAK,gDAAoD,MAAM,mBAAA,EAAqB,SAAS,KAAI;MAClG,OAAO;AACN,iBAAK,sCAA0C,MAAM;MACtD;IACD;QAEA,UAAU,EAAC,KAAK,IAAI;eACb,UAAU,EAAC,KAAK;EACxB;;;;;;;;;;;;;;;4BAeQ,KAAK,GAAA,CAAI,SAAI,QAAA,SAAA,QAAA,OAAkB,KAAK,KAAK,IAAI,KAAK,OAAK,CAAAA,WAA9C,SAAI;;;;MACyB,OAAK,IAAE,IAAI,EAAC;MAAO,OAAK,IAAE,IAAI,EAAC;;;;;;;;;;;;;;;;;;8BAZlE,UAAO,SAAA,MAAP,OAAO;;uBAIX,YAAY,CAAA;yBAMoB,UAAU,CAAA;;0DAT9B,eAAa,OAAA,CAAA;yDACd,cAAY,OAAA,CAAA;;;;",
  "names": ["$$anchor"]
}
